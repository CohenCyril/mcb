\documentclass{book}

\input{mymacros.tex}
\input{myacronyms.tex}

\title{The Book}
\author{Assia, Enrico, \ldots (you are welcome)}

\begin{document}
\maketitle
\tableofcontents{}

\input{chConventions.tex}

\input{ch0.tex}

\part{The art of formalizing}


\chapter{Programming}

Find a more catchy title? The motivation is: how to define things:
objects, operations, (boolean) relations.

Theoretical content:
\begin{itemize}
\item Functions with simple types ($\lambda$, $\rightarrow$)
\item Inductive {\bf datas}
\item Programs by case analysis and recursion
\item Compute
\item Polymorphic datatypes (introduce $\Pi$, and its \Coq{} notation
  \C{forall}, for quantification over datatypes only)
\item Everyone has a type : \C{0 : nat : Type : Type}
\end{itemize}
This is more or less a standard introduction to (a flavor of)
functional programming, with two possible difficulties:
\begin{itemize}
\item Be precise but not too technical (e.g. on inductive types)
\item Find a line of speech which does not bore/discourage
  mathematicians.
\item Somehow the syntax of (this fragment of the) terms should made
  be clear and precise.
\end{itemize}

\Coq{} commands and features:
\begin{itemize}
\item Implicit arguments (only to go from system F to ML), \C{@}
\item Sections and its discharging, implicit types
\end{itemize}

Comparison with other approaches:
\begin{itemize}
\item Compare an axiomatic, equational presentation of arithmetic to
  its formalization as an inductive type with functions that
  compute. At this stage, where we do not have conversion yet, we
  cannot say much about the proofs and may be just point out that
  computation in \Coq{} is geared toward the reduction of functional
  programs.
\end{itemize}

\Coq{} types introduced:
\begin{itemize}
\item \C{bool, nat, seq, option, prod}
\end{itemize}

Programs presented in detailed examples/exercises:
\begin{itemize}
\item Elementary programs on \C{option}: \C{odflt, obind,}\dots
\item Elementary programs on \C{seq} (without the \C{eqType}):
  \C{size, map, iota,...}
\item Comparison functions on \C{bool, nat}
\item Comparison functions on containers, taking the comparison
  function on the type of stored elements in argument (mind the
  higher-order)
\item Boolean connectives, arithmetic operations on \C{nat}
\item Euclidean division, computation of prime factors, examples from
  elementary number theory
\item Examples of Gödel-style encoding from the {\tt choice.v} library.
\end{itemize}
If possible give a few context to the exercises, in order not to bore
the reader not familiar with programming. For instance do not say that
you encode sequences of nats in nats but give a few hints about the
use of Gödel encoding.

\chapter{Logics}

From calculability to proofs, hence the CC, and the fact that
reasoning principles without a computational content become axioms.

This is a non technical chapter and message should be:
\begin{itemize}
\item instantiation of a universal statement is application (also the pair)
\item Excluded middle is not available by default (choice?)
\item Conversion as a pervasive indistinguishably, what inside
  (beta, definition unfolding,...)
\item Dependent types: eq, sigma (which example?)
\end{itemize}

One options is: avoid relating type theory and other logics. We say:
we have a formal game where the basic elements are programs/functions
that come with types to avoid confusion. full stop. (no relation with
proof theory, set theory). maybe mention that roots are in calculability (hence
the choice to pick functions as primitive and not sets). This is lucky because
(computable) functions are today executable by a computer.  Still not all
concepts are "computable" hence some principles are problematic: EM,.... we
mainly stay in the lucky fragment (again no propaganda on intuitionistic logic,
constructive math; just a mention).


\chapter{Proofs}

Where one learns to do proofs.
Boolean reflection in practice, views, discussion on the definition of leq,
proofs on things defined in the
previous chapter, associated tactics, exercises on prime, div,
binomial, etc.

spec? A new vernacular to declare specs without typing coinductive and
by writing explicitly the equations.

\input{chTypeInference}

\input{chSigmaBool}

\chapter{Hierarchy}
Packaging records, the bigop hierarchy.
Scaling with packed classes and mixins, to the ssralg
hierarchy. Presentation of the content of ssralg in terms of structures
and of the theory? Should the latter be a separate chapter.

Maybe a plugin for a new vernacular to script the creation/declaration
of structures/instances so that the level basic can touch the argument
easily.

Explain what the abstraction barrier is (like unfolding a GRing projection)

\gotcha{if you see GRing.toto then you broke an abstraction barrier}

\mantra{
	if you have a proof in mind, don't let the system drive you
        to another, less clean and abstract, proof.
}

Declaring an instance is hard... we need to document the multuiple processes
for each structure in each hierarchy and possibily make a program out of it.

\chapter{Larger scale reflection (out of place)}
Four colours, decomposition in primes, example in peterfalvi. In
particular example where a case analysis does not follow the
constructors of an existing inductive type: then craft an ad hoc one
to hint the proof. This topic is probably at a wrong place.

\part{Mathematics in Mathematical Components}

\section{STYLE of these chapters}
These chapters hopefully in the following style:
\begin{itemize}
\item first math mode to review the (not so standard) definitions and
\item then touch some real proof script to show why/how the definition
  make it possible to model the proofs (as they are in math)
\item use the (few) examples to illustrate a cool proof strategy if
  any (not necessarily typical of the math subject, but that happens to
  be there, like in OOTHM paper: circular leq, symmetries, ad hoc
  decision procedure, ...)
\item try hard to show how CIC helps (which feature: HO, computation, dependent
	types \ldots), so that at the end we can sum up and make a synthesis of
	all that.
\end{itemize}

Maybe it is simpler to do it in 2 steps:
1) in this second part one identifies where CIC or the SSR style plays a
   crucial role
2) then we advertise these use cases in the first part to motivate
   the techniques, the complexity of the logic...

\chapter{Numbers}

What are the numbers available in the library? How to use them, casts
between types... Non trivial point in the formalisation:
axiomatization, order is defined from norm, partial orders (in
particular for complex numbers).


\chapter{Polynomials, Linear algebra}

2-stage presentation: interface plus explicit. Expansion of
Georges'ITP paper. Here is one of the main application of the choice
operator (complement a base).

\chapter{Quotients}

\chapter{Finite group theory}

Data-structures, how to craft the set of variants of a same theorem to
make the formalization handy. Permutations. Presentations?

\chapter{Representation theory, Character theory}

As an example of application, in particular of the linear algebra
theory.

\chapter{Galois Theory}


\chapter{Real closed fields}

\chapter{Algebraic closure}

\part{Conclusion and perspectives}

Let's be brave:
This part looks back to the techniques, methodologies and achieved
formalized libraries described in the book and summarizes the role
played by each on them, in the spirit of the introduction to the ssr manual.
May be also discusses the possible extensions
(like CoqEAL) or adaptation to the future evolutions of the system and
formalism (Cubical Coq, HITs...).

\part{Annexes}

\chapter{What is done where?}

\chapter{How tos}
suggestions:
\begin{itemize}
\item Get more information when you do not understand the error
  message
\item Search in the library
\item Canonical structures: define a new instance
\item Canonical structures: add a new structure
\item Give a relevant name to the lemma I just stated
\item Forbid unwanted expansions
\item Choose a notation (what not to do...)
\item Compute ``for real'' (Natbin, Coqeal)
\item MathComp script style
\end{itemize}
\chapter{Naming conventions}

\chapter{Index of notations}

\bibliographystyle{plain}
\bibliography{biblio}


\end{document}
