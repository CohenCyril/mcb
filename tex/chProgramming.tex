\Chapter{Computational definitions}{ Defining concepts by writing programs}\label{ch:prog}

%\textcolor{blue}{Find a more catchy title? The motivation is: how to define things: objects, operations, (boolean) relations.}

We will take the point of view that mathematics can be understood as
the study of objects, operations on these objects, and abstractions.  
Children start learning mathematics by counting, where the objects are
numbers and the operations are enumerating and adding.  In fact
numbers are already the result of an abstraction process.

What are the objects, the operations, and the abstractions in a given
mathematical corpus is quite fluctuant.  The objects of group theory
may sometimes be viewed as operations in another context.  Nevertheless,
in this chapter, we describe how some objects are described with the intent
that they are {\em inert}, that is, they are meant to be
manipulated by operations.  We also show how operations are described.

\section{Functions}
In this section, we expect readers to get acquainted with the notion
of function and the associated syntax.  We rely on natural
numbers that will only be described fully a few pages later.  There is an
addition operation noted with the \C{+} symbol associated to this
type, and this operation will also be described  a few pages later in
the text.

We start by considering the expression
\[ 2 + 1 \]
We can read this expression as an object, but also as the result of an
operation on an object, or as the result of an operation on two
objects.  Let us first consider the operation of {\em adding one to
a natural number}.  This operation is written in the following manner.

\begin{coq}{name=exfun}{}
  fun n => n + 1
\end{coq}
To write such an operation, we can start from the expression {\tt 2 +
  1} and isolate the object in this expression that is considered a
variable component for the operation, here {\tt 2}, we then replace
this object with a symbolic name, here {\tt n}.  We then encapsulate
the expression {\tt n + 2} with the prefix {\tt fun n =>} to express
that the operation produces a certain result {\tt n + 1} when given an
input {\tt n}.

So we have an expression which represents the operation of adding 1.
Applying this operation to the object {\tt 2} will be written this
way:

\begin{coq}{name=exapp}{}
  (fun n => n + 1) 2
\end{coq}
From the point of view of mathematical syntax, there are two unusual 
things in this line.  First, applying a function to an argument is simply
by writing the function on left of the argument, {\em not necessarily
with parentheses around the argument}; we will come back to this later.
Second, this object {\tt
  fun n => n + 1} is unusual.  When defining an operation, we usually
rely on a sentence {\em consider the function \(f\) from {\(\mathbb{N}\)}
to {\(\mathbb{N}\)} which maps \(n\) to \(n + 1\)}.  This would also be
written without natural language as follows:

\[f : 
\begin{array}{ccc}
{\mathbb{N}} &\rightarrow& {\mathbb{N}}\\
n &\mapsto& n + 1
\end{array}\]

The main difference is that the usual mathematical practice includes
the step of giving a name, here \(f\) to the operation.

When using Coq and ssreflect, the step of giving a name can also be
performed, in the following manner:

\begin{coq}{name=exdef}{}
Definition f := fun x => x + 1.
\end{coq}
An alternative syntax for exactly the same definition is as follows,
this alternative syntax is actually preferred.

\begin{coq}{name=exdef-pref}{}
Definition f x := x + 1.
\end{coq}
As was obvious in the mathematical formulation, operations are mainly
described by functions and mathematical practice is also to give
information about the domain and the codomain of functions at
definition time, as we did when writing
\({\mathbb{N}}\rightarrow{\mathbb{N}}\).  In Coq syntax, we will write
the same information as follows, because \C{nat} is the name used in
Coq to represent \(\mathbb{N}\):

\begin{coq}{name=exdef-type}{}
Definition f (x : nat) : nat := x + 1.
\end{coq}
In this description, {\tt nat} is called a {\em type}.  Types describe
collections of objects that can be treated in a uniform way.

Once a definition was made, the Coq system provides a command to
describe the relevant information about the constant that is defined:

\begin{coq}{name=about_f}{width=6cm,title=A function}
About f.
\end{coq}
\coqrun{name=about_f_run}{about_f}
\begin{coqout}{run=about_f_run}{title=Response,width=6cm}
f : nat -> nat
Argument scope is [nat_scope] ...
\end{coqout}
This response confirms that \C{f} is a function from
\({\mathbb{N}}\) to \({\mathbb{N}}\).
We also learn that the Coq system will pay attention to
arguments of \C{f} in such a way that overloaded notations
will be interpreted as notation for natural numbers.
\marginnote{maybe place a footnote here to point to another paragraph
about overloaded notations.  To  be discussed.}

We can be more inquisitive in our requests for information about
\C{f}, we can also require to know what is the value.  This is done in
the following manner:

\begin{coq}{name=print_f}{width=6cm,title=A function's value}
Print f.
\end{coq}
\coqrun{name=print_f_run}{print_f}
\begin{coqout}{run=print_f_run}{title=Response,width=6cm}
f = fun x : nat => x + 1
       : nat -> nat
\end{coqout}

We see in this example that {\em type information} is an important
feature of the language.  Type information is given twice in the
result of the \C{Print} command, once in the fragment ``\C{fun x : nat
  =>}'' and once in the second line, behind the colon ``\C{:}''.  The first
time, what we get is that the input of the function is expected to be
a value of type \C{nat}.  The second time, what we get is that the
type of \C{f} itself is the function type \C{nat -> nat}.  In fact,
the colon character (when surrounded by spaces) will always be used to
give type information.

The function \C{f} operates on natural numbers, of type \C{nat}, but
we can also define functions that operate on functions.  For instance,
the following definition introduces a function that takes a function
from \C{nat} to \C{nat} and returns a new function from \C{nat} to
\C{nat}.

\begin{coq}{name=repeat_twice_def}{}
Definition repeat_twice (g : nat -> nat) :=
  fun x => g (g x).
\end{coq}
Reading the first line of this statement, we see that a new object is
being defined, called \C{repeat_twice}.  We also see that this object
is a function the argument of which is a function of
type \C{nat -> nat}.  For later reference in the definition of
\C{repeat_twice}, the argument is given the name \C{g}.

Reading the second line of this statement, we see that the value
of \C{repeat_twice} when applied to one argument is a new
function, described using the ``\C{fun .. => ..}'' construct.  The
argument to that function is called \C{x}.  After the \C{=>} sign, we
find the ultimate value of this function.  This fragment of text, \C{g
  (g x)}, also deserves some explanation.  This fragment describes the
application of function \C{g} to an expression \C{(g x)}.  In turn,
the fragment \C{g x} describes the application of function \C{g} to
\C{x}.  The lesson here is that the application of a function to an
argument is not systematically written using parentheses, as is
customary in mathematics, but it is usually only written by
juxtaposing the function (on the left) and the argument (on the
right).  Parentheses are only added when they are needed to resolve
ambiguity.  Also expressions written with several subexpressions side
by side should be read as if there were parentheses around the
subgroups on the left.  We will illustrate this in the next few
examples.

When we want to apply the function \C{repeat_twice} to the function
\C{f} and the number \C{2} and perform the computation, this can be
written as follows:
\begin{coq}{name=eval_repeat_twice_f_two}{width=6cm,title=Evaluating
    an expression}
Eval compute in repeat_twice f 2.
\end{coq}
\coqrun{name=eval_run}{eval_repeat_twice_f_two}
\begin{coqout}{run=eval_f_run}{title=Response,width=6cm}
  = 4 : nat
\end{coqout}
From the syntax point of view, we wrote three subexpressions only
separated by space.  By default, the parser understands this as
\C{(repeat_twice f) 2}, so we actually have a first subexpression
which is \C{repeat_twice} applied to \C{f}.  According to the
definition of the first function, the value is an intermediate
function from \C{nat}
to \C{nat}, which is then applied to \C{2}.  The intermediate function
actually is \C{fun x => f (f x)}, so the result expression is \C{f (f
  2)}.  Remembering the definition of \C{f}, this expression can also
be read as \C{(2 + 1) + 1}.  Thus, after computation, the result is \C{4}.

\marginnote{it would be nice to have one more example here, or exercises.
To be discussed.}
\section{Data: cases and induction}
It is possible to define a datatype by giving in one declaration
the type, methods to build elements of this type, and methods to
use elements of the type while computing.  This approach is used
systematically in Coq to define a variety of basic datatypes, among
which boolean values, natural numbers, pairs and sequences of values
are the most prominents examples.  We will study these examples in
turn.
\subsection{Boolean values}
The type \C{bool} of boolean values contains two values that can be
distinguished in computations.  The declaration of this type happens
in one of the first files to be automatically loaded when Coq starts.
We can recover this declaration by using the \C{Print} command.

\begin{coq}{name=print_bool}{width=6cm,title=Type bool}
Print bool.
\end{coq}
\coqrun{name=print_bool_run}{print_bool}
\begin{coqout}{run=print_bool_run}{width=6cm,title=Response}
Inductive bool : Set := true : bool | false : bool
\end{coqout}
\marginnote{I guess we should use Type, also for bool, and not even mention Set}
This declaration states explicitely that there are only two cases for
elements of type \C{bool}.  the first case is given by the constant
\C{true}, the second case by the constant \C{false}.  Thus, the
declaration of the type gives in an obvious manner the type, \C{bool},
and ways to build all its elements, \C{true}, and \C{false}.  All definitions
in Coq, like this one, which define a type by providing at the same
time a type and the only ways to build elements of the type are called {\em
  inductive} definitions.  The two objects \C{true} and \C{false} are
called constructors.

In practice, this means that we can build a well-formed expression of
type \C{bool} by using either \C{true} or \C{false}.  Coq provides a
command to check that an expression is well-formed.  We can use this
command here to illustrate a use of the constructors.

\begin{coq}{name=check_true}{width=6cm}
Check true.
\end{coq}
\coqrun{name=check_true_run}{check_true}
\begin{coqout}{run=check_true_run}{width=6cm,title=Response}
true : bool
\end{coqout}

To use boolean values in computations, we need a construct that makes
it possible to return different values depending on whether some
boolean input is \C{true} or \C{false}.  This is provided by an \C{if
  .. then .. else} construct, as illustrated here:

\begin{coq}{name=if_example}{}
 if true then 3 else 2
\end{coq}
More generally, we can define a function that takes a boolean value as
input and returns one of two possible natural numbers in the following
manner:

\begin{coq}{name=definef23}{}
Definition f23 b := if b then 2 else 3.
\end{coq}
\coqrun{name=definef23_run}{definef23}
Readers are invited to test this function using the \C{Eval compute in} command.

The ssreflect library provides a collection of boolean operations that
mirror reasoning steps on truth value.  The functions are called
\C{negb}, \C{orb}, \C{andb} , \C{implyb}, respectively with notations
\C{\~\~},  \C{||}, \C{&&}, and \C{==>} (the last three operators are
infix, they appear between the arguments as in \C{b1 && b2}).
  In
particular, it should be
noted that the symbol \C{\~\~} uses two characters \C{\~}, but it should
not be confused with two iterations of the one-character symbol
\C{\~}.  In practice, readers become quickly accustomed to the
distinction between the two symbols.

For instance, the function \C{andb} is defined as follows in one of
the preamble files:

\begin{coq}{name=define_andb}{}
Definition andb b1 b2 := if b1 then b2 else false
\end{coq}

% \subsubsection{TODO : A note on associativity for notations}

\subsection{natural numbers}
The description of natural numbers in the Coq system is inspired from
the work of Peano at the beginning of the twentieth century.  The
basic idea is that any natural number is either 0 or the successor of
an existing natural number.  Moreover, the successor operation is
injective.  Peano also considers supplementary operations, like
addition and multiplication, but we shall see that the Coq system
provides enough machinery so that these operations can be described as
defined functions on top of the basic tools.

The description of natural numbers as essentially generated by a
constant \C{O} (to represent 0) and a function \C{S} to represent 
the successor operation is given in the definition of the type
\C{nat}. This can
be obtained from the Coq system by using the \C{Print} command.

\begin{coq}{name=print_nat}{width=6cm,title=Type nat}
Print nat.

\end{coq}
\coqrun{name=print_nat_run}{print_nat}
\begin{coqout}{run=print_nat_run}{width=6cm,title=Response}
Inductive nat : Set :=  O : nat | S : nat -> nat
\end{coqout}

This declaration states that the only ways to produce natural numbers
are by using the constant \C{O}, or by applying the function \C{S} to
an already existing natural number.  So \C{O} is a natural number, \C{S O} is a
natural number, \C{S (S O)}, and so on, and these are the only natural
numbers.  When interacting with Coq, we will often see decimal
notations, but these are only a parsing and display
facility provided to the user for readability.  So \C{O} is displayed
\C{0}, \C{S O} is displayed \C{1}, etc.  Users can also type decimal
numbers to describe values, but these are automatically translated into
terms built with \C{O} and \C{S}.

The ssreflect library provides a few notations to make use of the
constructor {\tt S} more intuitive to read.  In particular, if \C{x}
is a value of type \C{nat}, \C{x.+1} is another way to write \C{S
  x}.  The \C{.+1} notation binds more strongly than function
application, so that this notation makes it possible to avoid some
needs for parentheses.
Similar notations are provided for up to 4 uses of the \C{S}
constructor.  This can be illustrated by the following dialog (where
we assume that \C{f} is a function of type \C{nat -> nat}).
  For instance, we can write the following
expression, when \C{f} is already defined with type \C{nat -> nat}.

\begin{coq}{name=f_plus_one}{width=6cm}
Check fun x => f x.+1.

Locate ".+4".
$~$
$~$
$~$
\end{coq}
\coqrun{name=f_plus_one_run}{f_plus_one}
\begin{coqout}{f_plus_one_run}{width=6cm,title=Response}
fun x => f x.+1 : nat -> nat

Notation        Scope
"n.+4" := S (S (S (S n)))  : nat_scope
    (default interpretation)
\end{coqout}

When writing functions that compute on natural numbers, we can
proceed by cases, as was done in the previous section for boolean
values.  Again, there are two cases, either the natural number used in
the computation is \C{O} (also written \C{0}) or it is \C{n.+1} for
some \C{n}, but in the latter case, it is often useful to also be able
to use \C{n} for further computations.  The usual approach in this
case is to describe the two cases as patterns: if the data fits one of
the patterns, the computation proceeds with the corresponding
computation.  Here is an example:

\begin{coq}{name=pattern_on_nat}{}
match n with | O => true | p.+1 => false end
\end{coq}
In this expression we describe a computation where some decision is
taken depending on the value of the number \C{n}.  The fragment 
\C{| 0 => true} expresses that when \C{n} is \C{0}, the final value is
\C{true}.  In this expression, \C{0} is a pattern and the computation
checks whether \C{n} matches this pattern.  The fragment
\C{| p.+1 => false}  expresses that when \C{n} is the successor of
some number \C{p} the final value is \C{false}.  In other words, when
\C{n} is the successor of somebody, then the returned value is
\C{false}.  The value \C{p} mentioned in this pattern is not known in
advance, it is actually computed at the moment the \C{n} is matched
against the pattern.  For instance, if \C{n} is \C{5}, then the value
computed for \C{p} is \C{4}.  In this particular instance, \C{p} is
not used, so that we can also write as follows:

\begin{coq}{name=pattern_on_nat}{}
match n with | 0 => true | _.+1 => false end
\end{coq}
The symbol \C{_} is used to represent a pattern whose value will never be
used.

This pattern can also be written using an ``\C{if .. then .. else}''
syntax:

\begin{coq}{name=pattern_on_nat_0}{}
if n is 0 then true else false
\end{coq}

For an example where the pattern variable is actually used, we can
observe the function that returns the predecessor of a natural number
when it exists, or 0 otherwise.  This function already exists in the library,
but we could redefine it as follows:

\begin{coq}{name=pred}{}
Definition my_pred n := if n is u.+1 then u else n.
\end{coq}
Reading this function in detail, we see that the argument \C{n} is
matched with the pattern \C{u.+1}.  When this comparison
succeeds, the variable \C{u} receives the value of the immediate
subterm of \C{n} the computation proceeds by computing the expression
in the \C{then} branch of the \C{if} statement.  This branch contains
exactly \C{u}, so this is the result value.  When the comparison
fails, this means that \C{n} has the form \C{0}, the returned value is
\C{n}, or equivalently \C{0}.

Assume for instance that \C{n} is \C{2}, in other words \C{n} is the
successor of the successor of \C{O}, which we could also write
\C{0.+1.+1}.  When matching \C{0.+1.+1} against the pattern \C{u.+1}
the value of \C{u} is found to be \C{0.+1}, in other words \C{1}.

The pattern used in the \C{if} statement can be composed of
several nested levels of the \C{.+1} pattern.  For instance,
if we want to write a function
that returns \(n-5\) for every input larger than or equal to 5 and 0
for every input smaller than 5, we can write the following definition:

\begin{coq}{name=pred5}{}
Definition my_pred5 n :=
  if n is u.+1.+1.+1.+1.+1 then u else 0.
\end{coq}
On the other hand, if we want to describe a different computation for
three different cases and use variables in more than one case, we need
to revert to the ``\C{match .. with .. end}'' syntax.  Here is an
example:

\begin{coq}{name=awkward5}{}
Definition three_patterns n :=
  match n with
  | u.+1.+1.+1.+1.+1 => u
  | v.+1 => v
  | O => n
  end.
\end{coq}
This function maps any number \(n\) larger than or equal to 5 to \(n-5\),
any number \(n \in \{1, \ldots, 4\}\) to \(n-1\), and \(0\) to \(0\).

The pattern matching construct \C{match .. with | .. => .. end}
contains an arbitrary large number of {\em pattern matching rules} of
the form \C{| \(pattern\) => \(result\)}.  For the symbols that are allowed
in the pattern, they are essentially restricted to \C{O}, \C{S} and
variable names.  Thanks to notations, a pattern can also contains
occurrences of the notation ``\C{.+1}'' which represents \C{S}, and
decimal numbers, which represent the corresponding terms built with
\C{S} and \C{O}.  When a variable name occur, this variable can be
re-used in the result part.  When computing with a natural number, all
the pattern matching rules are tried successively against this number.
For instance, if the input is \C{2}, in other words \C{0.+1.+1}, the first
rule cannot match, because this would require that \C{0} matches
\C{u.+1.+1.+.1} and we know that \(0\) is not the successor of any
natural number, when it comes to the second rule \C{0.+1.+1} matches
\C{v.+1}, because the rightmost \C{.+1} in the value of \C{2} matches
the rightmost \C{.+1} part in the pattern and \C{0.+1} matches the \C{v} part
in the pattern.

\subsection{Recursion for integers}
With only pattern-matching, we do not cope well with the fact that the
type \C{nat} of natural numbers actually contains an infinity of
elements.  To really handle infinity, the Coq system provides another
facility, known as {\em recursivity}.  The idea behind recursivity is
that we can define a function while supposing that it is already
defined for a subset of the type.  This adds a new element for which
the function is defined, and progressively this makes that the
function is defined for all elements of the type.

Many usual functions to deal with natural numbers are
defined recursively.  For instance, we can define addition in the
following manner:

\begin{coq}{name=redefine_add}{}
Fixpoint my_add n m :=
  if n is p.+1 then (my_add p m).+1 else m
\end{coq}
In this line, we learn that the keyword for defining a recursive
function is \C{Fixpoint}.  We see also that the function being
defined, here called \C{my_add}, is used in the definition of the
function \C{my_add} itself.  This text expresses that the value of
\C{my_add p.+1 m} is
\C{(my_add p m).+1} and that the value \C{my_add 0 m} is \C{m}.
This first equality may
seem redundant, but there is progress when reading this equality from
left to right: an addition with \C{p.+1} as the left-hand side argument
is explained with the help of addition with \C{p} as the left-hand side
argument, and \C{p} is a smaller number than \C{p.+1}.  When considering the
expression \C{my_add 2 3}, we can know the value by performing the following
computation:
\marginnote{LR: the meaning of ``first'' or ``second'' pattern matching is not clear with a definition using ``if''}
\begin{tabbing}
\C{adfasdfasdfafafafafafaf}\=\kill
\C{my_add 2 3} \> use the second pattern matching rule, \C{p = 1}\\
\C{(my_add 1 3).+1} \> use the second pattern matching rule, \C{p = 0}\\
\C{(my_add 0 3).+1.+1} \> use the first pattern matching rule\\
\C{3.+1.+1}\> remember that \C{5 = 3.+1.+1}\\
\end{tabbing}
When the computation finishes, the symbol \C{my_add} disappears.  In
this sense, the recursive definition is really a definition.

An alternative way of writing \C{my_add} relies explicitely on
pattern-matching rules instead of relying on an \C{if} statement.
This can be written as follows:

\begin{coq}{name=my_add_redef}{}
Fixpoint my_add n m :=
  match n with
  | 0 => m
  | p.+1 => (my_add p m).+1
  end.
\end{coq}
With this way of writing the recursive function, it becomes obvious that
pattern-matching rules describe equalities between two symbolic
expressions, but these equalities are always used from left to right during
computations.

When writing recursive functions, the Coq systems imposes the
constraint that the described computation must be guaranteed to
terminate.  This guarantee relies on an analysis of the function's
description, to make sure that recursive calls always happen with a
given argument that decreases.  The most frequent technique to
establish this guarantee is that recursive calls happen on a variable
and this variable was introduced by a pattern in a pattern-matching
construct or in an \C{if} statement, with the additional constraint
that the pattern-matching construct observes a variable that was one
of the function's inputs.

For instance, in the case of \C{my_add}, the recursive call happens
with \C{p} as the first argument, \C{p} was introduced by the pattern \C{p.+1}
in the corresponding pattern-matching rule, the pattern-matching
construct was observing \C{n}, and \C{n} is the first argument of the
function \C{my_add}.

In function \C{my_add}, the first argument \C{n} is only used to
repeat \C{n} times the operation of adding a \C{.+1} on the second
argument.  This corresponds to the fact that the \C{p} is only used in
the recursive call.  The programming language makes it possible to do
more.  For instance, for a given function \(f\), we might want to add all
the values \(f 0 + f 1 + \cdots + f n\).  This would be done in the
following manner:

\begin{coq}{name=example_sum_f}{}
Fixpoint sum_f (f : nat -> nat) (n : nat) :=
  if n is p.+1 then my_add (f n) (sum_f p) else f 0.
\end{coq}

If addition tantamounts to repeating the operation of adding a \C{.+1}
to one of the arguments, subtraction tantamounts to repeating the
operation of fetching a subterm of the first argument.  This is also
easily expressed using pattern matching constructs.  Here again,
subtraction is already defined in the libraries, but we can play the game
of re-defining our own version.

\begin{coq}{name=my_sub}{}
Fixpoint my_sub n m :=
  match n, m with
  | p.+1, q.+1 => my_sub p q
  | _ , _ => n
  end.
\end{coq}
From a mathematical point of view, this definition can be quite
unsettling.  The second pattern matching rule indicates that when
the second argument of the subtraction is \C{0}, then the result is
the first argument.  But it also covers the case where the second
argument is non-zero while the first argument is 0.  This phenomenon
is imposed by the fact that the function must be total (all functions
are total in the Coq system) and the type \C{nat} does not contain any
element to represent negative numbers.  When the second argument is non-zero
and the first argument is zero, a value must still be returned and
{\em this value must be a natural number}.  In the long run, this
problem will be solved by introducing another type of numbers with
negative integers.

Recursive functions also make it possible to test data for
equality. We can for example write a function with two arguments, that
returns \C{true} exactly when the two arguments are equal.

\begin{coq}{name=nat_eq_def}{}
Fixpoint my_eq_nat n m :=
  match n, m with
  | 0, 0 => true
  | p.+1, q.+1 => my_eq_nat p q
  | _, _ => false
  end.
\end{coq}
The last rule in the code of this function actually covers two cases :
\C{0, _.+1} and \C{_.+1, 0}.

For equality test functions, it is useful to add a more intuitive
notation.  For instance we can attach a notation to \C{my_eq_nat} in
the following manner:

\begin{coq}{name=notation_my_eq}{}
Notation "x == y" := (my_eq_nat x y)
  (at level 70, no associativity).
\end{coq}
This equality test function can then be used in other algorithms.  Now
that we have programmed this equality test function, we can verify
that the Coq system really identifies various ways to write the same
natural number.

\begin{coq}{name=equalities}{width=6cm}
Eval compute in 0 == O.
Eval compute in 1 == S O.
Eval compute in 1 == 0.+1.
Eval compute in 2 == S O.
Eval compute in 2 == 1.+1.
Eval compute in 2 == my_add 1 0.+1
\end{coq}
\coqrun{name=equalities_run}{equalities}
\begin{coqout}{equalities_run}{width=6cm}
= true : bool
= true : bool
= true : bool
= false : bool
= true : bool
= true : bool
\end{coqout}

In this section, we introduced a variety of functions and notations
for operations on natural numbers.  In practice, these functions and
notations are already loaded by the preamble that is provided in the
introductory chapter, so that we work in a context where addition,
multiplication, comparison, are already provided for direct use.

In
the next section, we will assume that readers start again with 
a fresh instance of the Coq system and load the preamble, so that
function \C{my_add}, \C{my_sub}, \C{my_eq_nat} are not provided
anymore.  On the other hand, the ssreflect library provides functions
and notations for addition (function \C{addn}, infix
notation \C{+}), multiplication
(\C{muln}, \C{*}), subtraction (\C{subn}, \C{-}), division (\C{divn},
\C{\%/}),  modulo (\C{modn}, \C{\%\%}), exponentiation (\C{expn}, \C{\^})
equality comparison (\C{eqn}, \C{==}), order
 comparison (\C{leq}, \C{<=}).  For the order on natural numbers,
the notation \C{n < m} is also provided to mean exactly \C{n.+1 <= m}.


\subsection{The sequence datatype}
It is often the case that we wish to group several objects in a
sequence that can be manipulated as a single object.  For instance, we
might want to compute the sequence of all predecessors or all divisors
of a number.  The sequence datatype is provided for this purpose.

The ssreflect library provides this datatype under the name \C{seq},
but defines it as an alias for the pre-existing type \C{list} given in the
Coq preamble.  The definition of type \C{list} is as follows:

\begin{coq}{name=list_def}{}
Inductive list (A : Type) : Type :=
  nil : list A
| cons : A -> list A -> list A.
\end{coq}
This definition actually describes the type of lists as a {\em
  polymorphic type}.  This means that there is a different type
\C{list A} for each possible choice of a type \C{A}.  The type of the
fonction \C{cons} is devised specifically to describe how to produce a
new list of type \C{list A} by combining an element of \C{A} and an
existing list of type \C{list A}.  This also means that this data-type
does not allow users to construct lists where the first element would be
a boolean value and the second element would be a natural number.

In principle, all objects of the datatype definition have a type
argument.  Thus, \C{list} is a function of type \C{Type -> Type} and
\C{nil} is a function that takes a type \C{A} as argument and returns
an empty list of type \C{list A}.  The notation \C{.. -> ..} is not
well suited for this kind of situation and the type of \C{nil} is
rather written as follows:

\begin{coq}{name=type_of_nil}{}
  forall A:Type, list A
\end{coq}
The same goes for the other constructor of list, named \C{cons}.  This
function actually takes three arguments: a type \C{A}, a value in this
type, and a value in the type \C{list A}.  The type of \C{cons} is
thus written as follows:

\begin{coq}{name=type_of_cons}{}
  forall A:Type, A -> list A -> list A
\end{coq}
This information can actually be obtained from the system by using the 
command \C{About} (the answer uses the fact \C{seq} is an alias for \C{list}).

\begin{coq}{name=about_cons}{width=3cm}
About cons.
$~$
$~$
$~$
\end{coq}
\coqrun{name=about_cons_run}{about_cons}
\begin{coqout}{about_cons_run}{width=9cm,title=Response}
cons : forall A: Type, A -> seq A -> seq A

Argument A is implicit and maximally inserted
Argument scopes are [type_scope _ seq_scope]
\end{coqout}
In practice, the Coq system implements a mechanism to avoid that
people need to give the type argument to the \C{cons} function.  This is
the information meant by the message \C{Argument A is implicit and
  ..}.  Every time users write \C{cons}, the system automatically
inserts an argument in place of \C{A}, so that this argument does not
need to be written (the argument is {\em implicit}).  It is then the
job of the Coq system to guess what this argument is when looking at
the first explicit argument given to the function.  The same happens
to the type argument of \C{nil}.  In the end, this makes that user can
write the following expression.

\begin{coq}{name=check_list_2}{width=6cm}
Check cons 2 nil.
\end{coq}
\coqrun{name=check_list_2_run}{check_list_2}
\begin{coqout}{check_list_2_run}{width=6cm,title=Response}
[:: 2] : seq nat
\end{coqout}
This example shows that the function \C{cons} is only applied
explicitely to two arguments.  The first argument, which is implicit,
has been guessed so that it matches the actually type of \C{2}.  For 
\C{nil} also, the argument has been guessed to match the constraints
that it is used in a place where a list of type \C{list
  nat} is expected.  This example also shows that the ssreflect
library provides a collection of notations for lists.  In particular
\C{cons a l} is usually written \C{a :: l} when \C{l} is a variable
name, and lists terminated by \C{nil} are written with square brackets.

When programming with sequences, we can again use the  pattern matching
construct to express how data can be retrieved from a sequence.  For
instance, to retrieve the first element of a sequence of natural numbers
or 0 if the sequence does not contain any element, we can write the
following code:

\begin{coq}{name=first_element}{}
Definition first_element_or_0 (s : seq nat) :=
  match s with
  | nil => 0
  | cons a _ => a
  end.
\end{coq}
Using the notations for {\tt cons} and {\tt nil}, we can also write

\begin{coq}{name=first_element1}{}
Definition first_element_or_0 (s : seq nat) :=
  match s with
  | [::] => 0
  | a :: _ => a
  end.
\end{coq}
Using the \C{if} syntax, we can write:

\begin{coq}{name=first_element2}{}
Definition first_element_or_0 (s : seq nat) :=
  if s is a :: _ then a else 0.
\end{coq}
\subsection{Recursion for sequences}
Because the second argument of \C{cons} can also be a sequence, it is
possible to build sequences that are quite long, but always finite.
In this respect, the sequences are very similar to the natural
numbers.  Recursion is again the solution to cope with the arbitrary
length of sequences with functions that can be described concisely.

For instance, we can define a size function that counts the number of
elements in a sequence.

\begin{coq}{name=def_size}{}
Fixpoint my_size A (s : seq A) :=
  if s is _ :: s' then (my_size s').+1 else 0.
\end{coq}
During computation on a given sequence, this function will traverse
the whole list, adding 1 to the result for ever
\C{cons} pattern that is encountered.  It should be noted that in this
definition, the function \C{my_size} is described as a two argument
function, but the recursive call \C{my_size s'} is done by providing
explicitely only one argument, \C{s'}.  This is because we started the
Coq session with, among other commands, the command ``\C{Set Implicit
  Arguments}''.  According to this directive, the Coq system makes
arguments of functions that can be guessed from the type of following
arguments automatically implicit.  This feature is effective directly
at definition time.

Another example of recursive function on lists is a function that constructs
a new list where all elements are values of a given function applied to
the elements of a list.  This function can be defined in this
manner.

\begin{coq}{name=def_map}{}
Fixpoint my_map A B (f : A -> B) s :=
  if s is e :: s' then f e :: my_map f s' else nil.
\end{coq}
With this function it is also interesting to understand how we can
improve the notations.  For instance, we will add a notation that
makes it more apparent that the result is {\em the sequence of all
expressions \(f(i)\) for \(i\) taken from another sequence}.

\begin{coq}{name=notation_map}{}
Notation "[ 'seq' E | i <- s ]" := (my_map (fun i => E) s)
  (at level 0, E at level 99, i ident,
   format "[ '[hv' 'seq' E '/ ' | i <- s  ] ']'").
\end{coq}
For instance, with this notation we write the computation of successors
for a given sequence of natural numbers as follows:

\begin{coq}{name=try_map_notation}{width=7.cm}
Eval compute in [seq i.+1 | i <- [:: 2; 3]].
\end{coq}
\coqrun{name=try_map_notation_run}{try_map_notation}
\begin{coqout}{try_map_notation_run}{width=5cm,title=Response}
= [:: 3; 4] : seq nat
\end{coqout}
The function \C{my_map} and the associated notation were only declared
in this section for illustration purposes, but we will assume that
they don't exist for the rest of the book.  The ssreflect library
provides a collection of useful functions and notations to work on
sequences, as described in the header of the file \C{seq.v}.  For
instance, the notation \C{[seq F | i <- s]} is already provided there,
together with \C{[seq i | i < s | p]}, which makes it possible to
filter the elements of a sequence for which \C{p} is the boolean
value \C{true}.  A function \C{cat} (with infix notation \C{++}) is
also provided to catenate two sequences together.

\section{Sections and local environments}
When several functions are designed to work on similar data, it is
useful to set a working environment where the common data is declared
only once.  Such a working environment is called a \C{Section}, and
the data that is local to this section is declared using \C{Variable}
commands.  A typical example happens when describing functions that
are polymorphic and rely in a uniform way on a given type and existing
functions in this type.  Here we shall illustrate this with a small
experiment on monoid structures:

\begin{coq}{name=simple_monoid_structure}{}
Section my_monoid.

Variable (T : Type) (naught : T) (op : T -> T -> T).

Fixpoint my_iter x n :=
  if n is p.+1 then op x (my_iter x p) else naught.
\end{coq}
When writing the definition of \C{my_iter}, we can use the type
\C{T}, the element in \C{T}, and the operation \C{op} which are
assumed to exist.  However, these various elements have no
definition, so that every computation made with them is symbolic.
This is illustrated by the following example.

\begin{coq}{name=compute_in_abstract}{title=Response, width=6.cm}
Variable x : T.
Eval compute in my_iter x 3.
\end{coq}
\coqrun{compute_in_abstract_run}{compute_in_abstract}
\begin{coqout}{compute_in_abstract_run}{width=6.cm}
$~$
op x (op x (op x naught)) : T
\end{coqout}
The section is opened by the \C{Section} command.  It can later be
closed by an \C{End} command.  When this happens, all the variables
that were defined in the section become unavailable, but the
definitions that were declared inside the section are still valid and
they are still available outside the section where they were defined.
If these definitions depended on one of the section variables, this
section variable becomes an extra argument to the function.

For instance, the function \C{my_iter} is defined inside the section
and relies on the type \C{T}, the value \C{naught}, and the operator
\C{op}.  Inside the section, the function \C{my_iter} appears to be a
function of two arguments (in types \C{T} and \C{nat}) and with a
result in type \C{T}.  When closing the section, it becomes a function
with five arguments.  The first three arguments must be a type, a
value in this type, and a binary operation in this type.  Because the
first argument's value is useful to describe the type of other
arguments, we need to use the notation \C{forall} that was already
necessary to describe the type of \C{nil} and \C{cons} when discussing
sequences.

\begin{coq}{name=close_section}{width=4cm}
About my_iter.
$~$
$~$
$~$
End my_monoid.
About my_iter.
$~$
$~$
$~$
$~$
\end{coq}
\coqrun{close_section_run}{close_section}
\begin{coqout}{close_section_run}{title=Response, width=8cm}
my_iter : A -> nat -> A
Argument scopes are [_ nat_scope]
my_iter is transparent
Expands to: Constant Top.my_monoid.my_iter
$~$
my_iter : forall A : Type, A -> (A -> A -> A) -> A -> nat -> A
Argument A is implicit
Argument scopes are [type_scope _ _ _ nat_scope]
\end{coqout}
Thus, the function \C{my_iter} that was defined inside the section
becomes very useful, because it can be applied to any type, element,
and operator, as long as they are consistent with the type
constraints.  The type argument to the function \C{my_iter} is
actually implicit, so that it never needs to be provided and the
function has only 4 explicit arguments.
For instance, we can apply this function the
number \C{1}, and the multiplication operation on natural numbers
to compute a function that has the same behavior as power:

\begin{coq}{name=compute_in_real}{width=6cm}
Eval compute in my_iter 1
    (fun x y => x * y) 3 3.
\end{coq}
\coqrun{name=compute_in_real_run}{compute_in_real}
\begin{coqout}{compute_in_real_run}{title=Response, width=6cm}
= 27 : nat
\end{coqout}

This mechanism of sections is very useful to organize formal
mathematical developments in a style that is closed to what would
happen in a mathematics textbook, where some concepts are fixed for a
fragment of the exposition, where they are considered in an abstract
way, and then used as variable parameters in other part of the book,
where they can be instantiated to arbitrary objects of the right type.


\section{Exercises}


%%%%%%%%
\begin{Exercise}[label=ex:pair,difficulty=0,title={Pairs}]
Defined the pair datatype such that the following notation
applies.  Also define the first projection.

\begin{coq}{}{width=7cm}
Notation "( A , B )" := (mk_pair A B).
Eval compute in fst (4,5).
\end{coq}
\begin{coqout}{}{width=5cm}
     = 4
     : nat
\end{coqout}

\end{Exercise}

%%%%%%%%
\begin{Exercise}[label=ex:iteradd,difficulty=0,title={Addition with iteration}]
Define a program computing the sum of two natural numbers
by using \C{iter}.
\end{Exercise}

%%%%%%%%
\begin{Exercise}[label=ex:itermul,difficulty=0,title={Addition with iteration}]
Define a program computing the product of two natural numbers
by using \C{iter}.
\end{Exercise}

%%%%%%%%
\begin{Exercise}[label=ex:nth,difficulty=0,title={nth element}]
Define a program taking a list, a natural number and a default value.  Such
program returns the n-th element of the list if n is smaller than the size of
the list.  It returns the default value otherwise.

\begin{coq}{}{width=7cm}
Eval compute in
  nth 0 [:: 3; 7; 11; 22] 2.
Eval compute in
  nth 0 [:: 3; 7; 11; 22] 7.
\end{coq}
\begin{coqout}{}{width=5cm}
     = 11
     : nat
     = 0
     : nat
\end{coqout}
\end{Exercise}

%%%%%%%%%
\begin{Exercise}[label=ex:rev,difficulty=0,title={List reversal}]
Define the program \C{rev} that takes reverses the order of the elements
of a list. 

\begin{coq}{}{width=5cm}
Eval compute in
  rev [:: 1; 2; 3].
\end{coq}
\begin{coqout}{}{width=7cm}
 = [:: 3; 2; 1]
 : seq nat
\end{coqout}
\end{Exercise}

%%%%%%%%%%%%%
\begin{Exercise}[label=ex:flatten,difficulty=1,title={List flattening}]
Define the program \C{flattern} that takes a list of lists and returns
their concatenation.  Don't write a recursive function, just reuse
the concatenation function and one of the higher-order iterators
seen so far.
\marginnote{Assumes foldr and cat}

\begin{coq}{}{width=7.3cm}
Eval compute in
  flatten [:: [:: 1; 2; 3]; [:: 4; 5] ].
\end{coq}
\begin{coqout}{}{width=5cm}
 = [:: 1; 2; 3; 4; 5]
 : seq nat
\end{coqout}
\end{Exercise}


%%%%%%%%%
\begin{Exercise}[label=ex:allwords,difficulty=2,title={All words of size n}]
Define the \C{all\_words} program that takes in input a
length \C{n} and sequence of symbols \C{alphabet}.
Such program has to generate a list of all words (i.e. list
of symbols) of size \C{n}.

\begin{coq}{}{width=5.5cm}
Eval compute in
  all_words 2 [:: 1; 2; 3].
\end{coq}
\begin{coqout}{}{width=7cm}
 = [:: [:: 1; 1]; [:: 1; 2]; [:: 1; 3];
       [:: 2; 1]; [:: 2; 2]; [:: 2; 3];
       [:: 3; 1]; [:: 3; 2]; [:: 3; 3]]
 : seq (seq nat)
\end{coqout}
\end{Exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Solutions}

\begin{Answer}[ref=ex:pair]

\begin{coq}{}{}
Inductive pair (A B : Type) := mk_pair (a : A) (b : B).
Definition fst A B (p : pair A B) := let: (x, _) := p in x.
\end{coq}

\end{Answer}

%%%%%%%%%%
\begin{Answer}[ref=ex:iteradd]

\begin{coq}{}{}
Definition addn n1 n2 := iter n1 S n2.
\end{coq}

\end{Answer}

%%%%%%%%%%
\begin{Answer}[ref=ex:itermul]

\begin{coq}{}{}
Definition muln n1 n2 := iter n1 (addn n2) 0.
\end{coq}

\end{Answer}

%%%%%%%%%%
\begin{Answer}[ref=ex:nth]

\begin{coq}{}{}
Fixpoint nth T (def : T) (s : seq T) n :=
  if s is x :: s' then if n is n'.+1 then nth def s' n' else x else def.
\end{coq}

\end{Answer}

%%%%%%%%%%
\begin{Answer}[ref=ex:rev]

\begin{coq}{}{}
Fixpoint catrev T (s1 s2 : seq T) :=
  if s1 is x :: xs then catrev xs (x :: s2) else s2.

Definition rev T (s : seq T) := catrev s [::].
\end{coq}

\end{Answer}

%%%%%%%%%%%%%

\begin{Answer}[ref=ex:flatten]

\begin{coq}{}{}
Definition flatten T (s : seq (seq T)) := foldr cat [::] s.
\end{coq}

\end{Answer}

%%%%%%%%
\begin{Answer}[ref=ex:allwords]

\begin{coq}{}{}
Definition all_words n T (alphabet : seq T) :=
  let prepend x wl := [seq x :: w | w <- wl] in
  let extend wl := flatten [seq prepend x wl | x <- alphabet] in
  iter n extend [:: [::] ].
\end{coq}

\end{Answer}



%%%%%%%%%%%%%%%%%%%%%%%%%% End of written part %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theoretical content:
% \begin{itemize}
% \item Functions with simple types ($\lambda$, $\rightarrow$): functions are the primitive concept
% \item Inductive {\bf datas}
% \item Programs by case analysis and recursion
% \item Compute (beta, delta, iota) example of beta (that helps later on to explain a predicate for elim principles)
% \item Polymorphic datatypes (introduce $\Pi$, and its \Coq{} notation
%   \C{forall}, for quantification over datatypes only)
% \item Everyone has a type : \C{0 : nat : Type : Type}, types avoid confusion
% \end{itemize}
% This is more or less a standard introduction to (a flavor of)
% functional programming, with two possible difficulties:
% \begin{itemize}
% \item Be precise but not too technical (e.g. on inductive types)
% \item Find a line of speech which does not bore/discourage
%   mathematicians.
% \item Somehow the syntax of (this fragment of the) terms should made
%   be clear and precise.
% \item types depending on terms (matrix x m)
% \end{itemize}


% \begin{itemize}
% \item Use monomorphic instances/compatible versions of the notations
%   that will later be generalized using canonical structures;
% \item For instance the infix \C{==} is the comparison on \C{nat}
% \item Further examples: \verb+\sum_(i <- l) F i+, \verb+\sum_(a <= b <) F i+
% in order to illustrate \C{foldr}.
% \end{itemize}
% \Coq{} commands and features:
% \begin{itemize}
% \item Implicit arguments (only to go from system F to ML), \C{@}
% \item Sections and its discharging, implicit types
% \end{itemize}
% 
% 
% \Coq{} types introduced:
% \begin{itemize}
% \item \C{bool, nat, seq, option, prod}
% \end{itemize}
% 
% Programs presented in detailed examples/exercises:
% \begin{itemize}
% \item Elementary programs on \C{option}: \C{odflt, obind,}\dots
% \item Elementary programs on \C{seq} (without the \C{eqType}):
%   \C{size, map, iota,...}
% \item Comparison functions on \C{bool, nat}
% \item Comparison functions on containers, taking the comparison
%   function on the type of stored elements in argument (mind the
%   higher-order)
% \item Boolean connectives, arithmetic operations on \C{nat}
% \item Do not forget to mention \C{if .. then .. else}
% \item Euclidean division, computation of prime factors, examples from
%   elementary number theory
% \item Examples of G{\"o}del-style encoding from the {\tt choice.v} library.
% \item Examples/exercises about extended gcd (egcdn), which mix lists
%   and arithmetic.
% \end{itemize}
% If possible give a few context to the exercises, in order not to bore
% the reader not familiar with programming. For instance do not say that
% you encode sequences of nats in nats but give a few hints about the
% use of G{\"o}del encoding.
% 
% Examples and exercises can be executed in an empty context, or
% libraries can be required for the purpose of (re)using and combine existing
% programs (non proofs here).
% 
% The current contents are organized like the tutorial at ITP15 I gave (Enrico).
% It was on standard Coq and was intended not to be difficult class ;-)
% It is a possible plan, no strong opinions.
% 
% \section*{Things needed by chapter 2}
% \begin{itemize}
% \item type annotations on arguments of lemmas/definitions can be omitted
% \item if then else
% \item all boolean connectives: \C{orb andb negb implb xorb}
% \item recursive programs: \C{addn muln subn leq eqn expn dvdn}
% \item notations with associativity: \C{+ * - == != .+1 < <= \%| \~\~}
% \end{itemize}
% 
% 
% \section{Functional programming in a nutshell}
% Only intuitions here.
% 
% For a mathematician this is perfectly natural, the main problem is the syntax.  E.g.
% $$f(x) = x * 2\qquad\qquad f(7)$$
% here we define a function named f that doubles its input.  Then we denote f(7) the value of f
% when the input is 7. The novelty is that:
% \begin{enumerate}
% \item functions are anonymous, and the names. \verb+(fun x => x * 2)+ is the function that
% 	doubles.  We can name it: \verb+Definition f := fun x => x * 2.+.  We don't need to
% 	name a function in order to use it in an expression. (there is something like
% 	\verb+x |-> x * 2+, but this is always attached to a name somehow).
% \item function application is \verb+(f 7)+.
% \end{enumerate}
% 
% For a computer scientist used to imperative languages, these are the main weird points:
% \begin{enumerate}
% \item there is no return statement, AKA expressions are already programs.  e.g.
% 	4 is a program, and 2+2 as well.  Programs then evaluate like a mathematical expression
% 	can be simplified
% \begin{verbatim}
%         if (false || true) then 2 + 2 else 7
%         if true then 2 + 2 else 7
%         2 + 2
%         4
% \end{verbatim}
% also
% \begin{verbatim}
%         2 + (if 7 == 2 then 4 else 2)
%         2 + (if false then 4 else 2)
%         2 + 2
%         4
% \end{verbatim}
% \item programs are really first class data (HO programming, not reasonably popular even outside
% 	the functional world). E.g.
%     This program takes in input a function f and uses it twice
% \begin{verbatim}
%       (fun f => f 3 + f 4)
% \end{verbatim}
% hence this is a valid program computing 14
% \begin{verbatim}
%       (fun f => f 3 + f 4) (fun x => x + x)
% \end{verbatim}
% \end{enumerate}
% 
% 
% \subsection{Build and destruct simple data}
% Simplest data is bool.
% 
% \begin{coq}{name=bool}{}
% Inductive bool : Type := true | false.
% Check bool : Type.
% Check true : bool.
% Check false.
% Check 3 : bool. (* boom *)
% \end{coq}
% 
% This tells you that one can construct a boolean using true or false but not a number.
% Types tells you how your values are (in normal form, since (true || false) is also of type bool, recall the example before).
% Hence it makes sense to consider only true and false when one inspects a bool.
% 
% \begin{coq}{name=negb}{}
% Definition negb (b : bool) : bool :=
%   match b with
%   | true => false
%   | false => true
%   end.
% 
% Check negb.
% Check negb true.
% Check negb (negb true).
% Check negb 3. (* boom *)
% 
% Eval compute in negb true.
% Eval compute in negb false.
% \end{coq}
% We see the function type (arrow) and how typing works in this simple case.
% Also that functions compute in Coq.
% Sugar:
% 
% \begin{coq}{name=negb}{}
% Definition another_negb (b : bool) : bool :=
%   if b then false else true.
% Definition yet_another_negb :=
%   (fun b : bool =>
%       if b then false else true).
% Definition andb (b1 : bool) (b2 : bool) :=
%   if b1 then b2 else false.
% Notation "x && y" := (andb x y).
% Eval compute in true && false.
% Eval compute in true && true.
% \end{coq}
% 
% \subsection{Polymorphic containers and binding in match}
% 
% This is not the syntax used in ssr I guess.
% 
% \begin{coq}{name=option}{}
%  Inductive option (A : Type) : Type :=
%  | None
%  | Some (a : A).
% Check option.
% Check option bool : Type.
% Check Some true. (* Implicit argument *)
% \end{coq}
% 
% Talk about implicit arguments here.
% 
% \begin{coq}{name=implicits}{}
% About Some.
% (* The @ locally disables the implicit arguments *)
% Check @Some bool true.
% Check @Some _ true.
% \end{coq}
% 
% Inspecting a container
% 
% \begin{coq}{name=matchopt}{}
% Definition is_empty A (box : option A) : bool :=
%   match box with
%   | None => true
%   | Some _ => false  (* Here _ means discard the little a *)
%   end.
% Eval compute in is_empty None.
% Eval compute in is_empty (Some true).
% (* Note: the function is polymorphic! *)
% Eval compute in is_empty (Some 4).
% \end{coq}
% 
% Two words about polymorphism.
% 
% Now binding in a match.
% 
% \begin{coq}{name=matchopt2}{}
% Definition get_default A (box: option A) (a : A) : A :=
%   match box with
%   | None => a
%   | Some x => x  (* this x is a name on the left bound to the contents *)
%   end.
% 
% Eval compute in get_default None 3.
% Eval compute in get_default (Some 4) 3.
% \end{coq}
% 
% More containers
% 
% \begin{coq}{name=pair}{}
%  Inductive prod (A B : Type) : Type :=
%  | pair (a : A) (b : B).
% 
%  Notation "A * B" := (prod A B).
%  Notation "( a , b )" := (pair a b).
% 
% Check (true, Some false).
% 
% Definition fst A B (p : A * B) :=
%   match p with
%   | ( x , _ ) => x
%   end.
% 
% Eval compute in fst (true, None).
% 
% Definition snd A B (p : A * B) :=
%   match p with (_, y) => y end.
% \end{coq}
% 
% \subsection{Recursive data}
% 
% Nat, with a special syntactic sugar
% 
% \begin{coq}{name=nat}{}
%    Inductive nat : Type :=
%    | O
%    | S (n : nat).
% 
% Check S (S O).
% Check 2.
% Check 1.
% \end{coq}
% 
% Recursive functions
% 
% \begin{coq}{name=plus}{}
% Fixpoint plus (n : nat) (m : nat) : nat :=
%   match n with
%   | O => m
%   | S w => S (plus w m)
%   end.
% Infix "+" := plus.
% 
% Check 2 + 3.
% Eval compute in 2 + 3.
% \end{coq}
% 
% execution step by step
% 
% \begin{coq}{name=execplus}{}
%    S (S 0) + 3
%    S ((S O) + 3)
%    S (S (O + 3))
%    S (S 3)
%    5
% \end{coq}
% 
% Here I was also showing
% 
% \begin{coq}{name=plusrec}{}
% Fixpoint fast_plus (n : nat) (m : nat) : nat :=
%   match n with
%   | O => m
%   | S w => fast_plus w (S m)
%   end.
% 
%     S (S O) + 3
%     S O + 4
%     O + 5
%     5
% \end{coq}
% 
% and making the point that reasoning about these two plus is not equally easy (short parenthesis on symbolic computation).
% 
% \begin{coq}{name=plusrec}{}
% Eval simpl in
%   (fun n => fast_plus (S n) 3).  (* no progress *)
% Eval simpl in
%   (fun n => plus (S n) 3).  (* some output already, we can prove that it is not 0 *)
% \end{coq}
% 
% Lists
% 
% \begin{coq}{name=list}{}
% Inductive list (A : Type) : Type :=
% | nil
% | cons (x : A) (xs : list A).
% 
% Infix "::" := cons.
% Arguments nil {A}.
% Arguments cons {A} x xs.
% 
% (* The type of lists imposes all the elements to
%     be in the same type! *)
% Check true :: false :: nil.
% Fail Check 1 :: false :: nil.
% 
% (* A non recursive function on lists *)
% Definition tl A (l : list A) : list A :=
%   match l with
%   | nil => nil
%   | _ :: xs => xs
%   end.
% 
% Eval compute in tl (6 :: 99 :: nil).
% 
% (* The most popular function on lists *)
% Fixpoint len A (l : list A) : nat :=
%   match l with
%   | nil => O
%   | x :: xs => 1 + (len xs)
%   end.
% 
% Eval compute in len (1 :: 2 :: 3 :: nil).
% Fixpoint split A B (l : list (A * B)) : list A * list B :=
%   match l with
%   | nil => (nil, nil)
%   | (x,y) :: rest =>
%       let xs_ys := split rest in
%       (x :: fst xs_ys, y :: snd xs_ys)
%   end.
% 
% Eval compute in
%   split ((1,2) :: (3,4) :: nil).
% 
% Fixpoint zip A B (la : list A) (lb : list B) : list (A * B) :=
%   match la, lb with
%   | nil, nil => nil
%   | x::xs, y::ys => (x,y) :: zip xs ys
%   | _, _ => nil
%   end.
% 
% Eval compute in
%   zip (1 :: 2 :: nil) (true :: false :: nil).
% 
% Eval compute in
%   let xs_ys := split ((1,2) :: (3,4) :: nil) in
%   zip (fst xs_ys) (snd xs_ys).
% \end{coq}
% 
% \subsection{termination}
% 
% Here we say how termination is checked, which are the alternative when the
% heuristic fails (not very relevant for mathcomp I guess) and relate that to
% logical inconsistency (maybe too early here, needs curry howard).
% 
% \begin{coq}{name=paradoxes}{}
% Fail
% Fixpoint wrong A (l : list A) {struct l} :=
%   match l with
%   | nil => 0
%   | x :: xs => 1 + wrong (x :: nil)
%   end.
% 
% Fixpoint loop (n : nat) : False := loop n.
% 
% Check loop 3.
% Fail Timeout 2 Eval compute in loop 3.
% \end{coq}
% 
% Also data must be checked.
% 
% \begin{coq}{name=paradoxes2}{}
% Inductive non_positive : Type :=
% | Call (f : non_positive -> False)
% 
% Definition self (t : non_positive) : False :=
%   match t with
%   | Call f => f t
%   end.
% 
% Definition loop2 : False := self (Call self).
% 
% Fail Timeout 2 Eval compute in loop2.
% \end{coq}
% 
% \subsection{HO programming}
% 
% A function can be abstracted over another
%    function.  It is a useful mechanism to write
%    code that can be reused, especially in the context
%    of polymorphic containers.
% 
% \begin{coq}{name=map}{}
% Fixpoint map A B (f : A -> B) (l : list A) : list B :=
%   match l with
%   | nil => nil
%   | x :: xs => f x :: map f xs
%   end.
% 
% Eval compute in
%   map (fun x => x + 2) (3 :: 4 :: 7 :: nil).
% Eval compute in
%   map negb (true :: false :: nil).
% 
% (* fold f (x1 :: x2 :: .. xn :: nil) a
%      =
%             (f xn (.. (f x2 (f x1 a))))
% *)
% Fixpoint fold A B (f : B -> A -> A) (l : list B) (a : A) : A :=
%   match l with
%   | nil => a
%   | x :: xs => fold f xs (f x a)
%   end.
% 
% (* what does this do? *)
% Eval compute in fold cons (1 :: 2 :: 3 :: nil) nil.
% \end{coq}
% 
% Here one could use a section for A B and talk about all that.

% \section{old contents (before Enrico's tutorial)}
% 
% Do use \C{About} for informations (not \C{Check}).
% \begin{coq}{name=beta}{}
% Eval beta in (fun x => x + x) 3. (* 3 + 3 : nat *)
% Definition f := fun x : nat => x + x.
% Definition f (x : nat) := x + x.
% About f : nat -> nat.
% \end{coq}
% 
% TODO: "beta" alone is not a reduction tactic, but we could add it.
% 
% maybe also talk about delta here and make example of f.
% 
% \subsection{Inductive data, case analysis and recursion}
% bool, nat.
% 
% \begin{coq}{name=ind-data}{}
% Inductive bool : Type := true | false.
% Inductive nat :Type := O | S of nat.
% Check true : bool : Type. (* on a side note .. : Type : Type *)
% Check (S (S O)). (* 2 : nat *)
% \end{coq}
% 
% 
% 
% 
% match, fix, termination.
% 
% \begin{coq}{name=bool-conn}{}
% Definition andb := ...
% Fixpoint addn := ..
% Fixpoint eq_nat
% Fixpoint leq
% \end{coq}
% 
% discuss example of a real computation, not just beta.
% 
% \begin{coq}{name=compute}{}
% Compute (addn 3 4)
% \end{coq}
% 
% now simple notation come in to play
% 
% \begin{coq}{name=notation-infix}{}
% Infix "+" := addn.
% \end{coq}
% 
% \subsection{Polymorphism and HO programming}
% option, seq, pairs.
% 
% \begin{coq}{name=option}{}
% Inductive option A := None | Some of A.
% Check option. (* Type -> Type *)
% Check Some. (* : forall A : Type, A -> option A *)
% Fixpoint map A B (f : A -> B) := ...
% Fixpoint eq_seq A (eq_A : A -> A -> bool) l := ...
% \end{coq}
% 
% polymorphism as in F
% 
% may be also examples of polymorphisms that can be defined in pure
% $\lambda$-calculus (identity, argument swaping).
% 
% \section{programming in Coq}
% this contains real programs, and is the excuse to talk about:
% 
% \subsection{Sections}
% and Implicit Type, to factor the type parameter of containers like
% sequences.  Write more stupid programs on seq.
% 
% \begin{coq}{name=seq}{}
% Section Seq.
% Variable A : Type.
% Variable x0 : A.
% Implicit Type l : seq A.
% ...
% Fixpoint fold f l := ...
% Fixpoint rev l := ...
% \end{coq}
% 
% 
% \subsection{Implicit arguments}
% to imitate polymorphism a-la ML, simplest example of type inference
% like \C{Some _ 3}.  Set implicit for inductive types/constructors too,
% and functions on them like the ones on seq we have seen before.
% 
% \begin{coq}{name=Arguments}{}
% Arguments seq {T}.
% Arguments nil {T}
% Arguments cons {T} x xs.
% About seq.
% Check cons 3 nil.
% (* we have notataions *)
% Check [:: 3, 4 ].
% Fixpoint size A l := ...
% \end{coq}
% 
% About is bad because it mention names that are not necessarily displayed.
% Maybe we should tell people to open the document and/or talk about Locate,
% Print.  Or else use Search (that does all that) but in an empty
% file, where no theorems pop up.
% 
% \subsection{Exercises (explained): arithmetic}
% by now we should have the infrastructure to write program on arithmetic
% 
% \begin{coq}{name=stuff}{}
% divn
% prime  (* an simpler version *)
% \end{coq}
% 
% from choice.v
% 
% \begin{coq}{name=smart}{}
% encode
% decode
% \end{coq}
