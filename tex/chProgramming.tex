\Chapter{Computational definitions \\ The syntax of terms}{Defining concepts by writing programs}\label{ch:prog}

Find a more catchy title? The motivation is: how to define things:
objects, operations, (boolean) relations.

Theoretical content:
\begin{itemize}
\item Functions with simple types ($\lambda$, $\rightarrow$): functions are the primitive concept
\item Inductive {\bf datas}
\item Programs by case analysis and recursion
\item Compute (beta, delta, iota) example of beta (that helps later on to explain a predicate for elim principles)
\item Polymorphic datatypes (introduce $\Pi$, and its \Coq{} notation
  \C{forall}, for quantification over datatypes only)
\item Everyone has a type : \C{0 : nat : Type : Type}, types avoid confusion
\end{itemize}
This is more or less a standard introduction to (a flavor of)
functional programming, with two possible difficulties:
\begin{itemize}
\item Be precise but not too technical (e.g. on inductive types)
\item Find a line of speech which does not bore/discourage
  mathematicians.
\item Somehow the syntax of (this fragment of the) terms should made
  be clear and precise.
% \item types depending on terms (matrix x m)
\end{itemize}

\Coq{} commands and features:
\begin{itemize}
\item Implicit arguments (only to go from system F to ML), \C{@}
\item Sections and its discharging, implicit types
\end{itemize}


\Coq{} types introduced:
\begin{itemize}
\item \C{bool, nat, seq, option, prod}
\end{itemize}

Programs presented in detailed examples/exercises:
\begin{itemize}
\item Elementary programs on \C{option}: \C{odflt, obind,}\dots
\item Elementary programs on \C{seq} (without the \C{eqType}):
  \C{size, map, iota,...}
\item Comparison functions on \C{bool, nat}
\item Comparison functions on containers, taking the comparison
  function on the type of stored elements in argument (mind the
  higher-order)
\item Boolean connectives, arithmetic operations on \C{nat}
\item Do not forget to mention \C{if .. then .. else}
\item Euclidean division, computation of prime factors, examples from
  elementary number theory
\item Examples of G{\"o}del-style encoding from the {\tt choice.v} library.
\item Examples/exercises about extended gcd (egcdn), which mix lists
  and arithmetic.
\end{itemize}
If possible give a few context to the exercises, in order not to bore
the reader not familiar with programming. For instance do not say that
you encode sequences of nats in nats but give a few hints about the
use of G{\"o}del encoding.

Examples and exercises can be executed in an empty context, or
libraries can be required for the purpose of (re)using and combine existing
programs (non proofs here).
\section{basics of functional programming}

\subsection{Functions and simple types}
functions are the base concept,
anonymous functions \C{(fun x => ...)},
application,
substitution (beta), arrow type.
we assume we have nat here.

Do use \C{About} for informations (not \C{Check}).
\begin{coq}{name=beta}{}
Eval beta in (fun x => x + x) 3. (* 3 + 3 : nat *)
Definition f := fun x : nat => x + x.
Definition f (x : nat) := x + x.
About f : nat -> nat.
\end{coq}

TODO: "beta" alone is not a reduction tactic, but we could add it.

maybe also talk about delta here and make example of f.

\subsection{Inductive data, case analysis and recursion}
bool, nat.

\begin{coq}{name=ind-data}{}
Inductive bool : Type := true | false.
Inductive nat :Type := O | S of nat.
Check true : bool : Type. (* on a side note .. : Type : Type *)
Check (S (S O)). (* 2 : nat *)
\end{coq}




match, fix, termination.

\begin{coq}{name=bool-conn}{}
Definition andb := ...
Fixpoint addn := ..
Fixpoint eq_nat
Fixpoint leq
\end{coq}

discuss example of a real computation, not just beta.

\begin{coq}{name=compute}{}
Compute (addn 3 4)
\end{coq}

now simple notation come in to play

\begin{coq}{name=notation-infix}{}
Infix "+" := addn.
\end{coq}

\subsection{Polymorphism and HO programming}
option, seq, pairs.

\begin{coq}{name=option}{}
Inductive option A := None | Some of A.
Check option. (* Type -> Type *)
Check Some. (* : forall A : Type, A -> option A *)
Fixpoint map A B (f : A -> B) := ...
Fixpoint eq_seq A (eq_A : A -> A -> bool) l := ...
\end{coq}

polymorphism as in F

may be also examples of polymorphisms that can be defined in pure
$\lambda$-calculus (identity, argument swaping).

\section{programming in Coq}
this contains real programs, and is the excuse to talk about:

\subsection{Sections}
and Implicit Type, to factor the type parameter of containers like
sequences.  Write more stupid programs on seq.

\begin{coq}{name=seq}{}
Section Seq.
Variable A : Type.
Variable x0 : A.
Implicit Type l : seq A.
...
Fixpoint fold f l := ...
Fixpoint rev l := ...
\end{coq}


\subsection{Implicit arguments}
to imitate polymorphism a-la ML, simplest example of type inference
like \C{Some _ 3}.  Set implicit for inductive types/constructors too,
and functions on them like the ones on seq we have seen before.

\begin{coq}{name=Arguments}{}
Arguments seq {T}.
Arguments nil {T}
Arguments cons {T} x xs.
About seq.
Check cons 3 nil.
(* we have notataions *)
Check [:: 3, 4 ].
Fixpoint size A l := ...
\end{coq}

About is bad because it mention names that are not necessarily displayed.
Maybe we should tell people to open the document and/or talk about Locate,
Print.  Or else use Search (that does all that) but in an empty
file, where no theorems pop up.

\subsection{Exercises (explained): arithmetic}
by now we should have the infrastructure to write program on arithmetic

\begin{coq}{name=stuff}{}
divn
prime  (* an simpler version *)
\end{coq}

from choice.v

\begin{coq}{name=smart}{}
encode
decode
\end{coq}


