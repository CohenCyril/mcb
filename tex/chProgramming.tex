\Chapter{Computational definitions}{ Defining concepts by writing programs}\label{ch:prog}

% TODO: uniform terminology (a function returns,produces, computes... patter matching,case analysis...program, function, operation...computation, evaluation...data type, inductive type); I mean, we can say we use them interchangeably... but the quotienting must be explicit since the reader may not know it (eg some of it is historical, some justified by curry Howard (fwd reference)).  Also "coq session" is something that I would remove.
% 
% TODO: in the text I did sneak in some ``principles'' and some were already there.  eg exhaustiveness of pattern matching, totality of functions, injectivity of constructors, uniqueness of constructors/types.  We may want to put them in a more visible format, like a mantra like box.  The mathematician may not see these are the pillars of the logic.
% 
%\textcolor{blue}{Find a more catchy title? The motivation is: how to define things: objects, operations, (boolean) relations.}

We will take the point of view that mathematics can be understood as
the study of objects, operations on these objects, and abstractions.  
Children start learning mathematics by counting, where the objects are
numbers and the operations are enumerating and adding.  In fact
numbers are already the result of an abstraction process.

What are the objects, the operations, and the abstractions in a given
mathematical corpus is quite fluctuant.  The objects of group theory
may sometimes be viewed as operations in another context.  Nevertheless,
in this chapter, we describe how some objects are described with the intent
that they are {\em inert}, that is, they are meant to be
manipulated by operations.  We also show how operations are described.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Functions}
In this section, we expect readers to get acquainted with the notion
of function and the associated syntax.  We rely on natural
numbers and the addition operation, noted with the \C{+} symbol.
Both concepts will only be described fully a few pages later.

We start by considering the expression
\[ 2 + 1 \]
We can read this expression as an object, but also as the result of an
operation on one object, or as the result of an operation on two
objects.  Let us first consider the operation of {\em adding one to
a natural number}.  This operation is written in the following manner.

\begin{coq}{name=exfun}{}
  fun n => n + 1
\end{coq}
\index[coq]{\C{fun .. => ..}}
To write such an operation, we can start from the expression \C{(2 + 1)}
and isolate the object in this expression that is considered a
variable component for the operation, here \C{2}, we then replace
this object with a symbolic name, here {\tt n}.  We then encapsulate
the expression \C{(n + 1)} with the prefix ``\C{fun n =>}'' to relate
the result produced by the operation to the variable \C{n}.  We commonly
say that ``\C{fun n =>}'' \emph{binds} the variable \C{n} in the expression
\C{n + 1}.
\index[concept]{binder}

The ``\C{fun}'' construction stands for \emph{function}.  Functions are the
main tool provided by \Coq{} to describe operations, so we will use the
two terms interchangeably.  Sometimes we also call operations \emph{programs},
since the functions we talk about are effective: i.e. described by a code
a computer can execute.  As a consequence we borrow from computer science
some jargon, like \emph{input} or \emph{return}. For example we say that
an operation takes as input a number and returns its double to mean
that the corresponding program computes the double of its input, or
that the function maps a number to its double.

So we have an expression which represents the operation of adding 1.
Applying this operation to the object \C{2} will be written this
way:

\begin{coq}{name=exapp}{}
  (fun n => n + 1) 2
\end{coq}
\index[concept]{function application}
From the point of view of mathematical syntax, there are two unusual 
things in this line.  First, applying a function to an argument is simply
by writing the function on left of the argument, {\em not necessarily
with parentheses around the argument}; we will come back to this later.
Second, this object \C{(fun n => n + 1)} is unusual.  
When defining an operation, we usually
rely on a sentence like {\em consider the function \(f\) from {\(\mathbb{N}\)}
to {\(\mathbb{N}\)} which maps \(n\) to \(n + 1\)}.  This would also be
written without natural language as follows:

\begin{equation}\label{equation:f}
f : 
\begin{array}{ccc}
{\mathbb{N}} &\rightarrow& {\mathbb{N}}\\
n &\mapsto& n + 1
\end{array}
\end{equation}

The main difference is that the usual mathematical practice includes
the step of giving a name, here \(f\), to the operation.

When using \Coq{}, the step of giving a name can also be
performed, in the following manner:

\begin{coq}{name=exdef}{}
Definition f := fun n => n + 1.
\end{coq}
\index[vernac]{\C{Definition}}
An alternative syntax for exactly the same definition is as follows,
this alternative syntax is actually preferred.

\begin{coq}{name=exdef-pref}{}
Definition f n := n + 1.
\end{coq}
The mathematical practice when defining a function is to give
information about its domain and codomain, as we did when writing
\({\mathbb{N}}\rightarrow{\mathbb{N}}\).  In \Coq{} syntax, we will write
the same information as follows, because \C{nat} is the name used in
\Coq{} to represent \(\mathbb{N}\):

\begin{coq}{name=exdef-type}{}
Definition f (n : nat) : nat := n + 1.
\end{coq}
In this description, \C{nat} is called a {\em type}.  Types describe
collections of objects that can be treated in a uniform way.
\index[concept]{type}

Once a definition was made, the \Coq{} system provides a command to
describe the relevant information about the constant that is defined:

\begin{coq}{name=about_f}{width=5.5cm,title=Gathering information on f}
About f.
\end{coq}
\coqrun{name=about_f_run}{about_f}
\begin{coqout}{run=about_f_run}{title=Response,width=6.5cm}
f : nat -> nat
\end{coqout}
\index[vernac]{\C{About}}
This response confirms that \C{f} is a function from
\({\mathbb{N}}\) to \({\mathbb{N}}\).
% We also learn that the \Coq{} system will pay attention to
% arguments of \C{f} in such a way that overloaded notations
% will be interpreted as notation for natural numbers.
% \marginnote{maybe place a footnote here to point to another paragraph
% about overloaded notations.  To  be discussed.}

We can be more inquisitive in our requests for information about
\C{f}, we can also require to know what is the value.  This is done in
the following manner:

\begin{coq}{name=print_f}{width=6cm}
Print f.
$~$
\end{coq}
\coqrun{name=print_f_run}{print_f}
\begin{coqout}{run=print_f_run}{width=6cm}
f = fun n : nat => n + 1
  : nat -> nat
\end{coqout}
\index[vernac]{\C{Print}}

We see in this example that {\em type information} is an important
feature of the language.  Type information is given twice in the
result of the \C{Print} command, once in the fragment ``\C{fun n : nat
  =>}'' and once in the second line, behind the colon ``\C{:}''.  The first
time, what we get is that the input of the function is expected to be
a value of type \C{nat}.  The second time, what we get is that the
type of \C{f} itself is the function type \C{nat -> nat}.  In fact,
the colon character (when surrounded by spaces) will always be used to
give type information.  Remark the similarity between the output of \C{Print}
and the mathematical notation in \eqref{equation:f}.

As we detail in chapter~\ref{sec:ttch} types play an important role in \Coq{}.
In particular they are used to avoid confusion.  For example
the function \C{f} we just defined can \emph{only
be applied to a natural number}, i.e. a term of type \C{nat}.
\Coq{} provides a command to check that an expression is \emph{well typed}.
\index[concept]{well typed}

\begin{coq}{name=print_f}{width=5.3cm,title=Check well-typedness}
Check f 3.
\end{coq}
\begin{coqout}{run=print_f_run}{title=Response,width=7cm}
 f 3 : nat
\end{coqout}
\index[vernac]{\C{Check}}
On the contrary \C{f} cannot be applied to something that 
is not a natural number, for example a function.

\begin{coq}{name=print_f}{width=5.3cm,title=Type error}
Check f (fun x : nat => x).
$~$
$~$
\end{coq}
\begin{coqout}{run=print_f_run}{title=Response,width=7cm}
Error: The term "(fun x : nat => x)"
has type "nat -> nat" while it is
expected to have type "nat".
\end{coqout}
\index[concept]{type error}
Indeed it makes little sense to compute the addition between
a function and 1.

Expressions that are well typed can be \emph{computed} by \Coq{},
meaning that they are \emph{reduced} to a ``simpler'' form, also
called a \emph{normal form}.
For example \C{(f 3)} returns \C{4}.

\begin{coq}{name=print_f}{width=6cm,title=Evaluating a function}
Eval compute in f 3.
\end{coq}
\begin{coqout}{run=print_f_run}{title=Response,width=6cm}
 = 4 : nat
\end{coqout}
\index[vernac]{\C{Eval compute}}
This seemingly trivial capability of \Coq{} plays a crucial role
in the \mcbMC{} library, as we will see in the next chapter when
doing proofs.
\index[concept]{computation}
\subsection{Functions with several arguments}
When we want to define a function that takes several arguments as input, we
can use the same syntax as when defining a function with a single argument,
simply adding the extra arguments separated by space.  Here is an example, 
concentrating on a function with two arguments:

\begin{coq}{name=two_arg_def}{}
Definition f2 (x y : nat) : nat :=
  x + y * 2.
\end{coq}
With this form of definition, we give very precise type information.  Firstly
we assert that both the \C{x} and \C{y} arguments have type \C{nat}, secondly
we assert that the result also has type \C{nat}.  When we ask the \Coq{}
system what is the type of \C{f2}, we see how the type of two argument
function is displayed.

\begin{coq}{name=about_f2}{width=5.5cm,title=Gathering information on f2}
About f2.
\end{coq}
\coqrun{name=about_f2_run}{about_f2}
\begin{coqout}{run=about_f2_run}{title=Response,width=6.5cm}
f2 : nat -> nat -> nat
\end{coqout}
The notation \C{nat -> nat -> nat} deserves some explanations.  This
notation actually relies on two uses of the \C{.. -> ..} notation to
describe function with a single argument.  It shows that multiple
argument functions are represented as a special kind of single
argument functions.  {\em A multiple argument function is a single
argument function that returns a function}.  In our case, we define
a second function that performs exactly the same computations as function
\C{f2}.

\begin{coq}{name=tw_arg_as_single_arg}{}
Definition f2' (x : nat) : nat -> nat := fun y => x + y * 2.
\end{coq}
This is a function that takes as argument a number \C{x} and returns
a function of one argument as a result.  When we ask to see the type
of \C{f2'} we see that this type is exactly the same as the type for
\C{f2}.

\begin{coq}{name=about_f2_prime}{width=5.5cm,title=Gathering information on f2'}
About f2'.
\end{coq}
\coqrun{name=about_f2_prime_run}{about_f2_prime}
\begin{coqout}{run=about_f2_prime_run}{title=Response,width=6.5cm}
f2' : nat -> nat -> nat
\end{coqout}

If we go further in our scrutiny and ask the \Coq{} system to print
the values associated to names \C{f2} and \C{f2'}, we see that these
values are exactly the same.  The \Coq{} system does not make any
difference between these two ways of describing a two-argument function.

\begin{coq}{name=print_f}{width=6cm}
Print f2.
$~$
Print f2'.
$~$
\end{coq}
\coqrun{name=print_f_run}{print_f}
\begin{coqout}{run=print_f_run}{width=6cm}
f2 = fun x y : nat => x + y * 2
  : nat -> nat -> nat
f2' = fun x y : nat => x + y * 2
  : nat -> nat -> nat
\end{coqout}
\index[vernac]{\C{Print}}

Since \C{f2} is also a one-argument function, it is sensible to apply this
function to only one integer.  We can call this {\em partial application}
because \C{f2} is also meant to be applied to two arguments.
 The value we obtain in this case is another
one-argument function.  Here are a few dialogs with the \Coq{} system 
that shows what happens.

\begin{coq}{name=about_f2_prime}{width=5.5cm,title=Applying f2 partially}
Check f2 3.
\end{coq}
\coqrun{name=about_f2_prime_run}{about_f2_prime}
\begin{coqout}{run=about_f2_prime_run}{title=Response,width=6.5cm}
f2 3 : nat -> nat
\end{coqout}

In \Coq{} functions with multiple inputs are just functions producing
functions.  As a consequence \emph{it is legal to apply functions partially},
and the \C{->} sign associates to the right.
This idea that multiple argument functions can be represented using
single argument functions is called {\em currying}.
\index[concept]{currying of functions}
\index[concept]{partial application}
\index[concept]{currying of functions}
\index[concept]{typing an application}

When we want to apply the function \C{f2} to the numbers \C{2} and \C{3},
this can be written as follows:

\begin{coq}{name=eval_f2_2_3}{width=7cm}
Eval compute in f2 2 3.
\end{coq}
\coqrun{name=eval_f2_2_3_run}{eval_f2_2_3}
\begin{coqout}{run=eval_f2_2_3_run}{width=5cm}
= 8 : nat
\end{coqout}
\coqrun{name=eval_f2_2_3_run}{eval_f2_2_3}
From the syntax point of view, we wrote three subexpressions only separated
by space.  By default, the parser understands this as \C{((f2 2) 3)}, so
we actually have a first subexpression which is \C{f2} applied to \C{2}.
The value of this subexpression is a function, with approximately has the
following value:

\begin{coq}{}{}
fun y => 2 + y * 2
\end{coq}
In turn, when applying this function to \C{3} we obtain the value

\begin{coq}{}{}
2 + 3 * 2
\end{coq}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Higher order functions}

The function \C{f} operates on natural numbers, of type \C{nat}, but
we can also define functions that operate on functions, called
\emph{higher order functions}.\index[concept]{higher order}  For instance,
the following definition introduces a function that takes a function
from \C{nat} to \C{nat} and produces a new function from \C{nat} to
\C{nat}.

\begin{coq}{name=repeat_twice_def}{}
Definition repeat_twice (g : nat -> nat) : nat -> nat :=
  fun x => g (g x).
\end{coq}
Reading the first line of this statement, we see that a new object is
being defined, called \C{repeat_twice}.  We also see that this object
is a function the argument of which is a function of
type \C{nat -> nat}.  For later reference in the definition of
\C{repeat_twice}, the argument is given the name \C{g}.  Finally
we see that the value produced by the function \C{repeat\_twice}
is itself a function from \C{nat} to \C{nat}.

Reading the second line of this statement, we see that the value
of \C{repeat_twice} when applied to one argument is a new
function, described using the ``\C{fun .. => ..}'' construct.  The
argument to that function is called \C{x}.  After the \C{=>} sign, we
find the ultimate value of this function.  This fragment of text, \C{g
(g x)}, also deserves some explanation.  This fragment describes the
application of function \C{g} to an expression \C{(g x)}.  In turn,
the fragment \C{(g x)} describes the application of function \C{g} to
\C{x}.  The lesson here is that the application of a function to an
argument is not systematically written using parentheses, as is
customary in mathematics, but it is usually only written by
juxtaposing the function (on the left) and the argument (on the
right).  Parentheses are only added when they are needed to resolve
ambiguity.  Also expressions written with several subexpressions side
by side should be read as if there were parentheses around the
subgroups on the left.  We will illustrate this in the next few
examples.

When we want to apply the function \C{repeat_twice} to the function
\C{f} and the number \C{2} and perform the computation, this can be
written as follows:

\begin{coq}{name=eval_repeat_twice_f_two}{width=7cm}
Eval compute in repeat_twice f 2.
\end{coq}
\coqrun{name=evalrepeat_twice_f_two_run}{eval_repeat_twice_f_two}
\begin{coqout}{run=eval_repeat_twice_f_two_run}{width=5cm}
= 4 : nat
\end{coqout}
\coqrun{name=eval_run}{eval_repeat_twice_f_two}
From the syntax point of view, we wrote three subexpressions only
separated by space.  By default, the parser understands this as
\C{((repeat_twice f) 2)}, so we actually have a first subexpression
which is \C{repeat_twice} applied to \C{f}.  According to the
definition of \C{repeat_twice} function, the value is 
%an intermediate
a function 
% from \C{nat} to \C{nat}, 
which is then applied to \C{2}. 
% The value of the
%intermediate function is \C{(fun x => f (f x))}, so 
The resulting expression is \C{(f (f 2))}, and given the
%Remembering the 
definition of \C{f}, this expression can also
be read as \C{((2 + 1) + 1)}.  Thus, after computation, the result is \C{4}.

As in the previous section, 
the \C{repeat_twice} program takes two arguments as input and we can
apply it to only one argument to obtain a perfectly valid term.

\begin{coq}{name=check_repeat_twice_f_two}{width=6cm,title=Partial application}
Check (repeat_twice f).
\end{coq}
\coqrun{name=check_repeat_twice_f_two_run}{check_repeat_twice_f_two}
\begin{coqout}{run=check_repeat_twice_f_two_run}{title=Response,width=6cm}
repeat_twice f : nat -> nat
\end{coqout}
If we look at the type of \C{repeat_twice} and add redundant parentheses
we obtain \C{(|==(nat -> nat)==| -> (|--nat--| -> nat))}:
once the first argument
is passed, \C{(f : |==nat -> nat==|)}, we obtain a term the type of which is
the right hand side of the main arrow, that is \C{(|--nat--| -> nat)}.
By passing another argument, like \C{(2 : |--nat--|)}, we obtain an expression
the type of which is, again, the right hand side of the main arrow, here \C{nat}.
Remark that the type of each argument matches the left hand side of
the arrow (as depicted with different underline styles).
When this is not the case \Coq{} issues a type error.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Local definitions}
When we write a function application whose function part has the form
\C{fun x => ..}, as in \C{(fun x => x + x + x) B}, we actually use the
variable \C{x} as an abbreviation for \C{B}.  This can be very useful when
\C{B} is replaced by a very big expression that would be cumbersome to repeat
several times.  However the readability of this statement is poor, because
the name \C{x} and the expression \C{B} for which it stands are separated by
the expression where \C{x} is used, in our example \C{x + x + x}.

The  \Coq{} programming language has recognized this need and added a
statement for this.  It is written as follows:
\begin{coq}{}{}
let x := B in
   x + x + x
\end{coq}
This statement is more readable than the function applications described earlier
in this section.  There are also variants that make it possible to state the
type ascribed to the variable \C{x}.  This can come handy when we want the
code to be very explicit about the nature of the values being exchanged.

In this expression the variable \C{x} is {\em bound} and can be used in
the text that comes after the \C{in} keyword. \index[Concepts]{binder}.

Here is an example of usage of this syntax.
\begin{coq}{name=eval_let_expr}{width=6cm,title=Evaluating local definitions}
Eval compute in
  let n := 33 in
  let e := n + n + n in
    e + e + e.
\end{coq}
\coqrun{name=eval_let_expr_run}{eval_let_expr}
\begin{coqout}{run=eval_let_expr__run}{title=Response,width=6cm}
 = 297 : nat
\end{coqout}

When it comes to comparing end values of computations, a local definition
has the same result as the expression where all occurrences of the bound
variable are replaced by the corresponding expression.  Thus, the example
expression above has exactly the same value as the following expression
\begin{coq}{}{}
(33 + 33 + 33) + (33 + 33 + 33) + (33 + 33 + 33)
\end{coq}
However, in practice the evaluation strategy used in the command
\C{Eval compute in ..} takes advantage of the \C{let .. in ..} notation to
avoid duplicating computation efforts.  So this notation can also be used
to organize intermediate computations.

\section{Data: construction and destruction}
It is possible to define a data type by giving in one declaration
the type name and the methods to \emph{build} elements of this type.
% and methods to
% use elements of the type while computing.
The dual method to use
elements of a data type by observing their contents (in other words, {\em destructing elements}) is provided by
\Coq{} in the form of a pattern matching syntax.

This approach is used
systematically in \Coq{} to define a variety of basic data types, among
which boolean values, natural numbers, pairs and sequences of values
are the most prominent examples.  We will study these examples in
turn.

%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Boolean values}
The type \C{bool} contains two values that can be
distinguished in computations.  The declaration of this type happens
in one of the first files to be automatically loaded when \Coq{} starts,
so booleans look like a built-in notion.  Nevertheless, the type of
boolean values is actually defined in the following manner.

\begin{coq}{name=print_bool}{title=Declaration of bool}
Inductive bool := true | false.
\end{coq}
\index[vernac]{\C{Inductive}}
This declaration states explicitly that there are only two cases for
elements of type \C{bool}.  The first case is given by the constant
\C{true}, the second case by the constant \C{false}.  
The constants \C{true} and \C{false} are provably distinct, and
are the only way to construct a value of type \C{bool}.

% Thus, the
%declaration of the type gives in an obvious manner the type, \C{bool},
%and ways to build all its elements, \C{true}, and \C{false}.  
All definitions
in \Coq{} that define a type by providing at the same time a type
name and the only ways to build elements of the type, like this one,
are called {\em inductive}
definitions.  The two objects \C{true} and \C{false} are called
\emph{constructors}.
\index[concept]{inductive type}
\index[concept]{inductive type!constructor}

In practice, this means that we can build a well-formed expression of
type \C{bool} by using either \C{true} or \C{false}. 

\begin{coq}{name=check_true}{width=6cm,title=Queries}
Check true.
\end{coq}
\coqrun{name=check_true_run}{check_true}
\begin{coqout}{run=check_true_run}{width=6cm,title=Response}
true : bool
\end{coqout}

To use boolean values in computations, we need a syntax form that makes
it possible to build different values depending on whether some
boolean input is \C{true} or \C{false}.  This syntax form is written
``\C{if .. then .. else ..}''.  An example follows:

\begin{coq}{name=if_example}{}
if true then 3 else 2
\end{coq}
\index[coq]{\C{if .. then .. else ..}}
More generally, we can define a function that takes a boolean value as
input and returns one of two possible natural numbers in the following
manner:

\begin{coq}{name=definef23}{}
Definition f23 b := if b then 2 else 3.
\end{coq}
\coqrun{name=definef23_run}{definef23}

As one expects, when \C{b} is \C{true} the expression
\C{(f23 b)} evaluates to \C{2}, while it evaluates to \C{3} otherwise.

\begin{coq}{name=eval_repeat_twice_f_two}{width=7cm,title=Evaluating f23}
Eval compute in f23 true.
Eval compute in f23 false.
\end{coq}
\coqrun{name=eval_run}{eval_repeat_twice_f_two}
\begin{coqout}{run=eval_f_run}{title=Response,width=5cm}
  = 2 : nat
  = 3 : nat
\end{coqout}

The \mcbMC{} library provides a collection of boolean operations that
mirror reasoning steps on truth value.  The functions are called
\C{negb}, \C{orb}, \C{andb} , and \C{implyb}, respectively with notations
\C{\~\~},  \C{||}, \C{&&}, and \C{==>} (the last three operators are
infix, they appear between the arguments as in \C{b1 && b2}).
  In
particular, it should be
noted that the symbol \C{\~\~} uses two characters \C{\~}, but it should
not be confused with two consecutive occurrences of the one-character symbol
\C{\~} (that has a meaning in \Coq{}, but is almost never used
in the \mcbMC{} library).  In practice, readers become quickly accustomed to the
distinction between the two symbols.

For instance, the function \C{andb} is defined as follows and
evaluates to \C{true} if and only if both inputs are \C{true}.

\begin{coq}{name=define_andb}{}
Definition andb b1 b2 := if b1 then b2 else false.
\end{coq}
\index[coq]{\C{andb}}

% \subsubsection{TODO : A note on associativity for notations}

\subsection{Natural numbers}\index[concept]{natural number}
The description of natural numbers in the \Coq{} system is inspired from
the work of Peano at the beginning of the twentieth century.  The
basic idea is that any natural number is either 0 or the successor of
an existing natural number.  Moreover, the successor operation is
injective.  Peano also considers supplementary operations, like
addition and multiplication, but we shall see that the \Coq{} system
provides enough machinery so that these operations can be described as
defined functions on top of the basic tools.

The description of natural numbers as essentially generated by a
constant \C{O} (capital ``o'' letter, to represent $0$) and a function symbol \C{S} to represent 
the successor operation is given in the definition of the type
\C{nat}.

\begin{coq}{}{}
Inductive nat := O | S (n : nat).
\end{coq}
\index[coq]{\C{nat}}
\index[coq]{\C{S}}
\index[coq]{\C{O}}

This declaration states that the only ways to produce natural numbers
are by using the constant \C{O}, or by applying the function \C{S} to
an already existing natural number.  So \C{O} is a natural number,
\C{(S O)} is a
natural number, \C{(S (S O))}, and so on, and these are the only natural
numbers.  When interacting with \Coq{}, we will often see decimal
notations, but these are only a parsing and display
facility provided to the user for readability.  So \C{O} is displayed
$0$, \C{(S O)} is displayed $1$, etc.  Users can also type decimal
numbers to describe values, but these are automatically translated into
terms built with \C{O} and \C{S}.

The \mcbMC{} library provides a few notations to make use of the
constructor \C{S} more intuitive to read.  In particular, if \C{x}
is a value of type \C{nat}, \C{x.+1} is another way to write \C{(S
x)}.  The ``\C{.+1}'' notation binds more strongly than function
application, so that this notation makes it possible to avoid some
needs for parentheses.
Similar notations are provided for up to 4 uses of the \C{S}
constructor.  This can be illustrated by the following dialog (where
we assume that \C{f} is a function of type \C{nat -> nat}).
  For instance, we can write the following
expression, when \C{f} is already defined with type \C{nat -> nat}.

\begin{coq}{name=f_plus_one}{width=5cm,title=Queries}
Check fun x => f x.+1.
Locate ".+4".
\end{coq}
\coqrun{name=f_plus_one_run}{f_plus_one}
\begin{coqout}{f_plus_one_run}{width=7cm,title=Response}
fun x => f x.+1 : nat -> nat
Notation "n.+4" := S (S (S (S n)))
\end{coqout}
\index[coq]{\C{(_ .+1)}|seealso {\C{S}}}
\index[vernac]{\C{Locate}}

When writing functions that compute on natural numbers, we can
proceed by cases, as was done in the previous section for boolean
values.  Again, there are two cases, either the natural number used in
the computation is \C{O} or it is \C{p.+1} for
some \C{p}, but in the latter case, it is often useful to also be able
to use \C{p} for further computations.  The usual approach
is to describe the two cases as patterns: if the data fits one of
the patterns, the computation proceeds with the corresponding
computation.  Here is an example:

\begin{coq}{name=pattern_on_nat}{}
match n with 0 => true | p.+1 => false end
\end{coq}
\index[concept]{inductive type!destructor}
\index[coq]{\C{match .. with .. end}}
In this expression we describe a computation where some decision is
taken depending on the value of the number \C{n}.  The fragment 
``\C{0 => true}'' expresses that when \C{n} is \C{0}, the final value is
\C{true}.  In this expression, \C{0} is a pattern and the computation
checks whether \C{n} matches this pattern.  The fragment
``\C{p.+1 => false}''  expresses that when \C{n} is the successor of
some number \C{p} the final value is \C{false}.  In other words, when
\C{n} is the successor of somebody, then the returned value is
\C{false}.  The value bound to the name \C{p} mentioned in this pattern is not
known in advance, it is actually computed at the moment the \C{n} is matched
against the pattern.  For instance, if \C{n} is \C{5}, then the value computed
for \C{p} is \C{4}.  In this particular instance, \C{p} is not used, so that we
can also write as follows:

\begin{coq}{name=pattern_on_nat}{}
match n with 0 => true | _.+1 => false end
\end{coq}
The symbol \C{_} is used to represent a pattern whose value will never be
used.

This pattern can also be written using an ``\C{if .. then .. else ..}'' like
syntax:

\begin{coq}{name=pattern_on_nat_0}{}
if n is 0 then true else false
\end{coq}
\index[coq]{\C{if .. is .. then .. else ..}}

For an example where the pattern variable is actually used, we can
observe the function that returns the predecessor of a natural number
when it exists, or 0 otherwise.

\begin{coq}{name=pred}{}
Definition pred n := if n is u.+1 then u else n.
\end{coq}
\index[coq]{\C{pred} (predecessor)|seealso {\C{.-1}}}
Reading this function in detail, we see that the argument \C{n} is
matched with the pattern \C{u.+1}.  When this comparison
succeeds, the variable \C{u} receives the value of the immediate
subterm of \C{n} and the computation proceeds by computing the expression
in the \C{then} branch of the \C{if} statement.  This branch contains
exactly \C{u}, so this is the result value.  When the comparison
fails, this means that \C{n} has the form \C{0}, the returned value is
\C{n}, or equivalently \C{0}.

Assume for instance that \C{n} is \C{2}, in other words \C{n} is the
successor of the successor of \C{O}, which we could also write
\C{0.+1.+1}.  When matching \C{0.+1.+1} against the pattern \C{u.+1}
the value of \C{u} is found to be \C{0.+1}, in other words \C{1}.

Remark that we did omit the type of the input \C{n}.  Since \C{n} is scrutinized
as a natural number, i.e. matched against the \C{u.+1} pattern, \Coq{} fixes its
type to \C{nat}.  Actually, the \C{S} constructor belongs \emph{exactly}
to one inductive definition, the one of \C{nat}.

The pattern used in the \C{if} statement can be composed of
several nested levels of the \C{.+1} pattern.  For instance,
if we want to write a function
that returns \(n-5\) for every input larger than or equal to 5 and 0
for every input smaller than 5, we can write the following definition:

\begin{coq}{name=pred5}{}
Definition pred5 n :=
  if n is u.+1.+1.+1.+1.+1 then u else 0.
\end{coq}
On the other hand, if we want to describe a different computation for
three different cases and use variables in more than one case, it is
more convenient
to revert to the ``\C{match .. with .. end}'' syntax.  Here is an
example:

\begin{coq}{name=awkward5}{}
Definition three_patterns n :=
  match n with
    u.+1.+1.+1.+1.+1 => u
  | v.+1 => v
  | 0 => n
  end.
\end{coq}
This function maps any number \(n\) larger than or equal to 5 to \(n-5\),
any number \(n \in \{1, \ldots, 4\}\) to \(n-1\), and \(0\) to \(0\).

The pattern matching construct ``\C{match .. with .. end}'' contains an
arbitrary large number of {\em pattern matching rules} of the form
``\emph{pattern}\C{ =>$~$}\emph{result}'' 
separated by the \C{|} symbol.  Optionally one can
prefix the first pattern matching rule with \C{|}, in order to make each line
begin with \C{|}.\index[concept]{pattern matching}

For the symbols that are allowed
in the pattern, they are essentially restricted to \C{O}, \C{S} and
variable names.  Thanks to notations, a pattern can also contain
occurrences of the notation ``\C{.+1}'' which represents \C{S}, and
decimal numbers, which represent the corresponding terms built with
\C{S} and \C{O}.  When a variable name occurs, this variable can be
re-used in the result part.  When computing with a natural number, all
the pattern matching rules are tried successively against this number.  The
patterns may overlap, but the result is given by the first pattern that
matches.
For instance with the function \C{three_patterns}, if the input is \C{2}, in other words \C{0.+1.+1}, the first
rule cannot match, because this would require that \C{0} matches
\C{u.+1.+1.+1} and we know that \(0\) is not the successor of any
natural number, when it comes to the second rule \C{0.+1.+1} matches
\C{v.+1}, because the rightmost \C{.+1} in the value of \C{2} matches
the rightmost \C{.+1} part in the pattern and \C{0.+1} matches the \C{v} part
in the pattern.

A fundamental principle is enforced by \Coq{} on case analysis:
\emph{exhaustiveness}.  The patterns must cover all constructors of
the inductive type.  For example, the following definition is
rejected by \Coq{}.

\begin{coq}{name=f_plus_one}{width=6cm,title=Non exhaustive case analysis}
Definition wrong (n : nat) :=
  match n with 0 => true end.
$~$
\end{coq}
\coqrun{name=f_plus_one_run}{f_plus_one}
\begin{coqout}{f_plus_one_run}{width=6cm,title=Response}
Error: Non exhaustive pattern
matching: no clause found for
pattern S _
\end{coqout}
\index[concept]{pattern matching!exhaustiveness}

We conclude the section by showing a syntactic facility to scrutinize
multiple values at the same time.

\begin{coq}{name=awkward5}{}
Definition same_bool b1 b2 :=
  match b1, b2 with
  | true, true => true
  | false, false => true
  | _, _ => false
  end.
\end{coq}

This is parsed as follows

\begin{coq}{name=awkward5}{}
Definition same_bool b1 b2 :=
  match b1 with
  | true => match b2 with true => true | _ => false end
  | false => match b2 with true => false | _ => true end
  end.
\end{coq}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data: recursion}\index[concept]{recursion}

With only pattern-matching, we do not cope well with the fact that the
type \C{nat} of natural numbers actually contains an infinity of
elements.  To really handle infinity, the \Coq{} system provides another
facility, known as {\em recursivity}.  The idea behind recursivity is
that we can define a function while supposing that it is already
defined for a subset of the type.  This adds a new element for which
the function is defined, and progressively this makes that the
function is defined for all elements of the type.

\subsection{Recursion for natural numbers}

Many usual functions to deal with natural numbers are
defined recursively.  For instance, we can define addition in the
following manner:

\begin{coq}{name=redefine_add}{}
Fixpoint addn n m :=
  if n is p.+1 then (addn p m).+1 else m.
\end{coq}
\index[vernac]{\C{Fixpoint}}
\index[coq]{\C{addn}}
In this example, we learn that the keyword for defining a recursive
function is \C{Fixpoint}.  We see also that the function being
defined, here called \C{addn}, is used in the definition of the
function \C{addn} itself.  This text expresses that the value of
\C{(addn p.+1 m)} is
\C{(addn p m).+1} and that the value \C{(addn 0 m)} is \C{m}.
This first equality may
seem redundant, but there is progress when reading this equality from
left to right: an addition with \C{p.+1} as the first argument
is explained with the help of addition with \C{p} as the first
argument, and \C{p} is a smaller number than \C{p.+1}.  When considering the
expression \C{(addn 2 3)}, we can know the value by performing the following
computation:
\begin{tabbing}
\C{adfasdfasdfafafafafafaf}\=\kill
\C{(addn 2 3)} \> use the ``then'' branch, \C{p = 1}\\
\C{(addn 1 3).+1} \> use the ``then'' branch, \C{p = 0}\\
\C{(addn 0 3).+1.+1} \> use the ``else'' branch\\
\C{3.+1.+1}\> remember that \C{5 = 3.+1.+1}
\end{tabbing}
\index[concept]{computation}
When the computation finishes, the symbol \C{addn} disappears.  In
this sense, the recursive definition is really a definition.  Remark that
what the \C{(addn n m)} program does is simply to count \C{n} times the
successor starting from \C{m}.

An alternative way of writing \C{addn} relies explicitly on
pattern-matching rules instead of relying on an \C{if} statement.
This can be written as follows:

\begin{coq}{name=add_redef}{}
Fixpoint addn n m :=
  match n with
  | 0 => m
  | p.+1 => (addn p m).+1
  end.
\end{coq}
\index[coq]{\C{addn}}
With this way of writing the recursive function, it becomes obvious that
pattern-matching rules describe equalities between two symbolic
expressions, but these equalities are always used from left to right during
computations.

When writing recursive functions, the \Coq{} system imposes the
constraint that the described computation must be \emph{guaranteed to
terminate}.  The reason for this requirement is sketched in
section~\ref{sec:indreason}.
This guarantee relies on an analysis of the function's
description, to make sure that recursive calls always happen with a
given argument that decreases.  The most frequent technique to
establish this guarantee is that recursive calls happen on a variable
and this variable was introduced by a pattern in a pattern-matching
construct or in an ``\C{if .. is ..}'' statement, with the additional
constraint that the pattern-matching construct observes a variable
that was one of the function's inputs.
\index[concept]{recursion!termination}
\index[concept]{termination}

For instance, in the case of \C{addn}, the recursive call happens
with \C{p} as the first argument, \C{p} was introduced by the pattern \C{p.+1}
in the corresponding pattern-matching rule, the pattern-matching
construct was observing \C{n}, and \C{n} is the first argument of the
function \C{addn}.  An erroneous, in the sense of non terminating,
definition is rejected by \Coq{}.

\begin{coq}{name=loop}{width=6cm,title=Non-terminating program}
Fixpoint loop n :=
 if n is 0 then loop n else 0.
$~$
\end{coq}
\begin{coqout}{}{title=Response,width=6cm}
Error: recursive call to loop has
principal argument equal to  "n"
instead of a subterm of "n".
\end{coqout}

% In function \C{add}, the first argument \C{n} is only used to
% repeat \C{n} times the operation of adding a \C{.+1} on the second
% argument.  This corresponds to the fact that the \C{p} is only used in
% the recursive call.  The programming language makes it possible to do
% more.  For instance, for a given function \(f\), we might want to add all
% the values \(f 0 + f 1 + \cdots + f n\).  This would be done in the
% following manner:
% 
% \begin{coq}{name=example_sum_f}{}
% Fixpoint sum_f (f : nat -> nat) (n : nat) :=
%   if n is p.+1 then add (f n) (sum_f p) else f 0.
% \end{coq}
% 
If addition tantamounts to repeating the operation of adding a \C{.+1}
to one of the arguments, subtraction tantamounts to repeating the
operation of fetching a subterm of the first argument.  This is also
easily expressed using pattern matching constructs.  Here again,
subtraction is already defined in the libraries, but we can play the game
of re-defining our own version.

\begin{coq}{name=sub}{}
Fixpoint subn m n : nat :=
  match m, n with
  | p.+1, q.+1 => subn p q
  | _ , _ => m
  end.
\end{coq}
\index[coq]{\C{subn}}
From a mathematical point of view, this definition can be quite
unsettling.  The second pattern matching rule indicates that when
the second argument of the subtraction is \C{0}, then the result is
the first argument.  But it also covers the case where the second
argument is non-zero while the first argument is 0.  This phenomenon
is imposed by the fact that the function must be total (all functions
are total in the \Coq{} system) and the type \C{nat} does not contain any
element to represent negative numbers.  When the second argument is non-zero
and the first argument is zero, a value must still be returned and
{\em this value must be a natural number}.  In the long run, this
problem will be solved by introducing another type of numbers with
negative integers.

Recursive functions also make it possible to test data for
equality. We can for example write a function with two arguments of
type \C{nat}, that
returns \C{true} exactly when the two arguments are equal.

\begin{coq}{name=nat_eq_def}{}
Fixpoint eqn m n :=
  match m, n with
  | 0, 0 => true
  | p.+1, q.+1 => eqn p q
  | _, _ => false
  end.
\end{coq}
The last rule in the code of this function actually covers two cases :
\C{0, _.+1} and \C{_.+1, 0}.

For equality test functions, it is useful to add a more intuitive
notation.  For instance we can attach a notation to \C{eqn} in
the following manner:

\begin{coq}{name=notation_my_eq}{}
Notation "x == y" := (eqn x y).
\end{coq}
Now
that we have programmed this equality test function, we can verify
that the \Coq{} system really identifies various ways to write the same
natural number.

\begin{coq}{name=equalities}{width=6cm}
Eval compute in 0 == 0.
Eval compute in 1 == S 0.
Eval compute in 1 == 0.+1.
Eval compute in 2 == S 0.
Eval compute in 2 == 1.+1.
Eval compute in 2 == add 1 0.+1
\end{coq}
\coqrun{name=equalities_run}{equalities}
\begin{coqout}{equalities_run}{width=6cm}
= true : bool
= true : bool
= true : bool
= false : bool
= true : bool
= true : bool
\end{coqout}

In this section, we introduced a variety of functions and notations
for operations on natural numbers.  In practice, these functions and
notations are already provided by the \mcbMC{} library.  In particular
it provides addition (named \C{addn}, infix notation \C{+}), 
multiplication
(\C{muln}, \C{*}), subtraction (\C{subn}, \C{-}), division (\C{divn},
\C{\%/}),  modulo (\C{modn}, \C{\%\%}), exponentiation (\C{expn}, \C{\^})
equality comparison (\C{eqn}, \C{==}), order
comparison (\C{leq}, \C{<=}) on natural numbers.  The trailing \C{n} in
the names is chosen to signal that these operations are on the \C{nat} data
type.  Postfix notations such as \C{.-1} and \C{.*2} are provided for
the predecessor and double functions.
\index[coq]{\C{(_ .-1)}}
\index[coq]{\C{(_ .*2)}}

The \mcbMC{} library also provides concepts that makes sense only
for the \C{nat} data type (hence the trailing \C{n} is omitted) and
that we will use many times in this book.  In particular the
test functions identifying \C{prime} and \C{odd} numbers have no trailing
\C{n} in their name.

We advise the reader not to ``explore'' the library from \Coq{}, but
rather to browse the source files.\footnote{\url{http://math-comp.github.io/math-comp/htmldoc/libgraph.html}}
While the \C{Print}
command can be quite useful in some circumstances, there is so much more
information in the source files.  
The relevant files for this chapter are \lib{ssrbool}, \lib{ssrnat}
and, later, \lib{seq}.

\mantra{Each file in the \mcbMC{} library
starts with a banner describing all concepts and associated notations.
There is not better way to browse the library than reading these banners.}

Before moving on it is worth detailing the definition of \C{leq}
and some associated notations.

\begin{coq}{}{}
Definition leq m n := m - n == 0.
Notation "m < n"  := (m.+1 <= n).
Notation "n > m"  := (m.+1 <= n) (parsing only).
Notation "a <= b <= c" := ((a <= b) && (b <= c)).
\end{coq}
\index[coq]{\C{leq}}
This definition relies on the fact that subtraction computes to \C{0} whenever
the first argument is less than or equal to the second argument.
 Finally note that the strict order
relation is just a notation, and that \C{(n > m)} is only accepted in input
and is always printed as  \C{(m < n)}.

\gotcha{There is no function testing if a natural number is strictly
smaller than another one.  \C{(a < b)} is just syntactic 
sugar for \C{(a.+1 <= b)}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data: generic containers}\label{sec:poly}

It is often the case that we wish to group several objects in a
sequence that can be manipulated as a single object.  For instance, we
might want to compute the sequence of all predecessors or all divisors
of a number.  We could define such a data type as follows.

\begin{coq}{name=list_def}{}
Inductive listn := niln | consn (hd : nat) (tl : listn).
\end{coq}

Elements of this data type can hold zero or more natural numbers, for example

\begin{coq}{}{width=6.5cm}
Check consn 1 (consn 2 niln).
Check consn true (consn false niln).
$~$
$~$
\end{coq}{}{}
\begin{coqout}{}{width=5.7cm}
consn 1 (consn 2 niln) : listn
Error: the term "true" has
type "bool" while it is
expected to have type "nat".
\end{coqout}{}{}

As expected, elements of this data type cannot hold boolean values.
So if we need to
manipulate a list of booleans we have do define a similar data type.

\begin{coq}{name=list_def}{}
Inductive listb := nilb | consb (hd : bool) (tl : listb).
\end{coq}

It is clear that this approach is problematic.  First, every time we
write a function that manipulates a list we have to choose a priori
if the list holds numbers or booleans, even if the program does not
really use the objects held in the list.
A concrete example is the function that computes the length of the list,
%% YB: should we use the word size here, to be consisted with the later def.
and in the current setting such function has to be written twice.
Worse, starting from the next chapter we will prove properties of programs,
and given the two size functions are ``different'' we are going to prove
properties twice.

However it is clear that the two data types we just defined follow
a similar schema, and so do the two functions for computing the length of lists
or the theorems we may prove about these functions.  In other words
one would write something
like the following, where $\alpha$ is a schematic variable.

\begin{coq}{name=list_def}{}
Inductive list := nil | cons (hd : $\alpha$) (tl : list).
\end{coq}

\noindent Even if this may look familiar jargon to some readers, we really want
this $\alpha$ to be a first class citizen, as well as the type of lists carrying
any type of values and not appeal to some notion of schema that would be
intuitively added on top of the \Coq{} language.  We want to 
reason and
prove theorems about such data types and related programs inside the formal
language \Coq{} provides and we want the proofs of these theorems
theorems to be first
class citizen too (see for example chapter~\ref{ch:sigmabool}).

\Coq{}'s language is powerful enough to fully characterize the generic 
list data type without appealing to an intuitive but external notion of
schema.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The (polymorphic) sequence data type}
\index[concept]{polymorphism}

The \mcbMC{} library provides a generic data type to hold
several objects of any type under the name \C{seq}.

\begin{coq}{name=list_def}{}
Inductive seq (A : Type) := nil | cons (hd : A) (tl : seq A).
\end{coq}
This definition actually describes the type of lists as a {\em
  polymorphic type}.  This means that there is a different type
\C{(seq A)} for each possible choice of type \C{A}.  For example
\C{(seq nat)} is the type of sequences of natural numbers, while
\C{(seq bool)} is the type of sequences of booleans.
The type of the
constructor \C{cons} is devised specifically to describe how to produce a
new list of type \C{(seq A)} by combining an element of \C{A} and an
existing list of type \C{(seq A)}.  This also means that this data-type
does not allow users to construct lists where the first element would be
a boolean value and the second element would be a natural number.

In the declaration of \C{seq}, \C{Type} is a keyword that denotes the
\emph{type of all data types}.  For example \C{nat} and \C{bool} are of type
\C{Type}, and can be used in place of \C{A}.
In other words \C{seq} is a function of type \C{(Type -> Type)}, sometimes
called a \emph{type constructor}.  The symbol \C{seq} alone does not
denote a data type,
but if one passes to it another data type, then it builds one.  Remark
that this also means that \C{(seq (seq nat))} is a valid data type, and
that the construction can be iterated.
Types again avoid confusion: it is not licit to form the type \C{(seq 3)},
since the argument \C{3} has type \C{nat}, while the function
\C{seq} expects an argument of type \C{Type}.\footnote{For historical
reasons \Coq{} may display the type of \C{nat} or \C{bool} as \C{Set}
and not \C{Type}.  We beg the reader to ignore this detail, that indeed
plays no role in the \mcbMC{} library.}

In principle, all objects of the data type definition have a type
argument:  
\C{nil} is a function that takes a type \C{A} as argument and returns
an empty list of type \C{(seq A)}.  The notation ``\C{.. -> ..}'' is not
well suited for this kind of situation and the type of \C{nil} is
rather written as follows:

\begin{coq}{name=type_of_nil}{}
  forall A : Type, seq A
\end{coq}
\index[coq]{\C{forall}}
The same goes for the other constructor of list, named \C{cons}.  This
function actually takes three arguments: a type \C{A}, a value in this
type, and a value in the type \C{(seq A)}.  The type of \C{cons} is
thus written as follows:

\begin{coq}{name=type_of_cons}{}
  forall A : Type, A -> seq A -> seq A
\end{coq}
This information can actually be obtained from the system by using the 
command \C{About}.

\begin{coq}{name=about_cons}{width=3cm,title=Query}
About cons.
$~$
$~$
\end{coq}
\begin{coqout}{about_cons_run}{width=9cm,title=Response}
cons : forall A: Type, A -> seq A -> seq A

Argument A is implicit and maximally inserted
\end{coqout}
\coqrun{name=about_cons_run}{about_cons}
\index[concept]{implicit argument}

In practice, the \Coq{} system implements a mechanism to avoid that
people need to give the type argument to the \C{cons} function.  This is
the information meant by the message ``\C{Argument A is implicit and
  ..}''.  Every time users write \C{cons}, the system automatically
inserts an argument in place of \C{A}, so that this argument does not
need to be written (the argument is {\em implicit}).  It is then the
job of the \Coq{} system to guess what this argument is when looking at
the first explicit argument given to the function.  The same happens
to the type argument of \C{nil}.  In the end, this makes that users can
write the following expression.

\begin{coq}{name=check_list_2}{width=6cm,title=Query}
Check cons 2 nil.
\end{coq}
\begin{coqout}{check_list_2_run}{width=6cm,title=Response}
[:: 2] : seq nat
\end{coqout}
\coqrun{name=check_list_2_run}{check_list_2}
\index[coq]{\C{(_ :: _)}}
This example shows that the function \C{cons} is only applied
explicitly to two arguments (the two arguments effectively declared
for \C{cons} in the inductive type declaration).
The first argument, which is implicit,
has been guessed so that it matches the actually type of \C{2}.  For 
\C{nil} also, the argument has been guessed to match the constraints
that it is used in a place where a list of type \C{(seq
nat)} is expected.  

This example, and the following ones, also show
that \Coq{} and the \mcbMC{} library provide
a collection of notations for lists.

\begin{coq}{name=check_list_2}{width=6cm,title=Query}
Check 1 :: 2 :: 3 :: nil.
Check fun l => 1 :: 2 :: 3 :: l.
$~$
\end{coq}
\begin{coqout}{check_list_2_run}{width=6cm,title=Response}
[:: 1; 2; 3] : seq nat
fun l => [:: 1, 2, 3 & l]
  : seq nat -> seq nat
\end{coqout}
\coqrun{name=check_list_2_run}{check_list_2}
\index[coq]{\C{[:: .. , .. & ..]}}

In particular \Coq{} provides the infix notation \C{::} for
\C{cons}.  The \mcbMC{} library follows a general pattern for
n-ary constructors, in particular \C{[::} begins the repetition
of \C{::} and \C{]} ends it.  Elements are separated by \C{,} (comma)
but for the last one separated by \C{&}.
For example one
can write as \C{[&& true, false & true]} the boolean conjunction
of three terms.\footnote{Some n-ary notation use a
different, but more evocative, last separator.  For example one writes
\C{[|| b1, b2 | b3]} and \C{[==> b1, b2 => b3]}.}
\index[coq]{\C{["|"| .. , .. "| ..]}}
\index[coq]{\C{[&& .. , .. & ..]}}
\index[coq]{\C{[==> .. , .. => ..]}}
For sequences that are \C{nil}-terminated, a very frequent case,
the \mcbMC{} library provides an additional notation where all elements are
separated by \C{;} (semi-colon) and the last element, \C{nil},
is omitted.
\index[coq]{\C{[seq .. ; ..]}}

When programming with sequences, we can again use the  pattern matching
syntax form to express how data can be retrieved from a sequence.  For
instance, to retrieve the first element of a sequence of natural numbers
or 0 if the sequence does not contain any element, we can write the
following code:

\begin{coq}{name=first_element}{}
Definition first_element_or_0 (s : seq nat) :=
  match s with
  | nil => 0
  | cons a _ => a
  end.
\end{coq}
Using the notations for {\tt cons} and {\tt nil}, we can also write

\begin{coq}{name=first_element1}{}
Definition first_element_or_0 (s : seq nat) :=
  match s with
  | [::] => 0
  | a :: _ => a
  end.
\end{coq}
Using the \C{if} syntax, we can write:

\begin{coq}{name=first_element2}{}
Definition first_element_or_0 (s : seq nat) :=
  if s is a :: _ then a else 0.
\end{coq}
\subsection{Recursion for sequences}
Because the second explicit argument of \C{cons} can also be a sequence, it is
possible to build sequences that are quite long, but always finite.
In this respect, the sequences are very similar to the natural
numbers.  Recursion is again the solution to cope with the arbitrary
length of sequences with functions that can be described concisely.

For instance, we can define a size function that counts the number of
elements in a sequence.

\begin{coq}{name=def_size}{}
Fixpoint size A (s : seq A) :=
  if s is _ :: tl then (size tl).+1 else 0.
\end{coq}
\index[coq]{\C{size}}
During computation on a given sequence, this function will traverse
the whole sequence, adding 1 to the result for every
\C{cons} pattern that is encountered.  It should be noted that in this
definition, the function \C{size} is described as a two argument
function, but the recursive call \C{(size tl)} is done by providing
explicitly only one argument, \C{tl}.  This is because
%we started the
%\Coq{} session with, among other commands, the command ``\C{Set Implicit
%  Arguments}''.  According to this directive, 
the \Coq{} system makes
arguments of functions that can be guessed from the type of following
arguments automatically implicit.  This feature is effective directly
at definition time.

Another example of recursive function on sequences is a function that constructs
a new sequence where all elements are values of a given function applied to
the elements of an input sequence.  This function can be defined in this
manner.

\begin{coq}{name=def_map}{}
Fixpoint map A B (f : A -> B) s :=
  if s is e :: tl then f e :: map f tl else nil.
\end{coq}
\index[coq]{\C{map}}
With this function it is also interesting to understand how we can
improve the notations.  For instance, we will add a notation that
makes it more apparent that the result is {\em the sequence of all
expressions \(f(i)\) for \(i\) taken from another sequence}.

\begin{coq}{name=notation_map}{}
Notation "[ 'seq' E | i <- s ]" := (map (fun i => E) s).
\end{coq}
For instance, with this notation we write the computation of successors
for a given sequence of natural numbers as follows:

\begin{coq}{name=try_map_notation}{width=7.8cm,title=Query}
Eval compute in [seq i.+1 | i <- [:: 2; 3]].
\end{coq}
\begin{coqout}{try_map_notation_run}{width=4.3cm,title=Response}
= [:: 3; 4] : seq nat
\end{coqout}
\coqrun{name=try_map_notation_run}{try_map_notation}
\index[concept]{list comprehension}
\index[coq]{\C{[seq .. "| .. <- ..]}}
In addition to the function \C{map} and the associated notation
we studied here, the \mcbMC{} library
provides a large collection of useful functions and notations to work on
sequences, as described in the header of the file \lib{seq}.  For
instance \C{[seq i <- s | p]} filters the sequence \C{s} keeping only
the values selected by the boolean test \C{p}.
Another useful function for sequences is \C{cat} (with infix notation \C{++})
that is used to catenate two sequences together.
\index[coq]{\C{(_ ++ _)}}
\index[coq]{\C{[seq .. <- .. "| ..]}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Other containers}\label{sec:othercontainers}
The simplest polymorphic data type one can think about is the option type

\begin{coq}{}{}
Inductive option A := None | Some (a : A).
\end{coq}
\index[coq]{\C{option}}
It represents a box that can be either empty or contain a value.
It is sometimes used to represent a partial function, or a filter.

\begin{coq}{}{}
Definition only_odd n : option n := if odd n then Some n else None.
\end{coq}
For example the sub-type kit presented in chapter~\ref{ch:sigmabool} makes use
of the option type to describe a partial injection.

Another widespread polymorphic data type is the one of pairs, that
lets one put together any two values.  While we leave its definition
as an exercise (see~\ref{ex:pair}) we briefly discuss the associated
notations: \C{(a,b)} builds the pair of \C{a} and \C{b} while \C{c.1}
projects the first component of the pair \C{c}.  The type of pairs is
denoted by an infix \C{*} symbol: \C{(nat * bool)} is the type of
pairs that have a natural number as the first component and a boolean
value as the second one.

\begin{coq}{}{width=6cm}
Check (3, false).
Eval compute in (true, false).1.
\end{coq}
\begin{coqout}{}{width=6cm}
(3, false) : nat * bool
true : bool
\end{coqout}
As one expects pairs can be nested, as in \C{(3,true,4)}, that is sugar
for \C{((3,true),4)}.  In such situation the value \C{true} can be
accessed by writing \C{(3,true,4).1.2}.

Given the notation for pairs, the expression \C{(a * b)} is now ``ambiguous'',
in the sense that the same infix \C{*} symbol can be used to multiply two
natural numbers as in \C{(1 * 2)} but also to write the type of pairs \C{(nat *
bool)}.  Such ambiguity is somewhat justified by the fact that the pair
data type can be seen as the (cartesian) product of the arguments.  Such
ambiguity can be resolved by annotating the expression with a specific
label: \C{(a * b)\%N} interprets the infix \C{*} as multiplication of natural numbers,
while \C{(a * b)\%type} would interpret \C{*} as the pair data type
constructor. The \C{\%N} and \C{\%type} labels are said to be
\emph{notation scope delimiters} (for more details see
\cite[section 12.2]{Coq:manual}).\index[concept]{notation scope}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Section mechanism}
\index[concept]{section}
When several functions are designed to work on similar data, it is
useful to set a working environment where the common data is declared
only once.  Such a working environment is called a \C{Section}, and
the data that is local to this section is declared using \C{Variable}
commands.  A typical example happens when describing functions that
are polymorphic and rely in a uniform way on a given type and existing
functions in this type.

\begin{coq}{name=simple_monoid_structure}{}
Section iterators.

Variables (T : Type) (A : Type).
Variables (f : T -> A -> A).

Implicit Type x : T.

Fixpoint iter n op x :=
  if n is p.+1 then op (iter p op x) else x.

Fixpoint foldr a s :=
  if s is x :: xs then f x (foldr a xs) else a.

End iterators.
\end{coq}
\index[vernac]{\C{Section}}
\index[vernac]{\C{Variable}}
\index[vernac]{\C{Implicit Type}}
\index[coq]{\C{foldr}}\index[coq]{\C{iter}}
The \C{Section} and \C{End} keyword delimit a scope in which
the variables \C{T}, \C{A} and \C{f} are available.  These variables
are used in the definition of \C{iter} and \C{foldr}.  When
the section is closed, these variables appear as arguments to
the various function that use them.

\begin{coq}{}{width=3.5cm,title=Query}
About iter.
About foldr.
$~$
\end{coq}
\begin{coqout}{close_section_run}{title=Response, width=8.5cm}
iter : forall T : Type, nat -> (T -> T) -> T -> T
foldr :
  forall T A : Type, (T -> A -> A) -> A -> seq T -> A
\end{coqout}
The \C{Implicit Type} annotation tells \Coq{} that, whenever we name
an input \C{x} its type is supposed to be \C{T}.

If we observe the definition of \C{iter}, this definition tells us
that \C{iter} has three argument.  The first one, \C{n}, is used in
a pattern-matching if-then-else statement and matched with a pattern of the
form \C{p.+1}.  For this reason, we can guess that \C{n} has the type \C{nat}.
The value returned by \C{iter} is either \C{x} or \C{op (iter p op x)}, so this
tells us the value must have the same type as \C{x}.  Here the type of 
\C{x} is not fixed by the definition of \C{iter}, but by the previous clause:
\C{Implicit Type x : T}.  So we know that the value returned by \C{iter}
has to be \C{T}.  Scrutinizing the ``then'' part of the if-then-else statement,
we can also infer that \C{op} must have the type \C{T -> T}.  So the type
of \C{iter} relies in several occasions on the type \C{T}.  However, we are
now outside the section, so the variable \C{T} is not in
scope anymore.  This means that the function \C{iter}, when considered
outside the section, must be ready to receive, {\em first an arbitrary type
 \C{T}, then a natural number, then a function of type \C{T ->T}, then a
value of type \C{T}}.  In the text defining \C{iter} (inside the section), the
type \C{T} did not appear to be an argument, but once we are outside
the section, the type \C{T} has to be an argument of \C{iter}.  Moreover,
the argument for \C{T} has to receive a name, so that we can refer to it when
describe the type of the other arguments.  We need to re-use the \C{forall}
notation that was already useful when mentioning generic data types.

This process, where a function appears to have more arguments outside
the section where it was defined than inside the section is called
an {\em abstraction mechanism}.\index[Concepts]{Abstracting variables}.
It only occurs when a section variable is used inside the definition or
the type of a defined object.  In this case, the type \C{T} is a section
variable that is used in the type of \C{iter}, so it needs to be
abstracted for \C{iter} when the section is closed.

Now, let us study how this abstraction process works for the other definition
in this section, \C{foldr}.  We know that the last argument \C{s} of \C{foldr}
must be a sequence, because it is matched with a pattern that is specific
to sequences.  Moreover, we know that the first element of this sequence,
when it exists, is passed as first argument of the function \C{f}, and
we know (from the type declaration at line 4) that the first argument of
\C{f} should be of type \C{T}.  So \C{s} has to have type \C{seq T}.
Looking at the ``then'' branch of the if-then-else statement, we also see
that \C{foldr a xs} is used as the second argument to \C{f}, so it should
have type \C{A}, so we can also infer that \C{a} should have the type \C{A}.
So in all, the function \C{foldr} relies on all the section variables and
they all have to be added as arguments.

Variables are abstracted in their order of declaration.  In our example,
\C{T} and \C{A} appear in the same order in the type of {\tt foldr} as
in the variables declarations for the section.  Variables that are actually
not use in a given definition are omitted, for example \C{iter}
is not abstracted on \C{f}.

Once the section is closed, \C{iter} and \C{foldr} behave exactly as
if they were defined as follows:

\begin{coq}{}{}
Fixpoint iter T n op (x : T) :=
  if n is p.+1 then op (iter p op x) else x.
Fixpoint foldr T A (f : T -> A -> A) a s :=
  if s is x :: xs then f x (foldr f a xs) else a.
\end{coq}
For example we can compute the subtraction of \C{5} from \C{7}, or the 
addition of all numbers in \C{[:: 1; 2; 3]}
as follows:

\begin{coq}{}{width=8cm}
Eval compute in iter 5 pred 7.
Eval compute in foldr addn 0 [:: 1; 2; 3].
\end{coq}
\begin{coqout}{}{width=4cm}
 = 2 : nat
 = 6 : nat
\end{coqout}

The \C{Section} mechanism lets one reuse variable declaration and type
annotations among multiple definitions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Symbolic computations under a context}
\index[concept]{computation!symbolic}

Which is the status of the \C{foldr} program \emph{before} the
\C{Section} is closed?  What are \C{T} and \C{A} and \C{f}?

\begin{coq}{}{}
Section iterators.

Variables (T : Type) (A : Type).
Variables (f : T -> A -> A).

Fixpoint foldr a s :=
  if s is x :: xs then f x (foldr a xs) else a.
\end{coq}

The variables \C{T}, \C{A} and \C{f} form the so called
\emph{local context} under which all operations take place.
For example, computing the type of \C{foldr} gives the following:

\begin{coq}{}{width=3.5cm,title=Query}
About foldr.
\end{coq}
\begin{coqout}{close_section_run}{title=Response, width=8.5cm}
foldr : A -> seq T -> A
\end{coqout}

This indicates that \C{foldr} is not a polymorphic function (yet)
and that it takes only two arguments, an element of \C{A} and
a list of \C{T}.

If the operation we intend to perform is computation, then
\C{T}, \C{A} and, most importantly, \C{f} are symbols.
 \C{f} in particular represents an unknown function.
Computation involving \C{f} hence becomes symbolic:

\begin{coq}{}{width=7cm}
Variable init : A.
Variables x1 x2 x3 : T.
Eval compute in
  foldr init [:: x1; x2; x3].
\end{coq}
\begin{coqout}{}{width=5cm}
= f x1 (f x2 (f x3 init))
: A	
\end{coqout}

\Coq{} has developed the expression symbolically.  As a mind
experiment, we can substitute \C{f} with \C{addn}, and
\C{[:: x1; x2; x3]} with \C{[:: 1; 2; 3]}.  We obtain
\begin{coq}{}{}
addn 1 (addn 2 (addn 3 0))
\end{coq}
that indeed is an expression that computes to 6.

In later chapters we are going to prove properties about \C{foldr}.
In such cases the local context has to be understood as containing
names (and type annotations) of fixed, but unknown, objects.
Hence proving a property of \C{foldr} when the iterated function
\C{f} is unknown means proving that such a property is true for any
possible value of \C{f}.

Symbolic computation  is going to play an important role in the activity
of proving
and the way programs are written has an impact on the way they
compute symbolically.  For example, let's consider this alternative
definition of the addition between natural numbers

\begin{coq}{}{}
Fixpoint add m n := if m is u.+1 then add u n.+1 else n.
\end{coq}
\index[coq]{\C{add}}

It is a sensible definition, and we can show that the two additions
compute the same results when computing with completely known natural
numbers.  Still, their computational behavior differ when computing on
arbitrary symbolic values.
This time we use the \C{simpl} evaluation strategy.  The relevant difference
is that \C{simpl} leaves expressions in nicer forms whenever they contain
variables.

\begin{coq}{}{width=7cm}
Variable n : nat.
Eval simpl in pred (add n.+1 7).
Eval simpl in pred (addn n.+1 7).
\end{coq}
\begin{coqout}{}{width=5cm}
= pred (add n 8)
= addn n 7
\end{coqout}

Here we see that since \C{addn} exposes bits of its
final result early the \C{pred} function can compute, and cancels
the \C{.+1} coming out of the sum.  On the other hand,
\C{add} does not expose a successor, instead it carries it on the second
argument and symbolic computation in \C{pred} is stuck.
Is some sense \C{addn} is more
explicit about its result, and this helps, for example, to show that
\C{(addn n.+1 7)} is different from \C{0} (see for example
the proof of \C{muln_eq0} in section~\ref{proof:mulneq0}).
As we have seen \Coq{} computes
automatically and in this case computation would expose a \C{S} symbol
and no natural number of the form \C{(S  ..)} can be equal to 0.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Iterators in mathematics}
\index[concept]{general term|seealso {higher order}}
\label{sec:bigopnat}

Numbers and sequences of objects are common in mathematics, so we feel
no need to justify our choice to present them in this chapter.
On the other hand, we can wonder what role programs like \C{foldr}
play in mathematics.
Let's take the left hand side of these two formulas:
$$
\sum_{i=1}^n (i * 2) - 1 = n ^ 2 \qquad
\sum_{i=1}^n i = \frac{n * (n + 1)}{2}
$$
They can both be faithfully represented by using \C{foldr}.

\begin{coq}{}{}
Fixpoint iota m n := if n is u.+1 then m :: iota m.+1 u else [::].
Notation "\sum_ ( m <= i < n ) F" :=
  (foldr (fun i a => F + a) 0 (iota m (n-m))).
\end{coq}
\index[coq]{\C{iota}}
\index[coq]{\C{\\sum}}

The \C{iota} function generates the list of natural numbers
corresponding to the range of the summation.  We also provide
to \C{foldr} the neutral element for the addition as the initial value
of the iteration.

\begin{coq}{}{width=8.5cm,title=Query}
Eval compute in \sum_( 1 <= i < 5 ) (i * 2 - 1).
Eval compute in \sum_( 1 <= i < 5 ) i.
\end{coq}
\begin{coqout}{}{width=3.5cm,title=Response}
= 16 : nat
= 10 : nat
\end{coqout}{}{}

The iteration happens following the order of the list.
In this case the operation, addition, is commutative, so it does not really
matter, but it may not be the case for example if the iterated operation
is group multiplication.  What is even more crucial is that
\C{foldr} takes as input a \emph{functional argument that
is able to represent faithfully any general term}.

The ability to write programs that manipulate functions, like \C{foldr}, is
crucial not only to provide convenient notations.  As we sketched in the
previous section we will be able to prove properties about \C{foldr} without
knowing the iterated function.  By assuming properties linking the iterated
operation to the initial value, like forming a Monoid, we will be able to
provide a generic theory of iterated operations in section~\ref{sec:bigop}.  
Such a theory becomes richer
when the operation is also commutative, and even richer when we combine two
operations that distribute.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Notations and abbreviations}
\index[concept]{notation}
\index[concept]{abbreviation}

We already mentioned several time the \C{Notation} command, relying on the
reader's intuition to understand roughly how it works.  The actual command is
quite complex, letting one specify associativity and precedence to the
parsing engine, as well as the group to which the notation belongs and some
hint for printing, like good
line breaking points.  The notation group is usually called a {\em scope} and it
is usually associated to a {\em scope delimiter}.


\begin{coq}{}{}
Notation "m + n" := (addn m n) (at level 50, left associativity). 
Notation "n .+1" := (succn n) (at level 2, left associativity,
  format "n .+1") : nat_scope.
\end{coq}
\index[vernac]{\C{Notation}}
A comprehensive description of this command goes behind
the scope of this book, the interested reader shall refer to~\cite[Chapter 12]{Coq:manual}.

What is worth mentioning here is some conventions either imposed by \Coq{}
or adopted in the \mcbMC{} library.

\begin{itemize}
\item A symbol starts with a non alpha-numerical character followed by
	any character.  For example \C{.+1} is a single symbol, and so are
	\C{.+4}, \C{\%/}, \C{<=}, and \C{[::}.  Only existing
	symbols are taken into account: \C{3.+1.+1} is parsed as a number
	followed by two occurrences of the \C{.+1} symbol.  In principle,
         \C{.+1.+1} could be a symbol, but no notation declares it.
%\marginnote{I know it is not correct, but no user would prefer the correct explanation}
\item Notations that are typically denoted with a letter, like $N(G)$ for the
	normalizer of the group $G$ are represented by symbols beginning
	with \C{'} as in \C{'N(G)}, where \C{'N} is a symbol.
\item At the time of writing, notations for numerical constants are specially
	handled by the system.  The algebraic part of the library overrides
	specific cases, like binding \C{1} and \C{0} to ring elements.
\item n-ary notations begin with \C{[} followed by the symbol of the
	operation being repeated, as in \C{[&& true, false & false]}.
\item postfix notations begin with \C{.}, as in \C{.+1} and \C{.-group}
	to let one write \C{(p.-group G)}.
\end{itemize}

Another frequently used form of notation is called syntactic abbreviation.
It simply lets one specify a shorter name.  For example the \C{S} constructor
of natural numbers (placed in \C{Datatype} Module) can also be accessed
by writing \C{succn}.  This is useful if \C{S} is used in the current context
to, say, denote a ring.

\begin{coq}{}{}
Notation succn := Datatypes.S.
\end{coq}

For infix notations, which are meant to be printed between two arguments
of the operator (like addition in \C{2 + 3}), we advise to always include
space around the infix operator, so that notations don't get mixed up with
potential notations occuring in the arguments.

Last, we recall the notion of implicit argument sketched in
section~\ref{sec:poly}.  Once implicit arguments are active for
the \C{cons} and \C{nil} constructors, writing \C{(cons 3 nil)} 
abbreviates \C{(cons _ 3 (nil _))}.  The \C{_} denotes a term,
here a type, to be inferred by \Coq{}.  In this case the typing constraints
impose both \C{_} to be \C{nat}.  To locally disable the
status of implicit arguments one can prefix the name of a
constant with \C{@} and pass all arguments explicitly as in
\C{(@cons nat 3 nil)}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Aggregated data: records}
\index[concept]{record}\label{sec:records}

Sometime one wants to aggregate already available data into a single object.
For example a point in the 3-dimensional space could be represented with
three natural numbers.

Such a need is so frequent that \Coq{} provides a specialized command
to declare this class of data type.

\begin{coq}{}{}
Record point := Point { x : nat; y : nat; z : nat }.
\end{coq}
\index[vernac]{\C{Record}}
This is mostly equivalent to writing as follows:

\begin{coq}{}{}
Inductive point := Point (x : nat) (y : nat) (z : nat).
\end{coq}
\index[concept]{record}

The main advantage of using \C{Record} is that \Coq{} uses the names of the
constructor fields to generate functions to access the field's contents.  We
call these programs \emph{projections}.  I.e. after the \C{Record} declaration
one can write:

\begin{coq}{}{width=8.5cm,title=Query}
Eval compute in x (Point 3 0 2).
Eval compute in y (Point 3 0 2).
\end{coq}{}{}
\begin{coqout}{}{width=3.5cm,title=Response}
= 3 : nat
= 0 : nat
\end{coqout}{}{}
Where the code for the \C{x} projection is, as expected:

\begin{coq}{}{}
Definition x (p : point) := match p with Point a _ _ => a end.
\end{coq}
Inductive data with a single constructor, like records, comes
equipped with a specific notation for single-branch pattern
matching:

\begin{coq}{}{}
Definition x (p : point) := let: Point a _ _ := p in a.
\end{coq}
\index[coq]{\C{let: .. := .. in ..}}
\index[concept]{pattern matching!irrefutable}

Records can also be polymorphic, for example the pair data type of
Exercise~\ref{ex:pair} can carry two values of any type.

Records play a major role in the \mcbMC{} library, in particular
in the modelling of algebraic structures.   As we see in later chapters
records let one pack together types, operations on these types and
finally the properties of these operations.  For example a record
will model the signature of a Ring.  %% Why a capital letter YB

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Exercises}

%%%%%%%%
\begin{Exercise}[label=ex:pair,difficulty=0,title={The pair data type}]
Define the pair data type such that the following notation
applies.  Also define the projections.

\begin{coq}{}{width=7cm}
Notation "( A , B )" := (pair A B).
Notation "p .1" := (fst p).
Notation "p .2" := (snd p).
Eval compute in (4, 5).1.
Eval compute in (true, false).2.
\end{coq}
\begin{coqout}{}{width=5cm}
$~$
     = 4 : nat
     = true : bool
\end{coqout}
Remark that the pair data type has to be polymorphic in order to
be applicable to both natural numbers and booleans.
\end{Exercise}

%%%%%%%%
\begin{Exercise}[label=ex:iteradd,difficulty=0,title={Addition with iteration}]
Define a program computing the sum of two natural numbers
using \C{iter}.
\end{Exercise}

%%%%%%%%
\begin{Exercise}[label=ex:itermul,difficulty=0,title={Multiplication with iteration}]
Define a program computing the product of two natural numbers
using \C{iter}.
\end{Exercise}

%%%%%%%%
\begin{Exercise}[label=ex:nth,difficulty=0,title={Find the n-th element}]
Define a program taking a default value, a list and  a natural number.  Such
program returns the n-th element of the list if n is smaller than the size of
the list.  It returns the default value otherwise.

\begin{coq}{}{width=7cm}
Eval compute in
  nth 99 [:: 3; 7; 11; 22] 2.
Eval compute in
  nth 99 [:: 3; 7; 11; 22] 7.
\end{coq}
\begin{coqout}{}{width=5cm}
     = 11
     : nat
     = 99
     : nat
\end{coqout}
\end{Exercise}

%%%%%%%%%
\begin{Exercise}[label=ex:rev,difficulty=0,title={List reversal}]
Define the program \C{rev} that reverses the order of the elements
of a list. 

\begin{coq}{}{width=5cm}
Eval compute in
  rev [:: 1; 2; 3].
\end{coq}
\begin{coqout}{}{width=7cm}
 = [:: 3; 2; 1]
 : seq nat
\end{coqout}
\end{Exercise}

%%%%%%%%%%%%%
\begin{Exercise}[label=ex:flatten,difficulty=1,title={List flattening}]
Define the program \C{flatten} that takes a list of lists and returns
their concatenation.  Don't write a recursive function, just reuse
the concatenation function and one of the higher-order iterators
seen so far.

\begin{coq}{}{width=7.3cm}
Eval compute in
  flatten [:: [:: 1; 2; 3]; [:: 4; 5] ].
\end{coq}
\begin{coqout}{}{width=5cm}
 = [:: 1; 2; 3; 4; 5]
 : seq nat
\end{coqout}
\end{Exercise}


%%%%%%%%%
\begin{Exercise}[label=ex:allwords,difficulty=2,title={All words of size n}]
Define the \C{all\_words} program that takes in input a
length \C{n} and sequence of symbols \C{alphabet}.
Such program has to generate a list of all words (i.e. list
of symbols) of size \C{n}.

\begin{coq}{}{width=5.5cm}
Eval compute in
  all_words 2 [:: 1; 2; 3].
\end{coq}
\begin{coqout}{}{width=7cm}
 = [:: [:: 1; 1]; [:: 1; 2]; [:: 1; 3];
       [:: 2; 1]; [:: 2; 2]; [:: 2; 3];
       [:: 3; 1]; [:: 3; 2]; [:: 3; 3]]
 : seq (seq nat)
\end{coqout}
\end{Exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Solutions}

%%%%%%%%%%
\begin{Answer}[ref=ex:pair]

\begin{coq}{}{}
Inductive prod (A B : Type) := pair (a : A) (b : B).
Notation "A * B" := (prod A B) : type_scope.
Notation "( A , B )" := (pair A B).
Definition fst A B (p : A * B) := let: (a, _) := p in a.
Definition snd A B (p : A * B) := let: (_, b) := p in b.
\end{coq}
\index[coq]{\C{(_ * _)} (pairs)}
\index[coq]{\C{(_ , _)}}

\end{Answer}

%%%%%%%%%%
\begin{Answer}[ref=ex:iteradd]

\begin{coq}{}{}
Definition addn n1 n2 := iter n1 S n2.
\end{coq}

\end{Answer}

%%%%%%%%%%
\begin{Answer}[ref=ex:itermul]

\begin{coq}{}{}
Definition muln n1 n2 := iter n1 (addn n2) 0.
\end{coq}

\end{Answer}

%%%%%%%%%%
\begin{Answer}[ref=ex:nth]

\begin{coq}{}{}
Fixpoint nth T (def : T) (s : seq T) n :=
  if s is x :: tl then if n is u.+1 then nth def tl u else x else def.
\end{coq}

\end{Answer}

%%%%%%%%%%
\begin{Answer}[ref=ex:rev]

\begin{coq}{}{}
Fixpoint catrev T (s1 s2 : seq T) :=
  if s1 is x :: xs then catrev xs (x :: s2) else s2.

Definition rev T (s : seq T) := catrev s [::].
\end{coq}

\end{Answer}

%%%%%%%%%%%%%

\begin{Answer}[ref=ex:flatten]

\begin{coq}{}{}
Definition flatten T (s : seq (seq T)) := foldr cat [::] s.
\end{coq}

\end{Answer}

%%%%%%%%
\begin{Answer}[ref=ex:allwords]

\begin{coq}{}{}
Definition all_words n T (alphabet : seq T) :=
  let prepend x wl := [seq x :: w | w <- wl] in
  let extend wl := flatten [seq prepend x wl | x <- alphabet] in
  iter n extend [:: [::] ].
\end{coq}

\end{Answer}



%%%%%%%%%%%%%%%%%%%%%%%%%% End of written part %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theoretical content:
% \begin{itemize}
% \item Functions with simple types ($\lambda$, $\rightarrow$): functions are the primitive concept
% \item Inductive {\bf datas}
% \item Programs by case analysis and recursion
% \item Compute (beta, delta, iota) example of beta (that helps later on to explain a predicate for elim principles)
% \item Polymorphic data types (introduce $\Pi$, and its \Coq{} notation
%   \C{forall}, for quantification over data types only)
% \item Everyone has a type : \C{0 : nat : Type : Type}, types avoid confusion
% \end{itemize}
% This is more or less a standard introduction to (a flavor of)
% functional programming, with two possible difficulties:
% \begin{itemize}
% \item Be precise but not too technical (e.g. on inductive types)
% \item Find a line of speech which does not bore/discourage
%   mathematicians.
% \item Somehow the syntax of (this fragment of the) terms should made
%   be clear and precise.
% \item types depending on terms (matrix x m)
% \end{itemize}


% \begin{itemize}
% \item Use monomorphic instances/compatible versions of the notations
%   that will later be generalized using canonical structures;
% \item For instance the infix \C{==} is the comparison on \C{nat}
% \item Further examples: \verb+\sum_(i <- l) F i+, \verb+\sum_(a <= b <) F i+
% in order to illustrate \C{foldr}.
% \end{itemize}
% \Coq{} commands and features:
% \begin{itemize}
% \item Implicit arguments (only to go from system F to ML), \C{@}
% \item Sections and its discharging, implicit types
% \end{itemize}
% 
% 
% \Coq{} types introduced:
% \begin{itemize}
% \item \C{bool, nat, seq, option, prod}
% \end{itemize}
% 
% Programs presented in detailed examples/exercises:
% \begin{itemize}
% \item Elementary programs on \C{option}: \C{odflt, obind,}\dots
% \item Elementary programs on \C{seq} (without the \C{eqType}):
%   \C{size, map, iota,...}
% \item Comparison functions on \C{bool, nat}
% \item Comparison functions on containers, taking the comparison
%   function on the type of stored elements in argument (mind the
%   higher-order)
% \item Boolean connectives, arithmetic operations on \C{nat}
% \item Do not forget to mention \C{if .. then .. else}
% \item Euclidean division, computation of prime factors, examples from
%   elementary number theory
% \item Examples of G{\"o}del-style encoding from the {\tt choice.v} library.
% \item Examples/exercises about extended gcd (egcdn), which mix lists
%   and arithmetic.
% \end{itemize}
% If possible give a few context to the exercises, in order not to bore
% the reader not familiar with programming. For instance do not say that
% you encode sequences of nats in nats but give a few hints about the
% use of G{\"o}del encoding.
% 
% Examples and exercises can be executed in an empty context, or
% libraries can be required for the purpose of (re)using and combine existing
% programs (non proofs here).
% 
% The current contents are organized like the tutorial at ITP15 I gave (Enrico).
% It was on standard \Coq{} and was intended not to be difficult class ;-)
% It is a possible plan, no strong opinions.
% 
% \section*{Things needed by chapter 2}
% \begin{itemize}
% \item type annotations on arguments of lemmas/definitions can be omitted
% \item if then else
% \item all boolean connectives: \C{orb andb negb implb xorb}
% \item recursive programs: \C{addn muln subn leq eqn expn dvdn}
% \item notations with associativity: \C{+ * - == != .+1 < <= \%| \~\~}
% \end{itemize}
% 
% 
% \section{Functional programming in a nutshell}
% Only intuitions here.
% 
% For a mathematician this is perfectly natural, the main problem is the syntax.  E.g.
% $$f(x) = x * 2\qquad\qquad f(7)$$
% here we define a function named f that doubles its input.  Then we denote f(7) the value of f
% when the input is 7. The novelty is that:
% \begin{enumerate}
% \item functions are anonymous, and the names. \verb+(fun x => x * 2)+ is the function that
% 	doubles.  We can name it: \verb+Definition f := fun x => x * 2.+.  We don't need to
% 	name a function in order to use it in an expression. (there is something like
% 	\verb+x |-> x * 2+, but this is always attached to a name somehow).
% \item function application is \verb+(f 7)+.
% \end{enumerate}
% 
% For a computer scientist used to imperative languages, these are the main weird points:
% \begin{enumerate}
% \item there is no return statement, AKA expressions are already programs.  e.g.
% 	4 is a program, and 2+2 as well.  Programs then evaluate like a mathematical expression
% 	can be simplified
% \begin{verbatim}
%         if (false || true) then 2 + 2 else 7
%         if true then 2 + 2 else 7
%         2 + 2
%         4
% \end{verbatim}
% also
% \begin{verbatim}
%         2 + (if 7 == 2 then 4 else 2)
%         2 + (if false then 4 else 2)
%         2 + 2
%         4
% \end{verbatim}
% \item programs are really first class data (HO programming, not reasonably popular even outside
% 	the functional world). E.g.
%     This program takes in input a function f and uses it twice
% \begin{verbatim}
%       (fun f => f 3 + f 4)
% \end{verbatim}
% hence this is a valid program computing 14
% \begin{verbatim}
%       (fun f => f 3 + f 4) (fun x => x + x)
% \end{verbatim}
% \end{enumerate}
% 
% 
% \subsection{Build and destruct simple data}
% Simplest data is bool.
% 
% \begin{coq}{name=bool}{}
% Inductive bool : Type := true | false.
% Check bool : Type.
% Check true : bool.
% Check false.
% Check 3 : bool. (* boom *)
% \end{coq}
% 
% This tells you that one can construct a boolean using true or false but not a number.
% Types tells you how your values are (in normal form, since (true || false) is also of type bool, recall the example before).
% Hence it makes sense to consider only true and false when one inspects a bool.
% 
% \begin{coq}{name=negb}{}
% Definition negb (b : bool) : bool :=
%   match b with
%   | true => false
%   | false => true
%   end.
% 
% Check negb.
% Check negb true.
% Check negb (negb true).
% Check negb 3. (* boom *)
% 
% Eval compute in negb true.
% Eval compute in negb false.
% \end{coq}
% We see the function type (arrow) and how typing works in this simple case.
% Also that functions compute in \Coq{}.
% Sugar:
% 
% \begin{coq}{name=negb}{}
% Definition another_negb (b : bool) : bool :=
%   if b then false else true.
% Definition yet_another_negb :=
%   (fun b : bool =>
%       if b then false else true).
% Definition andb (b1 : bool) (b2 : bool) :=
%   if b1 then b2 else false.
% Notation "x && y" := (andb x y).
% Eval compute in true && false.
% Eval compute in true && true.
% \end{coq}
% 
% \subsection{Polymorphic containers and binding in match}
% 
% This is not the syntax used in ssr I guess.
% 
% \begin{coq}{name=option}{}
%  Inductive option (A : Type) : Type :=
%  | None
%  | Some (a : A).
% Check option.
% Check option bool : Type.
% Check Some true. (* Implicit argument *)
% \end{coq}
% 
% Talk about implicit arguments here.
% 
% \begin{coq}{name=implicits}{}
% About Some.
% (* The @ locally disables the implicit arguments *)
% Check @Some bool true.
% Check @Some _ true.
% \end{coq}
% 
% Inspecting a container
% 
% \begin{coq}{name=matchopt}{}
% Definition is_empty A (box : option A) : bool :=
%   match box with
%   | None => true
%   | Some _ => false  (* Here _ means discard the little a *)
%   end.
% Eval compute in is_empty None.
% Eval compute in is_empty (Some true).
% (* Note: the function is polymorphic! *)
% Eval compute in is_empty (Some 4).
% \end{coq}
% 
% Two words about polymorphism.
% 
% Now binding in a match.
% 
% \begin{coq}{name=matchopt2}{}
% Definition get_default A (box: option A) (a : A) : A :=
%   match box with
%   | None => a
%   | Some x => x  (* this x is a name on the left bound to the contents *)
%   end.
% 
% Eval compute in get_default None 3.
% Eval compute in get_default (Some 4) 3.
% \end{coq}
% 
% More containers
% 
% \begin{coq}{name=pair}{}
%  Inductive prod (A B : Type) : Type :=
%  | pair (a : A) (b : B).
% 
%  Notation "A * B" := (prod A B).
%  Notation "( a , b )" := (pair a b).
% 
% Check (true, Some false).
% 
% Definition fst A B (p : A * B) :=
%   match p with
%   | ( x , _ ) => x
%   end.
% 
% Eval compute in fst (true, None).
% 
% Definition snd A B (p : A * B) :=
%   match p with (_, y) => y end.
% \end{coq}
% 
% \subsection{Recursive data}
% 
% Nat, with a special syntactic sugar
% 
% \begin{coq}{name=nat}{}
%    Inductive nat : Type :=
%    | O
%    | S (n : nat).
% 
% Check S (S O).
% Check 2.
% Check 1.
% \end{coq}
% 
% Recursive functions
% 
% \begin{coq}{name=plus}{}
% Fixpoint plus (n : nat) (m : nat) : nat :=
%   match n with
%   | O => m
%   | S w => S (plus w m)
%   end.
% Infix "+" := plus.
% 
% Check 2 + 3.
% Eval compute in 2 + 3.
% \end{coq}
% 
% execution step by step
% 
% \begin{coq}{name=execplus}{}
%    S (S 0) + 3
%    S ((S O) + 3)
%    S (S (O + 3))
%    S (S 3)
%    5
% \end{coq}
% 
% Here I was also showing
% 
% \begin{coq}{name=plusrec}{}
% Fixpoint fast_plus (n : nat) (m : nat) : nat :=
%   match n with
%   | O => m
%   | S w => fast_plus w (S m)
%   end.
% 
%     S (S O) + 3
%     S O + 4
%     O + 5
%     5
% \end{coq}
% 
% and making the point that reasoning about these two plus is not equally easy (short parenthesis on symbolic computation).
% 
% \begin{coq}{name=plusrec}{}
% Eval simpl in
%   (fun n => fast_plus (S n) 3).  (* no progress *)
% Eval simpl in
%   (fun n => plus (S n) 3).  (* some output already, we can prove that it is not 0 *)
% \end{coq}
% 
% Lists
% 
% \begin{coq}{name=list}{}
% Inductive list (A : Type) : Type :=
% | nil
% | cons (x : A) (xs : list A).
% 
% Infix "::" := cons.
% Arguments nil {A}.
% Arguments cons {A} x xs.
% 
% (* The type of lists imposes all the elements to
%     be in the same type! *)
% Check true :: false :: nil.
% Fail Check 1 :: false :: nil.
% 
% (* A non recursive function on lists *)
% Definition tl A (l : list A) : list A :=
%   match l with
%   | nil => nil
%   | _ :: xs => xs
%   end.
% 
% Eval compute in tl (6 :: 99 :: nil).
% 
% (* The most popular function on lists *)
% Fixpoint len A (l : list A) : nat :=
%   match l with
%   | nil => O
%   | x :: xs => 1 + (len xs)
%   end.
% 
% Eval compute in len (1 :: 2 :: 3 :: nil).
% Fixpoint split A B (l : list (A * B)) : list A * list B :=
%   match l with
%   | nil => (nil, nil)
%   | (x,y) :: rest =>
%       let xs_ys := split rest in
%       (x :: fst xs_ys, y :: snd xs_ys)
%   end.
% 
% Eval compute in
%   split ((1,2) :: (3,4) :: nil).
% 
% Fixpoint zip A B (la : list A) (lb : list B) : list (A * B) :=
%   match la, lb with
%   | nil, nil => nil
%   | x::xs, y::ys => (x,y) :: zip xs ys
%   | _, _ => nil
%   end.
% 
% Eval compute in
%   zip (1 :: 2 :: nil) (true :: false :: nil).
% 
% Eval compute in
%   let xs_ys := split ((1,2) :: (3,4) :: nil) in
%   zip (fst xs_ys) (snd xs_ys).
% \end{coq}
% 
% \subsection{termination}
% 
% Here we say how termination is checked, which are the alternative when the
% heuristic fails (not very relevant for mathcomp I guess) and relate that to
% logical inconsistency (maybe too early here, needs curry howard).
% 
% \begin{coq}{name=paradoxes}{}
% Fail
% Fixpoint wrong A (l : list A) {struct l} :=
%   match l with
%   | nil => 0
%   | x :: xs => 1 + wrong (x :: nil)
%   end.
% 
% Fixpoint loop (n : nat) : False := loop n.
% 
% Check loop 3.
% Fail Timeout 2 Eval compute in loop 3.
% \end{coq}
% 
% Also data must be checked.
% 
% \begin{coq}{name=paradoxes2}{}
% Inductive non_positive : Type :=
% | Call (f : non_positive -> False)
% 
% Definition self (t : non_positive) : False :=
%   match t with
%   | Call f => f t
%   end.
% 
% Definition loop2 : False := self (Call self).
% 
% Fail Timeout 2 Eval compute in loop2.
% \end{coq}
% 
% \subsection{HO programming}
% 
% A function can be abstracted over another
%    function.  It is a useful mechanism to write
%    code that can be reused, especially in the context
%    of polymorphic containers.
% 
% \begin{coq}{name=map}{}
% Fixpoint map A B (f : A -> B) (l : list A) : list B :=
%   match l with
%   | nil => nil
%   | x :: xs => f x :: map f xs
%   end.
% 
% Eval compute in
%   map (fun x => x + 2) (3 :: 4 :: 7 :: nil).
% Eval compute in
%   map negb (true :: false :: nil).
% 
% (* fold f (x1 :: x2 :: .. xn :: nil) a
%      =
%             (f xn (.. (f x2 (f x1 a))))
% *)
% Fixpoint fold A B (f : B -> A -> A) (l : list B) (a : A) : A :=
%   match l with
%   | nil => a
%   | x :: xs => fold f xs (f x a)
%   end.
% 
% (* what does this do? *)
% Eval compute in fold cons (1 :: 2 :: 3 :: nil) nil.
% \end{coq}
% 
% Here one could use a section for A B and talk about all that.

% \section{old contents (before Enrico's tutorial)}
% 
% Do use \C{About} for informations (not \C{Check}).
% \begin{coq}{name=beta}{}
% Eval beta in (fun x => x + x) 3. (* 3 + 3 : nat *)
% Definition f := fun x : nat => x + x.
% Definition f (x : nat) := x + x.
% About f : nat -> nat.
% \end{coq}
% 
% TODO: "beta" alone is not a reduction tactic, but we could add it.
% 
% maybe also talk about delta here and make example of f.
% 
% \subsection{Inductive data, case analysis and recursion}
% bool, nat.
% 
% \begin{coq}{name=ind-data}{}
% Inductive bool : Type := true | false.
% Inductive nat :Type := O | S of nat.
% Check true : bool : Type. (* on a side note .. : Type : Type *)
% Check (S (S O)). (* 2 : nat *)
% \end{coq}
% 
% 
% 
% 
% match, fix, termination.
% 
% \begin{coq}{name=bool-conn}{}
% Definition andb := ...
% Fixpoint addn := ..
% Fixpoint eq_nat
% Fixpoint leq
% \end{coq}
% 
% discuss example of a real computation, not just beta.
% 
% \begin{coq}{name=compute}{}
% Compute (addn 3 4)
% \end{coq}
% 
% now simple notation come in to play
% 
% \begin{coq}{name=notation-infix}{}
% Infix "+" := addn.
% \end{coq}
% 
% \subsection{Polymorphism and HO programming}
% option, seq, pairs.
% 
% \begin{coq}{name=option}{}
% Inductive option A := None | Some of A.
% Check option. (* Type -> Type *)
% Check Some. (* : forall A : Type, A -> option A *)
% Fixpoint map A B (f : A -> B) := ...
% Fixpoint eq_seq A (eq_A : A -> A -> bool) l := ...
% \end{coq}
% 
% polymorphism as in F
% 
% may be also examples of polymorphism that can be defined in pure
% $\lambda$-calculus (identity, argument swapping).
% 
% \section{programming in \Coq{}}
% this contains real programs, and is the excuse to talk about:
% 
% \subsection{Sections}
% and Implicit Type, to factor the type parameter of containers like
% sequences.  Write more stupid programs on seq.
% 
% \begin{coq}{name=seq}{}
% Section Seq.
% Variable A : Type.
% Variable x0 : A.
% Implicit Type l : seq A.
% ...
% Fixpoint fold f l := ...
% Fixpoint rev l := ...
% \end{coq}
% 
% 
% \subsection{Implicit arguments}
% to imitate polymorphism a-la ML, simplest example of type inference
% like \C{Some _ 3}.  Set implicit for inductive types/constructors too,
% and functions on them like the ones on seq we have seen before.
% 
% \begin{coq}{name=Arguments}{}
% Arguments seq {T}.
% Arguments nil {T}
% Arguments cons {T} x xs.
% About seq.
% Check cons 3 nil.
% (* we have notataions *)
% Check [:: 3, 4 ].
% Fixpoint size A l := ...
% \end{coq}
% 
% About is bad because it mention names that are not necessarily displayed.
% Maybe we should tell people to open the document and/or talk about Locate,
% Print.  Or else use Search (that does all that) but in an empty
% file, where no theorems pop up.
% 
% \subsection{Exercises (explained): arithmetic}
% by now we should have the infrastructure to write program on arithmetic
% 
% \begin{coq}{name=stuff}{}
% divn
% prime  (* an simpler version *)
% \end{coq}
% 
% from choice.v
% 
% \begin{coq}{name=smart}{}
% encode
% decode
% \end{coq}
