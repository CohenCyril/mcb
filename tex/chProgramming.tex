\Chapter{Computational definitions \\ The syntax of terms}{Defining concepts by writing programs}\label{ch:prog}

\textcolor{blue}{Find a more catchy title? The motivation is: how to define things:
objects, operations, (boolean) relations.}

We will take the point of view that mathematics can be understood as
the study of objects, operations on these objects, and abstractions.  
Children start learning mathematics by counting, where the objects are
numbers and the operations are enumerating and adding.  In fact
numbers are already the result of an abstraction process.

What are the objects, the operations, and the abstractions in a given
mathematical corpus is quite fluctuant.  The objects of group theory
may sometimes be viewed as operations in another context.  Nevertheless,
in this chapter, we describe how some objects are described with the intent
that they are {\em inert}, that is, they are meant to be
manipulated by operations.  We also show how operations are described.

We start by considering the expression
\[ 2 + 1 \]
We can read this expression as an object, but also as the result of an
operation on an object, or as the result of an operation on two
objects.  Let us first consider the operation of {\em adding one to
  natural number}.  This operation is written in the following manner.

\begin{coq}{name=exfun}{}
  fun n => n + 1
\end{coq}
To write such an operation, we can start from the expression {\tt 2 +
  1} and isolate the object in this expression that is considered a
variable component for the operation, here {\tt 2}, we then replace
this object with a symbolic name, here {\tt n}.  We then encapsulate
the expression {\tt n + 2} with the prefix {\tt fun n =>} to express
that the operation produces a certain result {\tt n + 1} when given an
input {\tt n}.

So we have an expression which represents the operation of adding 1.
Applying this operation to the object {\tt 2} will be written this
way:

\begin{coq}{name=exapp}{}
  (fun n => n + 1) 2
\end{coq}
From the point of view of mathematical syntax, this object {\tt
  fun n => n + 1} is unusual.  When defining an operation, we usually
rely on a sentence {\em consider the function \(f\) from {\(\mathbb{N}\)}
to {\(\mathbb{N}\)} which maps \(n\) to \(n + 1\)}.  This would also be
written without natural language as follows:

\[f : 
\begin{array}{ccc}
{\mathbb{N}} &\rightarrow& {\mathbb{N}}\\
n &\mapsto& n + 1
\end{array}\]

The main difference is that the usual mathematical practice includes
the step of giving a name, here \(f\) to the operation.

When using Coq and ssreflect, the step of giving a name can also be
performed, in the following manner:

\begin{coq}{name=exdef}{}
Definition f := fun x => x + 1
\end{coq}
An alternative syntax for exactly the same definition is as follows,
this alternative syntax is actually preferred.

\begin{coq}{name=exdef-pref}{}
Definition f x := x + 1.
\end{coq}
As was obvious in the mathematical formulation, operations are mainly
described by functions and mathematical practice is also to give
information about the domain and the codomain of functions at
definition time, as we did when writing
\({\mathbb{N}}\rightarrow{\mathbb{N}}\).  In Coq syntax, we will write
the same information as follows:

\begin{coq}{name=exdef-type}{}
Definition f (x : nat) : nat := x + 1.
\end{coq}

Once a definition was made, the Coq system provides a command to
verify if an expression is well formed and obtain the type
information, concerning the domain and codomain of the function.
After executing one of the previous definition commands, we can check
the function {\tt f} in the following manner:
\begin{coq}{name=toto}{}
\end{coq}

Theoretical content:
\begin{itemize}
\item Functions with simple types ($\lambda$, $\rightarrow$): functions are the primitive concept
\item Inductive {\bf datas}
\item Programs by case analysis and recursion
\item Compute (beta, delta, iota) example of beta (that helps later on to explain a predicate for elim principles)
\item Polymorphic datatypes (introduce $\Pi$, and its \Coq{} notation
  \C{forall}, for quantification over datatypes only)
\item Everyone has a type : \C{0 : nat : Type : Type}, types avoid confusion
\end{itemize}
This is more or less a standard introduction to (a flavor of)
functional programming, with two possible difficulties:
\begin{itemize}
\item Be precise but not too technical (e.g. on inductive types)
\item Find a line of speech which does not bore/discourage
  mathematicians.
\item Somehow the syntax of (this fragment of the) terms should made
  be clear and precise.
% \item types depending on terms (matrix x m)
\end{itemize}


\begin{itemize}
\item Use monomorphic instances/compatible versions of the notations
  that will later be generalized using canonical structures;
\item For instance the infix \C{==} is the comparison on \C{nat}
\item Further examples: \C{\sum_(i <- l) F i}, \C{\sum_(a <= b <) F i}
in order to illustrate \C{foldr}.
\end{itemize}
\Coq{} commands and features:
\begin{itemize}
\item Implicit arguments (only to go from system F to ML), \C{@}
\item Sections and its discharging, implicit types
\end{itemize}


\Coq{} types introduced:
\begin{itemize}
\item \C{bool, nat, seq, option, prod}
\end{itemize}

Programs presented in detailed examples/exercises:
\begin{itemize}
\item Elementary programs on \C{option}: \C{odflt, obind,}\dots
\item Elementary programs on \C{seq} (without the \C{eqType}):
  \C{size, map, iota,...}
\item Comparison functions on \C{bool, nat}
\item Comparison functions on containers, taking the comparison
  function on the type of stored elements in argument (mind the
  higher-order)
\item Boolean connectives, arithmetic operations on \C{nat}
\item Do not forget to mention \C{if .. then .. else}
\item Euclidean division, computation of prime factors, examples from
  elementary number theory
\item Examples of G{\"o}del-style encoding from the {\tt choice.v} library.
\item Examples/exercises about extended gcd (egcdn), which mix lists
  and arithmetic.
\end{itemize}
If possible give a few context to the exercises, in order not to bore
the reader not familiar with programming. For instance do not say that
you encode sequences of nats in nats but give a few hints about the
use of G{\"o}del encoding.

Examples and exercises can be executed in an empty context, or
libraries can be required for the purpose of (re)using and combine existing
programs (non proofs here).

The current contents are organized like the tutorial at ITP15 I gave (Enrico).
It was on standard Coq and was intended not to be difficult class ;-)
It is a possible plan, no strong opinions.

\section*{Things needed by chapter 2}
\begin{itemize}
\item type annotations on arguments of lemmas/definitions can be omitted
\item if then else
\item all boolean connectives: \C{orb andb negb implb xorb}
\item recursive programs: \C{addn muln subn leq eqn expn dvdn}
\item notations with associativity: \C{+ * - == != .+1 < <= \%| \~\~}
\end{itemize}


\section{Functional programming in a nutshell}
Only intuitions here.

For a mathematician this is perfectly natural, the main problem is the syntax.  E.g.
$$f(x) = x * 2\qquad\qquad f(7)$$
here we define a function named f that doubles its input.  Then we denote f(7) the value of f
when the input is 7. The novelty is that:
\begin{enumerate}
\item functions are anonymous, and the names. \verb+(fun x => x * 2)+ is the function that
	doubles.  We can name it: \verb+Definition f := fun x => x * 2.+.  We don't need to
	name a function in order to use it in an expression. (there is something like
	\verb+x |-> x * 2+, but this is always attached to a name somehow).
\item function application is \verb+(f 7)+.
\end{enumerate}

For a computer scientist used to imperative languages, these are the main weird points:
\begin{enumerate}
\item there is no return statement, AKA expressions are already programs.  e.g.
	4 is a program, and 2+2 as well.  Programs then evaluate like a mathematical expression
	can be simplified
\begin{verbatim}
        if (false || true) then 2 + 2 else 7
        if true then 2 + 2 else 7
        2 + 2
        4
\end{verbatim}
also
\begin{verbatim}
        2 + (if 7 == 2 then 4 else 2)
        2 + (if false then 4 else 2)
        2 + 2
        4
\end{verbatim}
\item programs are really first class data (HO programming, not reasonably popular even outside
	the functional world). E.g.
    This program takes in input a function f and uses it twice
\begin{verbatim}
      (fun f => f 3 + f 4)
\end{verbatim}
hence this is a valid program computing 14
\begin{verbatim}
      (fun f => f 3 + f 4) (fun x => x + x)
\end{verbatim}
\end{enumerate}


\subsection{Build and destruct simple data}
Simplest data is bool.

\begin{coq}{name=bool}{}
Inductive bool : Type := true | false.
Check bool : Type.
Check true : bool.
Check false.
Check 3 : bool. (* boom *)
\end{coq}

This tells you that one can construct a boolean using true or false but not a number.
Types tells you how your values are (in normal form, since (true || false) is also of type bool, recall the example before).
Hence it makes sense to consider only true and false when one inspects a bool.

\begin{coq}{name=negb}{}
Definition negb (b : bool) : bool :=
  match b with
  | true => false
  | false => true
  end.

Check negb.
Check negb true.
Check negb (negb true).
Check negb 3. (* boom *)

Eval compute in negb true.
Eval compute in negb false.
\end{coq}
We see the function type (arrow) and how typing works in this simple case.
Also that functions compute in Coq.
Sugar:

\begin{coq}{name=negb}{}
Definition another_negb (b : bool) : bool :=
  if b then false else true.
Definition yet_another_negb :=
  (fun b : bool =>
      if b then false else true).
Definition andb (b1 : bool) (b2 : bool) :=
  if b1 then b2 else false.
Notation "x && y" := (andb x y).
Eval compute in true && false.
Eval compute in true && true.
\end{coq}

\subsection{Polymorphic containers and binding in match}

This is not the syntax used in ssr I guess.

\begin{coq}{name=option}{}
 Inductive option (A : Type) : Type :=
 | None
 | Some (a : A).
Check option.
Check option bool : Type.
Check Some true. (* Implicit argument *)
\end{coq}

Talk about implicit arguments here.

\begin{coq}{name=implicits}{}
About Some.
(* The @ locally disables the implicit arguments *)
Check @Some bool true.
Check @Some _ true.
\end{coq}

Inspecting a container

\begin{coq}{name=matchopt}{}
Definition is_empty A (box : option A) : bool :=
  match box with
  | None => true
  | Some _ => false  (* Here _ means discard the little a *)
  end.
Eval compute in is_empty None.
Eval compute in is_empty (Some true).
(* Note: the function is polymorphic! *)
Eval compute in is_empty (Some 4).
\end{coq}

Two words about polymorphism.

Now binding in a match.

\begin{coq}{name=matchopt2}{}
Definition get_default A (box: option A) (a : A) : A :=
  match box with
  | None => a
  | Some x => x  (* this x is a name on the left bound to the contents *)
  end.

Eval compute in get_default None 3.
Eval compute in get_default (Some 4) 3.
\end{coq}

More containers

\begin{coq}{name=pair}{}
 Inductive prod (A B : Type) : Type :=
 | pair (a : A) (b : B).

 Notation "A * B" := (prod A B).
 Notation "( a , b )" := (pair a b).

Check (true, Some false).

Definition fst A B (p : A * B) :=
  match p with
  | ( x , _ ) => x
  end.

Eval compute in fst (true, None).

Definition snd A B (p : A * B) :=
  match p with (_, y) => y end.
\end{coq}

\subsection{Recursive data}

Nat, with a special syntactic sugar

\begin{coq}{name=nat}{}
   Inductive nat : Type :=
   | O
   | S (n : nat).

Check S (S O).
Check 2.
Check 1.
\end{coq}

Recursive functions

\begin{coq}{name=plus}{}
Fixpoint plus (n : nat) (m : nat) : nat :=
  match n with
  | O => m
  | S w => S (plus w m)
  end.
Infix "+" := plus.

Check 2 + 3.
Eval compute in 2 + 3.
\end{coq}

execution step by step

\begin{coq}{name=execplus}{}
   S (S 0) + 3
   S ((S O) + 3)
   S (S (O + 3))
   S (S 3)
   5
\end{coq}

Here I was also showing

\begin{coq}{name=plusrec}{}
Fixpoint fast_plus (n : nat) (m : nat) : nat :=
  match n with
  | O => m
  | S w => fast_plus w (S m)
  end.

    S (S O) + 3
    S O + 4
    O + 5
    5
\end{coq}

and making the point that reasoning about these two plus is not equally easy (short parenthesis on symbolic computation).

\begin{coq}{name=plusrec}{}
Eval simpl in
  (fun n => fast_plus (S n) 3).  (* no progress *)
Eval simpl in
  (fun n => plus (S n) 3).  (* some output already, we can prove that it is not 0 *)
\end{coq}

Lists

\begin{coq}{name=list}{}
Inductive list (A : Type) : Type :=
| nil
| cons (x : A) (xs : list A).

Infix "::" := cons.
Arguments nil {A}.
Arguments cons {A} x xs.

(* The type of lists imposes all the elements to
    be in the same type! *)
Check true :: false :: nil.
Fail Check 1 :: false :: nil.

(* A non recursive function on lists *)
Definition tl A (l : list A) : list A :=
  match l with
  | nil => nil
  | _ :: xs => xs
  end.

Eval compute in tl (6 :: 99 :: nil).

(* The most popular function on lists *)
Fixpoint len A (l : list A) : nat :=
  match l with
  | nil => O
  | x :: xs => 1 + (len xs)
  end.

Eval compute in len (1 :: 2 :: 3 :: nil).
Fixpoint split A B (l : list (A * B)) : list A * list B :=
  match l with
  | nil => (nil, nil)
  | (x,y) :: rest =>
      let xs_ys := split rest in
      (x :: fst xs_ys, y :: snd xs_ys)
  end.

Eval compute in
  split ((1,2) :: (3,4) :: nil).

Fixpoint zip A B (la : list A) (lb : list B) : list (A * B) :=
  match la, lb with
  | nil, nil => nil
  | x::xs, y::ys => (x,y) :: zip xs ys
  | _, _ => nil
  end.

Eval compute in
  zip (1 :: 2 :: nil) (true :: false :: nil).

Eval compute in
  let xs_ys := split ((1,2) :: (3,4) :: nil) in
  zip (fst xs_ys) (snd xs_ys).
\end{coq}

\subsection{termination}

Here we say how termination is checked, which are the alternative when the
heuristic fails (not very relevant for mathcomp I guess) and relate that to
logical inconsistency (maybe too early here, needs curry howard).

\begin{coq}{name=paradoxes}{}
Fail
Fixpoint wrong A (l : list A) {struct l} :=
  match l with
  | nil => 0
  | x :: xs => 1 + wrong (x :: nil)
  end.

Fixpoint loop (n : nat) : False := loop n.

Check loop 3.
Fail Timeout 2 Eval compute in loop 3.
\end{coq}

Also data must be checked.

\begin{coq}{name=paradoxes2}{}
Inductive non_positive : Type :=
| Call (f : non_positive -> False)

Definition self (t : non_positive) : False :=
  match t with
  | Call f => f t
  end.

Definition loop2 : False := self (Call self).

Fail Timeout 2 Eval compute in loop2.
\end{coq}

\subsection{HO programming}

A function can be abstracted over another
   function.  It is a useful mechanism to write
   code that can be reused, especially in the context
   of polymorphic containers.

\begin{coq}{name=map}{}
Fixpoint map A B (f : A -> B) (l : list A) : list B :=
  match l with
  | nil => nil
  | x :: xs => f x :: map f xs
  end.

Eval compute in
  map (fun x => x + 2) (3 :: 4 :: 7 :: nil).
Eval compute in
  map negb (true :: false :: nil).

(* fold f (x1 :: x2 :: .. xn :: nil) a
     =
            (f xn (.. (f x2 (f x1 a))))
*)
Fixpoint fold A B (f : B -> A -> A) (l : list B) (a : A) : A :=
  match l with
  | nil => a
  | x :: xs => fold f xs (f x a)
  end.

(* what does this do? *)
Eval compute in fold cons (1 :: 2 :: 3 :: nil) nil.
\end{coq}

Here one could use a section for A B and talk about all that.

\section{old contents (before Enrico's tutorial)}

Do use \C{About} for informations (not \C{Check}).
\begin{coq}{name=beta}{}
Eval beta in (fun x => x + x) 3. (* 3 + 3 : nat *)
Definition f := fun x : nat => x + x.
Definition f (x : nat) := x + x.
About f : nat -> nat.
\end{coq}

TODO: "beta" alone is not a reduction tactic, but we could add it.

maybe also talk about delta here and make example of f.

\subsection{Inductive data, case analysis and recursion}
bool, nat.

\begin{coq}{name=ind-data}{}
Inductive bool : Type := true | false.
Inductive nat :Type := O | S of nat.
Check true : bool : Type. (* on a side note .. : Type : Type *)
Check (S (S O)). (* 2 : nat *)
\end{coq}




match, fix, termination.

\begin{coq}{name=bool-conn}{}
Definition andb := ...
Fixpoint addn := ..
Fixpoint eq_nat
Fixpoint leq
\end{coq}

discuss example of a real computation, not just beta.

\begin{coq}{name=compute}{}
Compute (addn 3 4)
\end{coq}

now simple notation come in to play

\begin{coq}{name=notation-infix}{}
Infix "+" := addn.
\end{coq}

\subsection{Polymorphism and HO programming}
option, seq, pairs.

\begin{coq}{name=option}{}
Inductive option A := None | Some of A.
Check option. (* Type -> Type *)
Check Some. (* : forall A : Type, A -> option A *)
Fixpoint map A B (f : A -> B) := ...
Fixpoint eq_seq A (eq_A : A -> A -> bool) l := ...
\end{coq}

polymorphism as in F

may be also examples of polymorphisms that can be defined in pure
$\lambda$-calculus (identity, argument swaping).

\section{programming in Coq}
this contains real programs, and is the excuse to talk about:

\subsection{Sections}
and Implicit Type, to factor the type parameter of containers like
sequences.  Write more stupid programs on seq.

\begin{coq}{name=seq}{}
Section Seq.
Variable A : Type.
Variable x0 : A.
Implicit Type l : seq A.
...
Fixpoint fold f l := ...
Fixpoint rev l := ...
\end{coq}


\subsection{Implicit arguments}
to imitate polymorphism a-la ML, simplest example of type inference
like \C{Some _ 3}.  Set implicit for inductive types/constructors too,
and functions on them like the ones on seq we have seen before.

\begin{coq}{name=Arguments}{}
Arguments seq {T}.
Arguments nil {T}
Arguments cons {T} x xs.
About seq.
Check cons 3 nil.
(* we have notataions *)
Check [:: 3, 4 ].
Fixpoint size A l := ...
\end{coq}

About is bad because it mention names that are not necessarily displayed.
Maybe we should tell people to open the document and/or talk about Locate,
Print.  Or else use Search (that does all that) but in an empty
file, where no theorems pop up.

\subsection{Exercises (explained): arithmetic}
by now we should have the infrastructure to write program on arithmetic

\begin{coq}{name=stuff}{}
divn
prime  (* an simpler version *)
\end{coq}

from choice.v

\begin{coq}{name=smart}{}
encode
decode
\end{coq}
