\Chapter{Computational definitions}{ Defining concepts by writing programs}\label{ch:prog}

TODO: uniform terminology (a function returns,produces, computes... patter matching,case analysis...program, function, operation...computation, evaluation...data type, inductive type); I mean, we can say we use them interchangeably... but the quotienting must be explicit since the reader may not know it (eg some of it is historical, some justified by curry howard (fwd reference)).  Also "coq session" is something that I would remove.

TODO: in the text I did sneak in some ``principles'' and some were already there.  eg exhaustiveness of pattern matching, totality of functions, injectivity of constructors, uniqueness of constructors/types.  We may want to put them in a more visible format, like a mantra like box.  The mathematician may not see these are the pillars of the logic.

TODO: add typing error and non-well-founded recursion error.

TODO: implicit arguments, mention curly braces

%\textcolor{blue}{Find a more catchy title? The motivation is: how to define things: objects, operations, (boolean) relations.}

We will take the point of view that mathematics can be understood as
the study of objects, operations on these objects, and abstractions.  
Children start learning mathematics by counting, where the objects are
numbers and the operations are enumerating and adding.  In fact
numbers are already the result of an abstraction process.

What are the objects, the operations, and the abstractions in a given
mathematical corpus is quite fluctuant.  The objects of group theory
may sometimes be viewed as operations in another context.  Nevertheless,
in this chapter, we describe how some objects are described with the intent
that they are {\em inert}, that is, they are meant to be
manipulated by operations.  We also show how operations are described.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Functions}
In this section, we expect readers to get acquainted with the notion
of function and the associated syntax.  We rely on natural
numbers and the addition operation, noted with the \C{+} symbol.
Both concepts will only be described fully a few pages later.

We start by considering the expression
\[ 2 + 1 \]
We can read this expression as an object, but also as the result of an
operation on an object, or as the result of an operation on two
objects.  Let us first consider the operation of {\em adding one to
a natural number}.  This operation is written in the following manner.

\begin{coq}{name=exfun}{}
  fun n => n + 1
\end{coq}
To write such an operation, we can start from the expression \C{(2 + 1)}
and isolate the object in this expression that is considered a
variable component for the operation, here \C{2}, we then replace
this object with a symbolic name, here {\tt n}.  We then encapsulate
the expression \C{(n + 2)} with the prefix ``\C{fun n =>}'' to relate
the result produced by the operation to the input \C{n}.  We commonly
say that ``\C{fun n =>}'' \emph{binds} the variable \C{n} in the expression
\C{n + 2}.

So we have an expression which represents the operation of adding 1.
Applying this operation to the object \C{2} will be written this
way:

\begin{coq}{name=exapp}{}
  (fun n => n + 1) 2
\end{coq}
From the point of view of mathematical syntax, there are two unusual 
things in this line.  First, applying a function to an argument is simply
by writing the function on left of the argument, {\em not necessarily
with parentheses around the argument}; we will come back to this later.
Second, this object \C{(fun n => n + 1)} is unusual.  
When defining an operation, we usually
rely on a sentence {\em consider the function \(f\) from {\(\mathbb{N}\)}
to {\(\mathbb{N}\)} which maps \(n\) to \(n + 1\)}.  This would also be
written without natural language as follows:

\begin{equation}\label{equation:f}
f : 
\begin{array}{ccc}
{\mathbb{N}} &\rightarrow& {\mathbb{N}}\\
n &\mapsto& n + 1
\end{array}
\end{equation}

The main difference is that the usual mathematical practice includes
the step of giving a name, here \(f\) to the operation.

When using Coq, the step of giving a name can also be
performed, in the following manner:

\begin{coq}{name=exdef}{}
Definition f := fun x => x + 1.
\end{coq}
\index[vernac]{\C{Definition}}
An alternative syntax for exactly the same definition is as follows,
this alternative syntax is actually preferred.

\begin{coq}{name=exdef-pref}{}
Definition f x := x + 1.
\end{coq}
As was obvious in the mathematical formulation, operations are mainly
described by functions and mathematical practice is also to give
information about the domain and the codomain of functions at
definition time, as we did when writing
\({\mathbb{N}}\rightarrow{\mathbb{N}}\).  In \Coq{} syntax, we will write
the same information as follows, because \C{nat} is the name used in
\Coq{} to represent \(\mathbb{N}\):

\begin{coq}{name=exdef-type}{}
Definition f (x : nat) : nat := x + 1.
\end{coq}
In this description, \C{nat} is called a {\em type}.  Types describe
collections of objects that can be treated in a uniform way.

Once a definition was made, the \Coq{} system provides a command to
describe the relevant information about the constant that is defined:

\begin{coq}{name=about_f}{width=5.5cm,title=Gathering information on f}
About f.
$~$
\end{coq}
\coqrun{name=about_f_run}{about_f}
\begin{coqout}{run=about_f_run}{title=Response,width=6.5cm}
f : nat -> nat
Argument scope is [nat_scope] ...
\end{coqout}
\index[vernac]{\C{About}}
This response confirms that \C{f} is a function from
\({\mathbb{N}}\) to \({\mathbb{N}}\).
We also learn that the \Coq{} system will pay attention to
arguments of \C{f} in such a way that overloaded notations
will be interpreted as notation for natural numbers.
\marginnote{maybe place a footnote here to point to another paragraph
about overloaded notations.  To  be discussed.}

We can be more inquisitive in our requests for information about
\C{f}, we can also require to know what is the value.  This is done in
the following manner:

\begin{coq}{name=print_f}{width=6cm,title=A function's value}
Print f.
$~$
\end{coq}
\coqrun{name=print_f_run}{print_f}
\begin{coqout}{run=print_f_run}{title=Response,width=6cm}
f = fun x : nat => x + 1
  : nat -> nat
\end{coqout}
\index[vernac]{\C{Print}}

We see in this example that {\em type information} is an important
feature of the language.  Type information is given twice in the
result of the \C{Print} command, once in the fragment ``\C{fun x : nat
  =>}'' and once in the second line, behind the colon ``\C{:}''.  The first
time, what we get is that the input of the function is expected to be
a value of type \C{nat}.  The second time, what we get is that the
type of \C{f} itself is the function type \C{nat -> nat}.  In fact,
the colon character (when surrounded by spaces) will always be used to
give type information.  Remark the similarity between the output of \C{Print}
and the mathematical notation in \eqref{equation:f}.

The function \C{f} operates on natural numbers, of type \C{nat}, but
we can also define functions that operate on functions.  For instance,
the following definition introduces a function that takes a function
from \C{nat} to \C{nat} and produces a new function from \C{nat} to
\C{nat}.

\begin{coq}{name=repeat_twice_def}{}
Definition repeat_twice (g : nat -> nat) : nat -> nat :=
  fun x => g (g x).
\end{coq}
Reading the first line of this statement, we see that a new object is
being defined, called \C{repeat_twice}.  We also see that this object
is a function the argument of which is a function of
type \C{nat -> nat}.  For later reference in the definition of
\C{repeat_twice}, the argument is given the name \C{g}.  Finally
we see that the value produced by the function \C{repeat\_twice}
is itself a function from \C{nat} to \C{nat}.

Reading the second line of this statement, we see that the value
of \C{repeat_twice} when applied to one argument is a new
function, described using the ``\C{fun .. => ..}'' construct.  The
argument to that function is called \C{x}.  After the \C{=>} sign, we
find the ultimate value of this function.  This fragment of text, \C{g
(g x)}, also deserves some explanation.  This fragment describes the
application of function \C{g} to an expression \C{(g x)}.  In turn,
the fragment \C{(g x)} describes the application of function \C{g} to
\C{x}.  The lesson here is that the application of a function to an
argument is not systematically written using parentheses, as is
customary in mathematics, but it is usually only written by
juxtaposing the function (on the left) and the argument (on the
right).  Parentheses are only added when they are needed to resolve
ambiguity.  Also expressions written with several subexpressions side
by side should be read as if there were parentheses around the
subgroups on the left.  We will illustrate this in the next few
examples.

When we want to apply the function \C{repeat_twice} to the function
\C{f} and the number \C{2} and perform the computation, this can be
written as follows:

\begin{coq}{name=eval_repeat_twice_f_two}{width=7cm,title=Evaluating
    an expression}
Eval compute in (repeat_twice f 2).
\end{coq}
\coqrun{name=eval_run}{eval_repeat_twice_f_two}
\begin{coqout}{run=eval_f_run}{title=Response,width=5cm}
  = 4 : nat
\end{coqout}
\index[vernac]{\C{Eval compute}}
From the syntax point of view, we wrote three subexpressions only
separated by space.  By default, the parser understands this as
\C{((repeat_twice f) 2)}, so we actually have a first subexpression
which is \C{repeat_twice} applied to \C{f}.  According to the
definition of the first function, the value is an intermediate
function from \C{nat}
to \C{nat}, which is then applied to \C{2}.  The value of the
intermediate function is \C{(fun x => f (f x))}, so the result
expression is \C{(f (f 2))}.
Remembering the definition of \C{f}, this expression can also
be read as \C{((2 + 1) + 1)}.  Thus, after computation, the result is \C{4}.

\marginnote{it would be nice to have one more example here, or exercises.
To be discussed.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data: construction and destruction}
It is possible to define a datatype by giving in one declaration
the type, methods to build elements of this type, and methods to
use elements of the type while computing.  This approach is used
systematically in \Coq{} to define a variety of basic datatypes, among
which boolean values, natural numbers, pairs and sequences of values
are the most prominents examples.  We will study these examples in
turn.
\subsection{Boolean values}
The type \C{bool} of boolean values contains two values that can be
distinguished in computations.  The declaration of this type happens
in one of the first files to be automatically loaded when \Coq{} starts,
so booleans look like a built-in notion.  On the contrary they are a
notion defined as follows.

\begin{coq}{name=print_bool}{title=Declaration of bool}
Inductive bool := true | false
\end{coq}
\index[vernac]{\C{Inductive} (data type)}
\marginnote{I guess we should use Type, also for bool, and not even mention Set}
This declaration states explicitely that there are only two cases for
elements of type \C{bool}.  the first case is given by the constant
\C{true}, the second case by the constant \C{false}.  Thus, the
declaration of the type gives in an obvious manner the type, \C{bool},
and ways to build all its elements, \C{true}, and \C{false}.  All definitions
in Coq, like this one, which define a type by providing at the same time a type
name and the only ways to build elements of the type are called {\em inductive}
definitions.  The two objects \C{true} and \C{false} are called
\emph{constructors}.

In practice, this means that we can build a well-formed expression of
type \C{bool} by using either \C{true} or \C{false}.  \Coq{} provides a
command to check that an expression is well-formed.  We can use this
command here to illustrate a use of the constructors.

\begin{coq}{name=check_true}{width=6cm,title=Queries}
Check true.
\end{coq}
\coqrun{name=check_true_run}{check_true}
\begin{coqout}{run=check_true_run}{width=6cm,title=Response}
true : bool
\end{coqout}
\index[vernac]{\C{Check}}

To use boolean values in computations, we need a construct that makes
it possible to build different values depending on whether some
boolean input is \C{true} or \C{false}.  This construct is written
``\C{if .. then .. else}''.  An example follows:

\begin{coq}{name=if_example}{}
if true then 3 else 2
\end{coq}
\index[coq]{\C{if-then-else}}
More generally, we can define a function that takes a boolean value as
input and returns one of two possible natural numbers in the following
manner:

\begin{coq}{name=definef23}{}
Definition f23 b := if b then 2 else 3.
\end{coq}
\coqrun{name=definef23_run}{definef23}

As one expects, when \C{b} is \C{true} the expression
\C{f b} evaluates to \C{2}, while it evaluates to \C{3} otherwise.

\begin{coq}{name=eval_repeat_twice_f_two}{width=7cm,title=Evaluating f23}
Eval compute in (f23 true).
Eval compute in (f23 false).
\end{coq}
\coqrun{name=eval_run}{eval_repeat_twice_f_two}
\begin{coqout}{run=eval_f_run}{title=Response,width=5cm}
  = 2 : nat
  = 3 : nat
\end{coqout}

The \mcbMC{} library provides a collection of boolean operations that
mirror reasoning steps on truth value.  The functions are called
\C{negb}, \C{orb}, \C{andb} , \C{implyb}, respectively with notations
\C{\~\~},  \C{||}, \C{&&}, and \C{==>} (the last three operators are
infix, they appear between the arguments as in \C{b1 && b2}).
  In
particular, it should be
noted that the symbol \C{\~\~} uses two characters \C{\~}, but it should
not be confused with two iterations of the one-character symbol
\C{\~}.  In practice, readers become quickly accustomed to the
distinction between the two symbols.

For instance, the function \C{andb} is defined as follows in one of
the preamble files:

\begin{coq}{name=define_andb}{}
Definition andb b1 b2 := if b1 then b2 else false
\end{coq}
\index[coq]{\C{andb}}

% \subsubsection{TODO : A note on associativity for notations}

\subsection{natural numbers}
The description of natural numbers in the \Coq{} system is inspired from
the work of Peano at the beginning of the twentieth century.  The
basic idea is that any natural number is either 0 or the successor of
an existing natural number.  Moreover, the successor operation is
injective.  Peano also considers supplementary operations, like
addition and multiplication, but we shall see that the \Coq{} system
provides enough machinery so that these operations can be described as
defined functions on top of the basic tools.

The description of natural numbers as essentially generated by a
constant \C{O} (capital ``o'' letter, to represent $0$) and a function symbol \C{S} to represent 
the successor operation is given in the definition of the type
\C{nat}.

\begin{coq}{}{}
Inductive nat := O | S (n : nat)
\end{coq}
\index[coq]{\C{nat}}

This declaration states that the only ways to produce natural numbers
are by using the constant \C{O}, or by applying the function \C{S} to
an already existing natural number.  So \C{O} is a natural number,
\C{(S O)} is a
natural number, \C{(S (S O))}, and so on, and these are the only natural
numbers.  When interacting with Coq, we will often see decimal
notations, but these are only a parsing and display
facility provided to the user for readability.  So \C{O} is displayed
$0$, \C{(S O)} is displayed $1$, etc.  Users can also type decimal
numbers to describe values, but these are automatically translated into
terms built with \C{O} and \C{S}.

The \mcbMC{} library provides a few notations to make use of the
constructor \C{S} more intuitive to read.  In particular, if \C{x}
is a value of type \C{nat}, \C{x.+1} is another way to write \C{(S
x)}.  The ``\C{.+1}'' notation binds more strongly than function
application, so that this notation makes it possible to avoid some
needs for parentheses.
Similar notations are provided for up to 4 uses of the \C{S}
constructor.  This can be illustrated by the following dialog (where
we assume that \C{f} is a function of type \C{nat -> nat}).
  For instance, we can write the following
expression, when \C{f} is already defined with type \C{nat -> nat}.

\begin{coq}{name=f_plus_one}{width=5cm,title=Queries}
Check fun x => f x.+1.
Locate ".+4".
\end{coq}
\coqrun{name=f_plus_one_run}{f_plus_one}
\begin{coqout}{f_plus_one_run}{width=7cm,title=Response}
fun x => f x.+1 : nat -> nat
Notation "n.+4" := S (S (S (S n)))
\end{coqout}
\index[coq]{\C{.+1}}
\index[vernac]{\C{Locate}}

When writing functions that compute on natural numbers, we can
proceed by cases, as was done in the previous section for boolean
values.  Again, there are two cases, either the natural number used in
the computation is \C{O} or it is \C{n.+1} for
some \C{n}, but in the latter case, it is often useful to also be able
to use \C{n} for further computations.  The usual approach in this
case is to describe the two cases as patterns: if the data fits one of
the patterns, the computation proceeds with the corresponding
computation.  Here is an example:

\begin{coq}{name=pattern_on_nat}{}
match n with 0 => true | p.+1 => false end
\end{coq}
\index[coq]{\C{match-with-end}}
In this expression we describe a computation where some decision is
taken depending on the value of the number \C{n}.  The fragment 
``\C{0 => true}'' expresses that when \C{n} is \C{0}, the final value is
\C{true}.  In this expression, \C{0} is a pattern and the computation
checks whether \C{n} matches this pattern.  The fragment
``\C{p.+1 => false}''  expresses that when \C{n} is the successor of
some number \C{p} the final value is \C{false}.  In other words, when
\C{n} is the successor of somebody, then the returned value is
\C{false}.  The value \C{p} mentioned in this pattern is not known in
advance, it is actually computed at the moment the \C{n} is matched
against the pattern.  For instance, if \C{n} is \C{5}, then the value
computed for \C{p} is \C{4}.  In this particular instance, \C{p} is
not used, so that we can also write as follows:

\begin{coq}{name=pattern_on_nat}{}
match n with 0 => true | _.+1 => false end
\end{coq}
The symbol \C{_} is used to represent a pattern whose value will never be
used.

This pattern can also be written using an ``\C{if .. then .. else}'' like
syntax:

\begin{coq}{name=pattern_on_nat_0}{}
if n is 0 then true else false
\end{coq}
\index[coq]{\C{if-is-then-else}}

For an example where the pattern variable is actually used, we can
observe the function that returns the predecessor of a natural number
when it exists, or 0 otherwise.  This function already exists in the library,
but we could redefine it as follows:

\begin{coq}{name=pred}{}
Definition pred n := if n is u.+1 then u else n.
\end{coq}
Reading this function in detail, we see that the argument \C{n} is
matched with the pattern \C{u.+1}.  When this comparison
succeeds, the variable \C{u} receives the value of the immediate
subterm of \C{n} the computation proceeds by computing the expression
in the \C{then} branch of the \C{if} statement.  This branch contains
exactly \C{u}, so this is the result value.  When the comparison
fails, this means that \C{n} has the form \C{0}, the returned value is
\C{n}, or equivalently \C{0}.

Assume for instance that \C{n} is \C{2}, in other words \C{n} is the
successor of the successor of \C{O}, which we could also write
\C{0.+1.+1}.  When matching \C{0.+1.+1} against the pattern \C{u.+1}
the value of \C{u} is found to be \C{0.+1}, in other words \C{1}.

Remark that we did omit the type of the input \C{n}.  Being \C{n} scrutinized
as a natural number, i.e. matched against the \C{u.+1} pattern, \Coq{} fixes its
type to \C{nat}.  Indeed the \C{S} constructor belongs exclusively to the
\C{nat} inductive definition.

The pattern used in the \C{if} statement can be composed of
several nested levels of the \C{.+1} pattern.  For instance,
if we want to write a function
that returns \(n-5\) for every input larger than or equal to 5 and 0
for every input smaller than 5, we can write the following definition:

\begin{coq}{name=pred5}{}
Definition pred5 n :=
  if n is u.+1.+1.+1.+1.+1 then u else 0.
\end{coq}
On the other hand, if we want to describe a different computation for
three different cases and use variables in more than one case, we need
to revert to the ``\C{match .. with .. end}'' syntax.  Here is an
example:

\begin{coq}{name=awkward5}{}
Definition three_patterns n :=
  match n with
    u.+1.+1.+1.+1.+1 => u
  | v.+1 => v
  | 0 => n
  end.
\end{coq}
This function maps any number \(n\) larger than or equal to 5 to \(n-5\),
any number \(n \in \{1, \ldots, 4\}\) to \(n-1\), and \(0\) to \(0\).

The pattern matching construct ``\C{match .. with .. end}'' contains an
arbitrary large number of {\em pattern matching rules} of the form
``\emph{pattern}\C{ =>$~$}\emph{result}'' 
separated by the \C{|} symbol.  Optionally on can
prefix the fist pattern matching rule with \C{|}, in order to make each line
begin with \C{|}.

For the symbols that are allowed
in the pattern, they are essentially restricted to \C{O}, \C{S} and
variable names.  Thanks to notations, a pattern can also contains
occurrences of the notation ``\C{.+1}'' which represents \C{S}, and
decimal numbers, which represent the corresponding terms built with
\C{S} and \C{O}.  When a variable name occur, this variable can be
re-used in the result part.  When computing with a natural number, all
the pattern matching rules are tried successively against this number.
For instance, if the input is \C{2}, in other words \C{0.+1.+1}, the first
rule cannot match, because this would require that \C{0} matches
\C{u.+1.+1.+.1} and we know that \(0\) is not the successor of any
natural number, when it comes to the second rule \C{0.+1.+1} matches
\C{v.+1}, because the rightmost \C{.+1} in the value of \C{2} matches
the rightmost \C{.+1} part in the pattern and \C{0.+1} matches the \C{v} part
in the pattern.

A fundamental principle is enforced by \Coq{} on case analysis:
\emph{exhaustiveness}.  The patterns must cover all constructors of
the inductive type.  For example, the following definition is
rejected by Coq.

\begin{coq}{name=f_plus_one}{width=6cm,title=Non exhaustive case analysis}
Definition wrong (n : nat) :=
  match n with 0 => true end.
$~$
\end{coq}
\coqrun{name=f_plus_one_run}{f_plus_one}
\begin{coqout}{f_plus_one_run}{width=6cm,title=Response}
Error: Non exhaustive pattern
matching: no clause found for
pattern S _
\end{coqout}

We conclude the section by showing a syntactic facility to scrutinized
multiple values at the same time.

\begin{coq}{name=awkward5}{}
Definition same_bool b1 b2 :=
  match b1, b2 with
  | true, true => true
  | _, _ => false
  end.
\end{coq}

This is translated on the fly to

\begin{coq}{name=awkward5}{}
Definition same_bool b1 b2 :=
  match b1 with
  | true => match b2 with true => true | _ => false end
  | _ => false
  end.
\end{coq}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data: recursion}

With only pattern-matching, we do not cope well with the fact that the
type \C{nat} of natural numbers actually contains an infinity of
elements.  To really handle infinity, the \Coq{} system provides another
facility, known as {\em recursivity}.  The idea behind recursivity is
that we can define a function while supposing that it is already
defined for a subset of the type.  This adds a new element for which
the function is defined, and progressively this makes that the
function is defined for all elements of the type.

\subsection{Recursion for integers}

Many usual functions to deal with natural numbers are
defined recursively.  For instance, we can define addition in the
following manner:

\begin{coq}{name=redefine_add}{}
Fixpoint addn n m :=
  if n is p.+1 then (addn p m).+1 else m
\end{coq}
\index[vernac]{\C{Fixpoint}}
In this line, we learn that the keyword for defining a recursive
function is \C{Fixpoint}.  We see also that the function being
defined, here called \C{addn}, is used in the definition of the
function \C{addn} itself.  This text expresses that the value of
\C{(addn p.+1 m)} is
\C{(addn p m).+1} and that the value \C{(addn 0 m)} is \C{m}.
This first equality may
seem redundant, but there is progress when reading this equality from
left to right: an addition with \C{p.+1} as the left-hand side argument
is explained with the help of addition with \C{p} as the left-hand side
argument, and \C{p} is a smaller number than \C{p.+1}.  When considering the
expression \C{(addn 2 3)}, we can know the value by performing the following
computation:
\begin{tabbing}
\C{adfasdfasdfafafafafafaf}\=\kill
\C{(addn 2 3)} \> use the ``then'' branch, \C{p = 1}\\
\C{(addn 1 3).+1} \> use the ``then'' branch, \C{p = 0}\\
\C{(addn 0 3).+1.+1} \> use the ``else'' branch\\
\C{3.+1.+1}\> remember that \C{5 = 3.+1.+1}
\end{tabbing}
When the computation finishes, the symbol \C{addn} disappears.  In
this sense, the recursive definition is really a definition.  Remark that
what the \C{(addn n m)} program does is simply to count \C{n} times the
successor starting from \C{m}.  Fina

An alternative way of writing \C{addn} relies explicitly on
pattern-matching rules instead of relying on an \C{if} statement.
This can be written as follows:

\begin{coq}{name=add_redef}{}
Fixpoint addn n m :=
  match n with
  | 0 => m
  | p.+1 => (addn p m).+1
  end.
\end{coq}
\index[coq]{\C{addn}}
With this way of writing the recursive function, it becomes obvious that
pattern-matching rules describe equalities between two symbolic
expressions, but these equalities are always used from left to right during
computations.

When writing recursive functions, the \Coq{} systems imposes the
constraint that the described computation must be guaranteed to
terminate.  This guarantee relies on an analysis of the function's
description, to make sure that recursive calls always happen with a
given argument that decreases.  The most frequent technique to
establish this guarantee is that recursive calls happen on a variable
and this variable was introduced by a pattern in a pattern-matching
construct or in an ``\C{if .. is ..}'' statement, with the additional
constraint that the pattern-matching construct observes a variable
that was one of the function's inputs.

For instance, in the case of \C{addn}, the recursive call happens
with \C{p} as the first argument, \C{p} was introduced by the pattern \C{p.+1}
in the corresponding pattern-matching rule, the pattern-matching
construct was observing \C{n}, and \C{n} is the first argument of the
function \C{addn}.

% In function \C{add}, the first argument \C{n} is only used to
% repeat \C{n} times the operation of adding a \C{.+1} on the second
% argument.  This corresponds to the fact that the \C{p} is only used in
% the recursive call.  The programming language makes it possible to do
% more.  For instance, for a given function \(f\), we might want to add all
% the values \(f 0 + f 1 + \cdots + f n\).  This would be done in the
% following manner:
% 
% \begin{coq}{name=example_sum_f}{}
% Fixpoint sum_f (f : nat -> nat) (n : nat) :=
%   if n is p.+1 then add (f n) (sum_f p) else f 0.
% \end{coq}
% 
If addition tantamounts to repeating the operation of adding a \C{.+1}
to one of the arguments, subtraction tantamounts to repeating the
operation of fetching a subterm of the first argument.  This is also
easily expressed using pattern matching constructs.  Here again,
subtraction is already defined in the libraries, but we can play the game
of re-defining our own version.

\begin{coq}{name=sub}{}
Fixpoint subn m n :=
  match m, n with
  | p.+1, q.+1 => subn p q
  | _ , _ => m
  end.
\end{coq}
\index[coq]{\C{subn}}
From a mathematical point of view, this definition can be quite
unsettling.  The second pattern matching rule indicates that when
the second argument of the subtraction is \C{0}, then the result is
the first argument.  But it also covers the case where the second
argument is non-zero while the first argument is 0.  This phenomenon
is imposed by the fact that the function must be total (all functions
are total in the \Coq{} system) and the type \C{nat} does not contain any
element to represent negative numbers.  When the second argument is non-zero
and the first argument is zero, a value must still be returned and
{\em this value must be a natural number}.  In the long run, this
problem will be solved by introducing another type of numbers with
negative integers.

Recursive functions also make it possible to test data for
equality. We can for example write a function with two arguments of
type \C{nat}, that
returns \C{true} exactly when the two arguments are equal.

\begin{coq}{name=nat_eq_def}{}
Fixpoint eqn m n :=
  match m, n with
  | 0, 0 => true
  | p.+1, q.+1 => eqn p q
  | _, _ => false
  end.
\end{coq}
The last rule in the code of this function actually covers two cases :
\C{0, _.+1} and \C{_.+1, 0}.

For equality test functions, it is useful to add a more intuitive
notation.  For instance we can attach a notation to \C{eqn} in
the following manner:

\begin{coq}{name=notation_my_eq}{}
Notation "x == y" := (eqn x y) (at level 70, no associativity).
\end{coq}
This equality test function can then be used in other algorithms.  Now
that we have programmed this equality test function, we can verify
that the \Coq{} system really identifies various ways to write the same
natural number.

\begin{coq}{name=equalities}{width=6cm}
Eval compute in 0 == O.
Eval compute in 1 == S O.
Eval compute in 1 == 0.+1.
Eval compute in 2 == S O.
Eval compute in 2 == 1.+1.
Eval compute in 2 == add 1 0.+1
\end{coq}
\coqrun{name=equalities_run}{equalities}
\begin{coqout}{equalities_run}{width=6cm}
= true : bool
= true : bool
= true : bool
= false : bool
= true : bool
= true : bool
\end{coqout}
\marginnote{Is the use of O intended (instead of 0)?  To me this is not adding much to the picture.  Actually in an ideal system I'd like to write \C{Ind.. nat := 0 | (n:nat).+1}; The fact that we need an ``ident'' name for each constructor is incidental.  Given the influence of Coq Art on Coq, we may say that explicitly ;-)}

In this section, we introduced a variety of functions and notations
for operations on natural numbers.  In practice, these functions and
notations are already provided by the \mcbMC{} library.  In particular
it provides addition (named \C{addn}, infix notation \C{+}), 
multiplication
(\C{muln}, \C{*}), subtraction (\C{subn}, \C{-}), division (\C{divn},
\C{\%/}),  modulo (\C{modn}, \C{\%\%}), exponentiation (\C{expn}, \C{\^})
equality comparison (\C{eqn}, \C{==}), order
comparison (\C{leq}, \C{<=}) on natural numbers.  The trailing \C{n} in
the names is indeed to signal that these operations are on the \C{nat} data
type.\marginnote{Why not leqn?  Georges?}
The notation \C{n < m} is also provided to mean exactly \C{n.+1 <= m}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data: generic containers}

It is often the case that we wish to group several objects in a
sequence that can be manipulated as a single object.  For instance, we
might want to compute the sequence of all predecessors or all divisors
of a number.  We could define such datatype as follows.

\begin{coq}{name=list_def}{}
Inductive listn := niln | consn (hd : nat) (tl : listb).
\end{coq}

Such data type can hold zero or more natural numbers, for example

\begin{coq}{}{}
Check consn 1 (consn 2 niln).
Check consn true (consn false niln).
\end{coq}{}{}
\begin{coqout}{}{}
 consn 1 (consn 2 niln) : listn
 Error ...
\end{coqout}{}{}

As expected, it can't hold boolean values.  So if we need to
manipulate a list of booleans we have do define a similar data type.

\begin{coq}{name=list_def}{}
Inductive listb := nilb | consb (hd : bool) (tl : listb).
\end{coq}

It is clear that this approach is problematic.  First, every time we
write a function that manipulates a list we have to choose a priori
if such list holds numbers or booleans, even if such program does not
really use the objects hold by the list.
A concrete example is the function that computes the length of the list,
and in the current setting such function has to be written twice.
Worse, starting from the next chapter we will prove properties of programs,
and given the two size functions are ``different'' we are going to prove such
properties twice.

However it is clear that the two datatypes we just defined follow
a schema, as well as the two functions computing the length and the
theorems we may prove about them.  In other words one could write something
like the following, where $\alpha$ is a schematic variable.

\begin{coq}{name=list_def}{}
Inductive list := nil | cons (hd : $\alpha$) (tl : list).
\end{coq}

\noindent Even if this may look familiar jargon to some reader, we really want
this $\alpha$ to be a first class citizen, as well the type of lists carrying
any type of values and not appeal to some notion of schema that is intuitively
added on top of the \Coq{} language.  The reason being that we want to reason and
prove theorems about such data type and related programs inside the formal
language \Coq{} provides, and that we want the proofs of such theorems to be first
class citizen too (see for example Chapter~\ref{ch:sigmabool}).

Coq's language is powerful enough to fully characterize the generic 
list datatype without appealing to the intuitive, but external, notion of
schema.

\subsection{The (polymorphic) sequence datatype}

The \mcbMC{} library provides a generic datatype to hold
several objects of any type under the name \C{seq}.

\begin{coq}{name=list_def}{}
Inductive seq (A : Type) := nil | cons (hd : A) (tl : list A).
\end{coq}
This definition actually describes the type of lists as a {\em
  polymorphic type}.  This means that there is a different type
\C{(list A)} for each possible choice of a type \C{A}.  For example
\C{(list nat)} is the type of sequences of natural numbers, while
\C{(list bool)} is the type of sequences of booleans.
The type of the
function \C{cons} is devised specifically to describe how to produce a
new list of type \C{list A} by combining an element of \C{A} and an
existing list of type \C{list A}.  This also means that this data-type
does not allow users to construct lists where the first element would be
a boolean value and the second element would be a natural number.

In principle, all objects of the datatype definition have a type
argument.  Thus, \C{list} is a function of type \C{Type -> Type} and
\C{nil} is a function that takes a type \C{A} as argument and returns
an empty list of type \C{(list A)}.  The notation ``\C{.. -> ..}'' is not
well suited for this kind of situation and the type of \C{nil} is
rather written as follows:

\begin{coq}{name=type_of_nil}{}
  forall A : Type, seq A
\end{coq}
The same goes for the other constructor of list, named \C{cons}.  This
function actually takes three arguments: a type \C{A}, a value in this
type, and a value in the type \C{list A}.  The type of \C{cons} is
thus written as follows:

\begin{coq}{name=type_of_cons}{}
  forall A : Type, A -> seq A -> seq A
\end{coq}
This information can actually be obtained from the system by using the 
command \C{About}.

\begin{coq}{name=about_cons}{width=3cm,title=Query}
About cons.
$~$
$~$
$~$
\end{coq}
\coqrun{name=about_cons_run}{about_cons}
\begin{coqout}{about_cons_run}{width=9cm,title=Response}
cons : forall A: Type, A -> seq A -> seq A

Argument A is implicit and maximally inserted
Argument scopes are [type_scope _ seq_scope]
\end{coqout}
In practice, the \Coq{} system implements a mechanism to avoid that
people need to give the type argument to the \C{cons} function.  This is
the information meant by the message ``\C{Argument A is implicit and
  ..}''.  Every time users write \C{cons}, the system automatically
inserts an argument in place of \C{A}, so that this argument does not
need to be written (the argument is {\em implicit}).  It is then the
job of the \Coq{} system to guess what this argument is when looking at
the first explicit argument given to the function.  The same happens
to the type argument of \C{nil}.  In the end, this makes that user can
write the following expression.

\begin{coq}{name=check_list_2}{width=6cm,title=Query}
Check cons 2 nil.
\end{coq}
\begin{coqout}{check_list_2_run}{width=6cm,title=Response}
[:: 2] : seq nat
\end{coqout}
\coqrun{name=check_list_2_run}{check_list_2}
This example shows that the function \C{cons} is only applied
explicitly to two arguments (the two arguments effectively declared
for \C{cons} in the inductive type declaration).
The first argument, which is implicit,
has been guessed so that it matches the actually type of \C{2}.  For 
\C{nil} also, the argument has been guessed to match the constraints
that it is used in a place where a list of type \C{(list
nat)} is expected.  

This example, and the following ones, also show
that \Coq{} and the \mcbMC{} library provide
a collection of notations for lists.

\begin{coq}{name=check_list_2}{width=6cm,title=Query}
Check 1 :: 2 :: 3 :: nil.
Check fun l => 1 :: 2 :: 3 :: l.
$~$
\end{coq}
\begin{coqout}{check_list_2_run}{width=6cm,title=Response}
[:: 1; 2; 3] : seq nat
fun l => [:: 1, 2, 3 & l]
  : seq nat -> seq nat
\end{coqout}
\coqrun{name=check_list_2_run}{check_list_2}

In particular \Coq{} provides the infix notation \C{::} for
\C{cons}.  The \mcbMC{} library follows a general pattern for
n-ary constructors, in particular \C{[::} begins the repetition
of \C{::} and \C{]} ends it.  Elements are separated by \C{,} (comma)
but for the last one separated by \C{&}.
For example one
can write as \C{[&& true, false & true]} the boolean conjunction
of three terms.\footnote{For the sake of completeness, some n-ary notation use a
different, but more evocative, last separator.  For example one writes
\C{[|| b1, b2 | b3]} and \C{[==> b1, b2 => b3]}.}
For sequences that are \C{nil}-terminated, a very frequent case,
the \mcbMC{} library provides an additional notation where all elements are
separated by \C{;} (semi-colon) and the last element, \C{nil},
is omitted.

When programming with sequences, we can again use the  pattern matching
construct to express how data can be retrieved from a sequence.  For
instance, to retrieve the first element of a sequence of natural numbers
or 0 if the sequence does not contain any element, we can write the
following code:

\begin{coq}{name=first_element}{}
Definition first_element_or_0 (s : seq nat) :=
  match s with
  | nil => 0
  | cons a _ => a
  end.
\end{coq}
Using the notations for {\tt cons} and {\tt nil}, we can also write

\begin{coq}{name=first_element1}{}
Definition first_element_or_0 (s : seq nat) :=
  match s with
  | [::] => 0
  | a :: _ => a
  end.
\end{coq}
Using the \C{if} syntax, we can write:

\begin{coq}{name=first_element2}{}
Definition first_element_or_0 (s : seq nat) :=
  if s is a :: _ then a else 0.
\end{coq}
\subsection{Recursion for sequences}
Because the second argument of \C{cons} can also be a sequence, it is
possible to build sequences that are quite long, but always finite.
In this respect, the sequences are very similar to the natural
numbers.  Recursion is again the solution to cope with the arbitrary
length of sequences with functions that can be described concisely.

For instance, we can define a size function that counts the number of
elements in a sequence.

\begin{coq}{name=def_size}{}
Fixpoint size A (s : seq A) :=
  if s is _ :: s' then (size s').+1 else 0.
\end{coq}
\index[coq]{\C{size}}
During computation on a given sequence, this function will traverse
the whole list, adding 1 to the result for ever
\C{cons} pattern that is encountered.  It should be noted that in this
definition, the function \C{size} is described as a two argument
function, but the recursive call \C{(size s')} is done by providing
explicitly only one argument, \C{s'}.  This is because we started the
\Coq{} session with, among other commands, the command ``\C{Set Implicit
  Arguments}''.  According to this directive, the \Coq{} system makes
arguments of functions that can be guessed from the type of following
arguments automatically implicit.  This feature is effective directly
at definition time.

Another example of recursive function on lists is a function that constructs
a new list where all elements are values of a given function applied to
the elements of a list.  This function can be defined in this
manner.

\begin{coq}{name=def_map}{}
Fixpoint map A B (f : A -> B) s :=
  if s is e :: s' then f e :: map f s' else nil.
\end{coq}
\index[coq]{\C{map}}
With this function it is also interesting to understand how we can
improve the notations.  For instance, we will add a notation that
makes it more apparent that the result is {\em the sequence of all
expressions \(f(i)\) for \(i\) taken from another sequence}.

\begin{coq}{name=notation_map}{}
Notation "[ 'seq' E | i <- s ]" := (map (fun i => E) s).
\end{coq}
For instance, with this notation we write the computation of successors
for a given sequence of natural numbers as follows:

\begin{coq}{name=try_map_notation}{width=7.8cm,title=Query}
Eval compute in [seq i.+1 | i <- [:: 2; 3]].
\end{coq}
\begin{coqout}{try_map_notation_run}{width=4.3cm,title=Response}
= [:: 3; 4] : seq nat
\end{coqout}
\coqrun{name=try_map_notation_run}{try_map_notation}
In addition to the function \C{map} and the associated notation
we studied here, the \mcbMC{} library
provides a large collection of useful functions and notations to work on
sequences, as described in the header of the file \C{seq.v}.  For
instance \C{[seq i <- s | p]} filters the sequence \C{s} keeping only
the values selected by the boolean test \C{p}.
Another useful function for sequences is \C{cat} (with infix notation \C{++})
that is used to catenate two sequences together.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Section mechanism}
When several functions are designed to work on similar data, it is
useful to set a working environment where the common data is declared
only once.  Such a working environment is called a \C{Section}, and
the data that is local to this section is declared using \C{Variable}
commands.  A typical example happens when describing functions that
are polymorphic and rely in a uniform way on a given type and existing
functions in this type.

\begin{coq}{name=simple_monoid_structure}{}
Section iterators.

Variables (T : Type) (A : Type).
Variables (f : T -> A -> A).

Implicit Type x : T.

Fixpoint iter n op x :=
  if n is p.+1 then op (iter p op x) else x.

Fixpoint foldr a s :=
  if s is x :: xs then f x (foldr a xs) else a.

End iterators.
\end{coq}
\index[vernac]{\C{Section}}
\index[coq]{\C{foldr}}\index[coq]{\C{iter}}
The \C{Section} and \C{End} keyword delimit a scope in which
the variables \C{T}, \C{A} and \C{f} are available.  Such variables
are used in the definition of \C{iter} and \C{fold}.  When the section is
closed, such variable are abstracted.

\begin{coq}{}{width=3.5cm,title=Query}
About iter.
About foldr.
$~$
\end{coq}
\begin{coqout}{close_section_run}{title=Response, width=8.5cm}
iter : forall T : Type, nat -> (T -> T) -> T -> T
foldr :
  forall T A : Type, (T -> A -> A) -> A -> seq T -> A
\end{coqout}

Variables are abstracted in their order of declaration, see \C{T} and \C{A}
in the type of \C{foldr} and unused ones are omitted, for example \C{iter}
is not abstracted on \C{f}.

The \C{Implicit Type} annotation tells \Coq{} that, whenever we name
an input \C{x} its type is supposed to be \C{T}.

Once the section is closed, \C{iter} and \C{foldr} behave exactly as
if they were defined as follows:

\begin{coq}{}{}
Fixpoint iter T n op (x : T) :=
  if n is p.+1 then op (iter p op x) else x.
Fixpoint foldr T A (f : T -> A -> A) a s :=
  if s is x :: xs then f x (foldr f a xs) else a.
\end{coq}

For example we can compute the subtraction of \C{5} from \C{7}, or the 
addition of all numbers in \C{[:: 1; 2; 3]}
as follows:

\begin{coq}{}{width=8cm}
Eval compute in iter 5 pred 7.
Eval compute in foldr add 0 [:: 1; 2; 3].
\end{coq}
\begin{coqout}{}{width=4cm}
 = 2 : nat
 = 6 : nat
\end{coqout}

The section mechanism lets one factor variable declaration and type
annotations among multiple definitions.  Incidentally it also let us
experiment with the crucial notion of symbolic computation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Symbolic computations under a context}

Which is the status of the \C{foldr} program \emph{before} the
\C{Section} is closed?  What are \C{T} and \C{A} and \C{f}?

\begin{coq}{}{}
Section iterators.

Variables (T : Type) (A : Type).
Variables (f : T -> A -> A).

Fixpoint foldr a s :=
  if s is x :: xs then f x (foldr a xs) else a.
\end{coq}

The variables \C{T}, \C{A} and \C{f} form the so called
\emph{local context} under which all operation take place.
For example, computing the type of \C{foldr} gives the following:

\begin{coq}{}{width=3.5cm,title=Query}
About foldr.
\end{coq}
\begin{coqout}{close_section_run}{title=Response, width=8.5cm}
foldr : A -> seq T -> A
\end{coqout}

This indicates that \C{foldr} is not a polymorphic function (yet)
and that it takes only two arguments, an element of \C{A} and
a list of \C{T}.

If the operation we intend to perform is computation, then
\C{T}, \C{A} and, most importantly, \C{f} are symbols.
 \C{f} in particular represents an unknown function.
Computing involving \C{f} become hence symbolic:

\begin{coq}{}{width=7cm}
Variable init : A.
Variables x1 x2 x3 : T.
Eval compute in
  foldr init [:: x1; x2; x3].
\end{coq}
\begin{coqout}{}{width=5cm}
= f x1 (f x2 (f x3 init))
: A	
\end{coqout}

\Coq{} has developed the expression symbolically.  If we substitute
in such expression the values we passed earlier we obtain

\begin{coq}{}{}
add 1 (add 2 (add 3 0))
\end{coq}
that indeed is an expression that computes to 6.

In later chapters we are going to prove properties about \C{foldr}.
In such case the local context has to be understood as containing
names (and type annotations) of fixed, but unknown, objects.
Hence proving a property of \C{foldr} when the iterated function
\C{f} is unknown means proving that such property is true for any
value \C{f} can possibly take.

The last observation to be made about symbolic computation is that
it is going to play an important role in the activity of proving
and that the way programs are written has an impact on the way they
compute symbolically.  For example, let's consider this alternative
definition of the addition between natural numbers

\begin{coq}{}{}
Fixpoint add m n := if m is m'.+1 then add m' n.+1 else n.
\end{coq}
\index[coq]{\C{add}}

It is a sensible definition, and we can show that the two additions
are equivalent.  Still, their computational behavior differ.
This time we use the \C{simpl} evaluation strategy.  The relevant difference
is that \C{simpl} leaves expressions in nicer forms whenever they contain
variables.

\begin{coq}{}{width=7cm}
Variable n : nat.
Eval simpl in pred (add n.+1 7).
Eval simpl in pred (addn n.+1 7).
\end{coq}
\begin{coqout}{}{width=5cm}
= pred (add n 8)
= addn n 7
\end{coqout}

Here we see that since \C{addn} exposes bits of its
final result early the \C{pred} function can compute, and cancels
the \C{.+1} coming out of the sum.  On the contrary
\C{add} does not expose a successor, instead it carries it on the second
argument, hence \C{pred} is stuck.  Is some sense \C{addn} is more
explicit about its result, and this helps, for example, to show that
\C{(addn n.+1 7)} is different from 0. As we have seen \Coq{} computes
automatically and in this case computation would expose a \C{S} symbol
and no natural number of the form \C{(S $~something$)} can be equal to 0.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Iterators in mathematics}

Numbers and sequences of objects are common in mathematics, so we feel
no need to justify our choice to present them in this chapter.
On the contrary it is legit to wonder which role programs like \C{foldr}
play in mathematics.
Let's take the left hand side of these two formulas:
$$
\sum_{i=1}^n (i * 2) - 1 = n ^ 2 \qquad
\sum_{i=1}^n i = \frac{n * (n + 1)}{2}
$$
They can both be faithfully represented by using \C{foldr}.

\begin{coq}{}{}
Fixpoint iota m n := if n is n'.+1 then m :: iota m.+1 n' else [::].
Notation "\sum_ ( m <= i < n ) F" :=
  (foldr (fun i a => F + a) 0 (iota m (n-m)).
\end{coq}
\index[coq]{\C{iota}}

The \C{iota} function generates the list of natural numbers
corresponding to the range of the summation.  We also provide
to \C{foldr} the neutral element for addition as the initial value
of the iteration.

\begin{coq}{}{width=8.5cm,title=Query}
Eval compute in \sum_( 1 <= i < 5 ) (i * 2 - 1).
Eval compute in \sum_( 1 <= i < 5 ) i.
\end{coq}{}{}
\begin{coqout}{}{width=3.5cm,title=Response}
= 16 : nat
= 10 : nat
\end{coqout}{}{}
\marginnote{maybe we should start from 1, give both bounds}

It is important that the iteration happens following the order of the list.
In this case the operation, addition, is commutative, so it does not really
matter, but it may not be the case for example if the iterated operation
is group multiplication.  What is even more crucial is that
the function argument passed to \C{foldr} is able to represent
faithfully the general term that make iterated operations so
flexible and widely used in mathematics.

The ability to write programs that manipulate functions, like \C{foldr}, is
crucial not only to provide convenient notations.  As we sketched in the
previous section we will be able to prove properties about \C{foldr} without
knowing the iterated function.  By assuming properties linking the iterated
operation to the initial value, like forming a monoid, we will be able to
provide a generic theory of iterated operations.  Such theory becomes richer
when the operation is also commutative, and even richer when we combine two
operations that distribute.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Exercises}

%%%%%%%%
\begin{Exercise}[label=ex:leq,difficulty=0,title={Order with subtraction}]
Define a program \C{leq} that uses \C{subn} and \C{eqn}, but no
explicit pattern matching, to test if a natural number is smaller
or equal than another one.
\end{Exercise}


%%%%%%%%
\begin{Exercise}[label=ex:pair,difficulty=0,title={The pair datatype}]
Define the pair datatype such that the following notation
applies.  Also define the first projection.

\begin{coq}{}{width=7cm}
Notation "( A , B )" := (pair A B).
Eval compute in fst (4, 5).
Eval compute in fst (true, false).
\end{coq}
\begin{coqout}{}{width=5cm}
$~$
     = 4 : nat
     = true : bool
\end{coqout}
Remark that the pair datatype has to be polymorphic in order to
be applicable to both natural numbers and booleans.
\end{Exercise}

%%%%%%%%
\begin{Exercise}[label=ex:iteradd,difficulty=0,title={Addition with iteration}]
Define a program computing the sum of two natural numbers
using \C{iter}.
\end{Exercise}

%%%%%%%%
\begin{Exercise}[label=ex:itermul,difficulty=0,title={Multiplication with iteration}]
Define a program computing the product of two natural numbers
using \C{iter}.
\end{Exercise}

%%%%%%%%
\begin{Exercise}[label=ex:nth,difficulty=0,title={Find the n-th element}]
Define a program taking a list, a natural number and a default value.  Such
program returns the n-th element of the list if n is smaller than the size of
the list.  It returns the default value otherwise.

\begin{coq}{}{width=7cm}
Eval compute in
  nth 0 [:: 3; 7; 11; 22] 2.
Eval compute in
  nth 0 [:: 3; 7; 11; 22] 7.
\end{coq}
\begin{coqout}{}{width=5cm}
     = 11
     : nat
     = 0
     : nat
\end{coqout}
\end{Exercise}

%%%%%%%%%
\begin{Exercise}[label=ex:rev,difficulty=0,title={List reversal}]
Define the program \C{rev} that reverses the order of the elements
of a list. 

\begin{coq}{}{width=5cm}
Eval compute in
  rev [:: 1; 2; 3].
\end{coq}
\begin{coqout}{}{width=7cm}
 = [:: 3; 2; 1]
 : seq nat
\end{coqout}
\end{Exercise}

%%%%%%%%%%%%%
\begin{Exercise}[label=ex:flatten,difficulty=1,title={List flattening}]
Define the program \C{flatten} that takes a list of lists and returns
their concatenation.  Don't write a recursive function, just reuse
the concatenation function and one of the higher-order iterators
seen so far.

\begin{coq}{}{width=7.3cm}
Eval compute in
  flatten [:: [:: 1; 2; 3]; [:: 4; 5] ].
\end{coq}
\begin{coqout}{}{width=5cm}
 = [:: 1; 2; 3; 4; 5]
 : seq nat
\end{coqout}
\end{Exercise}


%%%%%%%%%
\begin{Exercise}[label=ex:allwords,difficulty=2,title={All words of size n}]
Define the \C{all\_words} program that takes in input a
length \C{n} and sequence of symbols \C{alphabet}.
Such program has to generate a list of all words (i.e. list
of symbols) of size \C{n}.

\begin{coq}{}{width=5.5cm}
Eval compute in
  all_words 2 [:: 1; 2; 3].
\end{coq}
\begin{coqout}{}{width=7cm}
 = [:: [:: 1; 1]; [:: 1; 2]; [:: 1; 3];
       [:: 2; 1]; [:: 2; 2]; [:: 2; 3];
       [:: 3; 1]; [:: 3; 2]; [:: 3; 3]]
 : seq (seq nat)
\end{coqout}
\end{Exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Solutions}

\begin{Answer}[ref=ex:leq]

\begin{coq}{}{}
Definition leq m n := m - n == 0.
\end{coq}

\end{Answer}

%%%%%%%%%%
\begin{Answer}[ref=ex:pair]

\begin{coq}{}{}
Inductive prod (A B : Type) := pair (a : A) (b : B).
Notation "A * B" := (prod A B) : type_scope.
Notation "( A , B )" := (pair A B).
Definition fst A B (p : A * B) :=
  match p with (a, _) => a end.
\end{coq}
\index[coq]{\C{(_ * _)} (type scope)}
\index[coq]{\C{(_ , _)} (pairs)}

\end{Answer}

%%%%%%%%%%
\begin{Answer}[ref=ex:iteradd]

\begin{coq}{}{}
Definition addn n1 n2 := iter n1 S n2.
\end{coq}

\end{Answer}

%%%%%%%%%%
\begin{Answer}[ref=ex:itermul]

\begin{coq}{}{}
Definition muln n1 n2 := iter n1 (addn n2) 0.
\end{coq}

\end{Answer}

%%%%%%%%%%
\begin{Answer}[ref=ex:nth]

\begin{coq}{}{}
Fixpoint nth T (def : T) (s : seq T) n :=
  if s is x :: s' then if n is n'.+1 then nth def s' n' else x else def.
\end{coq}

\end{Answer}

%%%%%%%%%%
\begin{Answer}[ref=ex:rev]

\begin{coq}{}{}
Fixpoint catrev T (s1 s2 : seq T) :=
  if s1 is x :: xs then catrev xs (x :: s2) else s2.

Definition rev T (s : seq T) := catrev s [::].
\end{coq}

\end{Answer}

%%%%%%%%%%%%%

\begin{Answer}[ref=ex:flatten]

\begin{coq}{}{}
Definition flatten T (s : seq (seq T)) := foldr cat [::] s.
\end{coq}

\end{Answer}

%%%%%%%%
\begin{Answer}[ref=ex:allwords]

\begin{coq}{}{}
Definition all_words n T (alphabet : seq T) :=
  let prepend x wl := [seq x :: w | w <- wl] in
  let extend wl := flatten [seq prepend x wl | x <- alphabet] in
  iter n extend [:: [::] ].
\end{coq}

\end{Answer}



%%%%%%%%%%%%%%%%%%%%%%%%%% End of written part %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theoretical content:
% \begin{itemize}
% \item Functions with simple types ($\lambda$, $\rightarrow$): functions are the primitive concept
% \item Inductive {\bf datas}
% \item Programs by case analysis and recursion
% \item Compute (beta, delta, iota) example of beta (that helps later on to explain a predicate for elim principles)
% \item Polymorphic datatypes (introduce $\Pi$, and its \Coq{} notation
%   \C{forall}, for quantification over datatypes only)
% \item Everyone has a type : \C{0 : nat : Type : Type}, types avoid confusion
% \end{itemize}
% This is more or less a standard introduction to (a flavor of)
% functional programming, with two possible difficulties:
% \begin{itemize}
% \item Be precise but not too technical (e.g. on inductive types)
% \item Find a line of speech which does not bore/discourage
%   mathematicians.
% \item Somehow the syntax of (this fragment of the) terms should made
%   be clear and precise.
% \item types depending on terms (matrix x m)
% \end{itemize}


% \begin{itemize}
% \item Use monomorphic instances/compatible versions of the notations
%   that will later be generalized using canonical structures;
% \item For instance the infix \C{==} is the comparison on \C{nat}
% \item Further examples: \verb+\sum_(i <- l) F i+, \verb+\sum_(a <= b <) F i+
% in order to illustrate \C{foldr}.
% \end{itemize}
% \Coq{} commands and features:
% \begin{itemize}
% \item Implicit arguments (only to go from system F to ML), \C{@}
% \item Sections and its discharging, implicit types
% \end{itemize}
% 
% 
% \Coq{} types introduced:
% \begin{itemize}
% \item \C{bool, nat, seq, option, prod}
% \end{itemize}
% 
% Programs presented in detailed examples/exercises:
% \begin{itemize}
% \item Elementary programs on \C{option}: \C{odflt, obind,}\dots
% \item Elementary programs on \C{seq} (without the \C{eqType}):
%   \C{size, map, iota,...}
% \item Comparison functions on \C{bool, nat}
% \item Comparison functions on containers, taking the comparison
%   function on the type of stored elements in argument (mind the
%   higher-order)
% \item Boolean connectives, arithmetic operations on \C{nat}
% \item Do not forget to mention \C{if .. then .. else}
% \item Euclidean division, computation of prime factors, examples from
%   elementary number theory
% \item Examples of G{\"o}del-style encoding from the {\tt choice.v} library.
% \item Examples/exercises about extended gcd (egcdn), which mix lists
%   and arithmetic.
% \end{itemize}
% If possible give a few context to the exercises, in order not to bore
% the reader not familiar with programming. For instance do not say that
% you encode sequences of nats in nats but give a few hints about the
% use of G{\"o}del encoding.
% 
% Examples and exercises can be executed in an empty context, or
% libraries can be required for the purpose of (re)using and combine existing
% programs (non proofs here).
% 
% The current contents are organized like the tutorial at ITP15 I gave (Enrico).
% It was on standard Coq and was intended not to be difficult class ;-)
% It is a possible plan, no strong opinions.
% 
% \section*{Things needed by chapter 2}
% \begin{itemize}
% \item type annotations on arguments of lemmas/definitions can be omitted
% \item if then else
% \item all boolean connectives: \C{orb andb negb implb xorb}
% \item recursive programs: \C{addn muln subn leq eqn expn dvdn}
% \item notations with associativity: \C{+ * - == != .+1 < <= \%| \~\~}
% \end{itemize}
% 
% 
% \section{Functional programming in a nutshell}
% Only intuitions here.
% 
% For a mathematician this is perfectly natural, the main problem is the syntax.  E.g.
% $$f(x) = x * 2\qquad\qquad f(7)$$
% here we define a function named f that doubles its input.  Then we denote f(7) the value of f
% when the input is 7. The novelty is that:
% \begin{enumerate}
% \item functions are anonymous, and the names. \verb+(fun x => x * 2)+ is the function that
% 	doubles.  We can name it: \verb+Definition f := fun x => x * 2.+.  We don't need to
% 	name a function in order to use it in an expression. (there is something like
% 	\verb+x |-> x * 2+, but this is always attached to a name somehow).
% \item function application is \verb+(f 7)+.
% \end{enumerate}
% 
% For a computer scientist used to imperative languages, these are the main weird points:
% \begin{enumerate}
% \item there is no return statement, AKA expressions are already programs.  e.g.
% 	4 is a program, and 2+2 as well.  Programs then evaluate like a mathematical expression
% 	can be simplified
% \begin{verbatim}
%         if (false || true) then 2 + 2 else 7
%         if true then 2 + 2 else 7
%         2 + 2
%         4
% \end{verbatim}
% also
% \begin{verbatim}
%         2 + (if 7 == 2 then 4 else 2)
%         2 + (if false then 4 else 2)
%         2 + 2
%         4
% \end{verbatim}
% \item programs are really first class data (HO programming, not reasonably popular even outside
% 	the functional world). E.g.
%     This program takes in input a function f and uses it twice
% \begin{verbatim}
%       (fun f => f 3 + f 4)
% \end{verbatim}
% hence this is a valid program computing 14
% \begin{verbatim}
%       (fun f => f 3 + f 4) (fun x => x + x)
% \end{verbatim}
% \end{enumerate}
% 
% 
% \subsection{Build and destruct simple data}
% Simplest data is bool.
% 
% \begin{coq}{name=bool}{}
% Inductive bool : Type := true | false.
% Check bool : Type.
% Check true : bool.
% Check false.
% Check 3 : bool. (* boom *)
% \end{coq}
% 
% This tells you that one can construct a boolean using true or false but not a number.
% Types tells you how your values are (in normal form, since (true || false) is also of type bool, recall the example before).
% Hence it makes sense to consider only true and false when one inspects a bool.
% 
% \begin{coq}{name=negb}{}
% Definition negb (b : bool) : bool :=
%   match b with
%   | true => false
%   | false => true
%   end.
% 
% Check negb.
% Check negb true.
% Check negb (negb true).
% Check negb 3. (* boom *)
% 
% Eval compute in negb true.
% Eval compute in negb false.
% \end{coq}
% We see the function type (arrow) and how typing works in this simple case.
% Also that functions compute in Coq.
% Sugar:
% 
% \begin{coq}{name=negb}{}
% Definition another_negb (b : bool) : bool :=
%   if b then false else true.
% Definition yet_another_negb :=
%   (fun b : bool =>
%       if b then false else true).
% Definition andb (b1 : bool) (b2 : bool) :=
%   if b1 then b2 else false.
% Notation "x && y" := (andb x y).
% Eval compute in true && false.
% Eval compute in true && true.
% \end{coq}
% 
% \subsection{Polymorphic containers and binding in match}
% 
% This is not the syntax used in ssr I guess.
% 
% \begin{coq}{name=option}{}
%  Inductive option (A : Type) : Type :=
%  | None
%  | Some (a : A).
% Check option.
% Check option bool : Type.
% Check Some true. (* Implicit argument *)
% \end{coq}
% 
% Talk about implicit arguments here.
% 
% \begin{coq}{name=implicits}{}
% About Some.
% (* The @ locally disables the implicit arguments *)
% Check @Some bool true.
% Check @Some _ true.
% \end{coq}
% 
% Inspecting a container
% 
% \begin{coq}{name=matchopt}{}
% Definition is_empty A (box : option A) : bool :=
%   match box with
%   | None => true
%   | Some _ => false  (* Here _ means discard the little a *)
%   end.
% Eval compute in is_empty None.
% Eval compute in is_empty (Some true).
% (* Note: the function is polymorphic! *)
% Eval compute in is_empty (Some 4).
% \end{coq}
% 
% Two words about polymorphism.
% 
% Now binding in a match.
% 
% \begin{coq}{name=matchopt2}{}
% Definition get_default A (box: option A) (a : A) : A :=
%   match box with
%   | None => a
%   | Some x => x  (* this x is a name on the left bound to the contents *)
%   end.
% 
% Eval compute in get_default None 3.
% Eval compute in get_default (Some 4) 3.
% \end{coq}
% 
% More containers
% 
% \begin{coq}{name=pair}{}
%  Inductive prod (A B : Type) : Type :=
%  | pair (a : A) (b : B).
% 
%  Notation "A * B" := (prod A B).
%  Notation "( a , b )" := (pair a b).
% 
% Check (true, Some false).
% 
% Definition fst A B (p : A * B) :=
%   match p with
%   | ( x , _ ) => x
%   end.
% 
% Eval compute in fst (true, None).
% 
% Definition snd A B (p : A * B) :=
%   match p with (_, y) => y end.
% \end{coq}
% 
% \subsection{Recursive data}
% 
% Nat, with a special syntactic sugar
% 
% \begin{coq}{name=nat}{}
%    Inductive nat : Type :=
%    | O
%    | S (n : nat).
% 
% Check S (S O).
% Check 2.
% Check 1.
% \end{coq}
% 
% Recursive functions
% 
% \begin{coq}{name=plus}{}
% Fixpoint plus (n : nat) (m : nat) : nat :=
%   match n with
%   | O => m
%   | S w => S (plus w m)
%   end.
% Infix "+" := plus.
% 
% Check 2 + 3.
% Eval compute in 2 + 3.
% \end{coq}
% 
% execution step by step
% 
% \begin{coq}{name=execplus}{}
%    S (S 0) + 3
%    S ((S O) + 3)
%    S (S (O + 3))
%    S (S 3)
%    5
% \end{coq}
% 
% Here I was also showing
% 
% \begin{coq}{name=plusrec}{}
% Fixpoint fast_plus (n : nat) (m : nat) : nat :=
%   match n with
%   | O => m
%   | S w => fast_plus w (S m)
%   end.
% 
%     S (S O) + 3
%     S O + 4
%     O + 5
%     5
% \end{coq}
% 
% and making the point that reasoning about these two plus is not equally easy (short parenthesis on symbolic computation).
% 
% \begin{coq}{name=plusrec}{}
% Eval simpl in
%   (fun n => fast_plus (S n) 3).  (* no progress *)
% Eval simpl in
%   (fun n => plus (S n) 3).  (* some output already, we can prove that it is not 0 *)
% \end{coq}
% 
% Lists
% 
% \begin{coq}{name=list}{}
% Inductive list (A : Type) : Type :=
% | nil
% | cons (x : A) (xs : list A).
% 
% Infix "::" := cons.
% Arguments nil {A}.
% Arguments cons {A} x xs.
% 
% (* The type of lists imposes all the elements to
%     be in the same type! *)
% Check true :: false :: nil.
% Fail Check 1 :: false :: nil.
% 
% (* A non recursive function on lists *)
% Definition tl A (l : list A) : list A :=
%   match l with
%   | nil => nil
%   | _ :: xs => xs
%   end.
% 
% Eval compute in tl (6 :: 99 :: nil).
% 
% (* The most popular function on lists *)
% Fixpoint len A (l : list A) : nat :=
%   match l with
%   | nil => O
%   | x :: xs => 1 + (len xs)
%   end.
% 
% Eval compute in len (1 :: 2 :: 3 :: nil).
% Fixpoint split A B (l : list (A * B)) : list A * list B :=
%   match l with
%   | nil => (nil, nil)
%   | (x,y) :: rest =>
%       let xs_ys := split rest in
%       (x :: fst xs_ys, y :: snd xs_ys)
%   end.
% 
% Eval compute in
%   split ((1,2) :: (3,4) :: nil).
% 
% Fixpoint zip A B (la : list A) (lb : list B) : list (A * B) :=
%   match la, lb with
%   | nil, nil => nil
%   | x::xs, y::ys => (x,y) :: zip xs ys
%   | _, _ => nil
%   end.
% 
% Eval compute in
%   zip (1 :: 2 :: nil) (true :: false :: nil).
% 
% Eval compute in
%   let xs_ys := split ((1,2) :: (3,4) :: nil) in
%   zip (fst xs_ys) (snd xs_ys).
% \end{coq}
% 
% \subsection{termination}
% 
% Here we say how termination is checked, which are the alternative when the
% heuristic fails (not very relevant for mathcomp I guess) and relate that to
% logical inconsistency (maybe too early here, needs curry howard).
% 
% \begin{coq}{name=paradoxes}{}
% Fail
% Fixpoint wrong A (l : list A) {struct l} :=
%   match l with
%   | nil => 0
%   | x :: xs => 1 + wrong (x :: nil)
%   end.
% 
% Fixpoint loop (n : nat) : False := loop n.
% 
% Check loop 3.
% Fail Timeout 2 Eval compute in loop 3.
% \end{coq}
% 
% Also data must be checked.
% 
% \begin{coq}{name=paradoxes2}{}
% Inductive non_positive : Type :=
% | Call (f : non_positive -> False)
% 
% Definition self (t : non_positive) : False :=
%   match t with
%   | Call f => f t
%   end.
% 
% Definition loop2 : False := self (Call self).
% 
% Fail Timeout 2 Eval compute in loop2.
% \end{coq}
% 
% \subsection{HO programming}
% 
% A function can be abstracted over another
%    function.  It is a useful mechanism to write
%    code that can be reused, especially in the context
%    of polymorphic containers.
% 
% \begin{coq}{name=map}{}
% Fixpoint map A B (f : A -> B) (l : list A) : list B :=
%   match l with
%   | nil => nil
%   | x :: xs => f x :: map f xs
%   end.
% 
% Eval compute in
%   map (fun x => x + 2) (3 :: 4 :: 7 :: nil).
% Eval compute in
%   map negb (true :: false :: nil).
% 
% (* fold f (x1 :: x2 :: .. xn :: nil) a
%      =
%             (f xn (.. (f x2 (f x1 a))))
% *)
% Fixpoint fold A B (f : B -> A -> A) (l : list B) (a : A) : A :=
%   match l with
%   | nil => a
%   | x :: xs => fold f xs (f x a)
%   end.
% 
% (* what does this do? *)
% Eval compute in fold cons (1 :: 2 :: 3 :: nil) nil.
% \end{coq}
% 
% Here one could use a section for A B and talk about all that.

% \section{old contents (before Enrico's tutorial)}
% 
% Do use \C{About} for informations (not \C{Check}).
% \begin{coq}{name=beta}{}
% Eval beta in (fun x => x + x) 3. (* 3 + 3 : nat *)
% Definition f := fun x : nat => x + x.
% Definition f (x : nat) := x + x.
% About f : nat -> nat.
% \end{coq}
% 
% TODO: "beta" alone is not a reduction tactic, but we could add it.
% 
% maybe also talk about delta here and make example of f.
% 
% \subsection{Inductive data, case analysis and recursion}
% bool, nat.
% 
% \begin{coq}{name=ind-data}{}
% Inductive bool : Type := true | false.
% Inductive nat :Type := O | S of nat.
% Check true : bool : Type. (* on a side note .. : Type : Type *)
% Check (S (S O)). (* 2 : nat *)
% \end{coq}
% 
% 
% 
% 
% match, fix, termination.
% 
% \begin{coq}{name=bool-conn}{}
% Definition andb := ...
% Fixpoint addn := ..
% Fixpoint eq_nat
% Fixpoint leq
% \end{coq}
% 
% discuss example of a real computation, not just beta.
% 
% \begin{coq}{name=compute}{}
% Compute (addn 3 4)
% \end{coq}
% 
% now simple notation come in to play
% 
% \begin{coq}{name=notation-infix}{}
% Infix "+" := addn.
% \end{coq}
% 
% \subsection{Polymorphism and HO programming}
% option, seq, pairs.
% 
% \begin{coq}{name=option}{}
% Inductive option A := None | Some of A.
% Check option. (* Type -> Type *)
% Check Some. (* : forall A : Type, A -> option A *)
% Fixpoint map A B (f : A -> B) := ...
% Fixpoint eq_seq A (eq_A : A -> A -> bool) l := ...
% \end{coq}
% 
% polymorphism as in F
% 
% may be also examples of polymorphisms that can be defined in pure
% $\lambda$-calculus (identity, argument swaping).
% 
% \section{programming in Coq}
% this contains real programs, and is the excuse to talk about:
% 
% \subsection{Sections}
% and Implicit Type, to factor the type parameter of containers like
% sequences.  Write more stupid programs on seq.
% 
% \begin{coq}{name=seq}{}
% Section Seq.
% Variable A : Type.
% Variable x0 : A.
% Implicit Type l : seq A.
% ...
% Fixpoint fold f l := ...
% Fixpoint rev l := ...
% \end{coq}
% 
% 
% \subsection{Implicit arguments}
% to imitate polymorphism a-la ML, simplest example of type inference
% like \C{Some _ 3}.  Set implicit for inductive types/constructors too,
% and functions on them like the ones on seq we have seen before.
% 
% \begin{coq}{name=Arguments}{}
% Arguments seq {T}.
% Arguments nil {T}
% Arguments cons {T} x xs.
% About seq.
% Check cons 3 nil.
% (* we have notataions *)
% Check [:: 3, 4 ].
% Fixpoint size A l := ...
% \end{coq}
% 
% About is bad because it mention names that are not necessarily displayed.
% Maybe we should tell people to open the document and/or talk about Locate,
% Print.  Or else use Search (that does all that) but in an empty
% file, where no theorems pop up.
% 
% \subsection{Exercises (explained): arithmetic}
% by now we should have the infrastructure to write program on arithmetic
% 
% \begin{coq}{name=stuff}{}
% divn
% prime  (* an simpler version *)
% \end{coq}
% 
% from choice.v
% 
% \begin{coq}{name=smart}{}
% encode
% decode
% \end{coq}
