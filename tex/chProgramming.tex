\Chapter{Computational definitions \\ The syntax of terms}{Defining concepts by writing programs}\label{ch:prog}

\textcolor{blue}{Find a more catchy title? The motivation is: how to define things:
objects, operations, (boolean) relations.}

We will take the point of view that mathematics can be understood as
the study of objects, operations on these objects, and abstractions.  
Children start learning mathematics by counting, where the objects are
numbers and the operations are enumerating and adding.  In fact
numbers are already the result of an abstraction process.

What are the objects, the operations, and the abstractions in a given
mathematical corpus is quite fluctuant.  The objects of group theory
may sometimes be viewed as operations in another context.  Nevertheless,
in this chapter, we describe how some objects are described with the intent
that they are {\em inert}, that is, they are meant to be
manipulated by operations.  We also show how operations are described.

\section{Functions}
In this section, we expect readers to get acquainted with the notion
of function and the associated syntax.  We rely on a type of natural
numbers that will only be described fully a few pages later.  There is an
addition operation associated to this type and noted with the \C{+}
symbol, and this operation will also be described a few pages later in
the text.

We start by considering the expression
\[ 2 + 1 \]
We can read this expression as an object, but also as the result of an
operation on an object, or as the result of an operation on two
objects.  Let us first consider the operation of {\em adding one to
  natural number}.  This operation is written in the following manner.

\begin{coq}{name=exfun}{}
  fun n => n + 1
\end{coq}
To write such an operation, we can start from the expression {\tt 2 +
  1} and isolate the object in this expression that is considered a
variable component for the operation, here {\tt 2}, we then replace
this object with a symbolic name, here {\tt n}.  We then encapsulate
the expression {\tt n + 2} with the prefix {\tt fun n =>} to express
that the operation produces a certain result {\tt n + 1} when given an
input {\tt n}.

So we have an expression which represents the operation of adding 1.
Applying this operation to the object {\tt 2} will be written this
way:

\begin{coq}{name=exapp}{}
  (fun n => n + 1) 2
\end{coq}
From the point of view of mathematical syntax, this object {\tt
  fun n => n + 1} is unusual.  When defining an operation, we usually
rely on a sentence {\em consider the function \(f\) from {\(\mathbb{N}\)}
to {\(\mathbb{N}\)} which maps \(n\) to \(n + 1\)}.  This would also be
written without natural language as follows:

\[f : 
\begin{array}{ccc}
{\mathbb{N}} &\rightarrow& {\mathbb{N}}\\
n &\mapsto& n + 1
\end{array}\]

The main difference is that the usual mathematical practice includes
the step of giving a name, here \(f\) to the operation.

When using Coq and ssreflect, the step of giving a name can also be
performed, in the following manner:

\begin{coq}{name=exdef}{}
Definition f := fun x => x + 1.
\end{coq}
An alternative syntax for exactly the same definition is as follows,
this alternative syntax is actually preferred.

\begin{coq}{name=exdef-pref}{}
Definition f x := x + 1.
\end{coq}
As was obvious in the mathematical formulation, operations are mainly
described by functions and mathematical practice is also to give
information about the domain and the codomain of functions at
definition time, as we did when writing
\({\mathbb{N}}\rightarrow{\mathbb{N}}\).  In Coq syntax, we will write
the same information as follows, because \C{nat} is the name used in
Coq to represent \(\mathbb{N}\):

\begin{coq}{name=exdef-type}{}
Definition f (x : nat) : nat := x + 1.
\end{coq}

Once a definition was made, the Coq system provides a command to
describe the relevant information about the constant that is defined:

\begin{coq}{name=about_f}{width=6cm,title=A function}
About f.
\end{coq}
\coqrun{name=about_f_run}{about_f}
\begin{coqout}{run=about_f_run}{title=Response,width=6cm}
f : nat -> nat
Argument scope is [nat_scope] ...
\end{coqout}
This response confirms that \C{f} is a function from
\({\mathbb{N}}\) to \({\mathbb{N}}\).  We also learn that  \C{f}
will interact with the parser in such a way that overloaded notations
will be interpreted as notations for operations on natural number.

We can be more inquisitive in our requests for information about
\C{f}, we can also require to know what is the value.  This is done in
the following manner:

\begin{coq}{name=print_f}{width=6cm,title=A function's value}
Print f.
\end{coq}
\coqrun{name=print_f_run}{print_f}
\begin{coqout}{run=print_f_run}{title=Response,width=6cm}
f =- fun x : nat -> x + 1
       : nat -> nat
\end{coqout}

We see in this example that {\em type information} is an important
feature of the language.  Type information is given twice in the
result of the \C{Print} command, once in the fragment ``\C{fun x : nat
  =>}'' and once in the second line, behind the colon ``\C{:}''.  The first
time, what we get is that the input of the function is expected to be
a value of type \C{nat}.  The second time, what we get is that the
type of \C{f} itself is the function type \C{nat -> nat}.  In fact,
the colon character (when surrounded by spaces) will always be used to
give type information.

The function \C{f} operates on natural numbers, of type \C{nat}, but
we can also define functions that operate on functions.  For instance,
the following definition introduces a function that takes a function
from \C{nat} to \C{nat} and returns a new function from \C{nat} to
\C{nat}.

\begin{coq}{name=repeat_twice_def}{}
Definition repeat_twice (g : nat -> nat) :=
  fun x => g (g x).
\end{coq}
Reading the first line of this statement, we see that a new object is
being defined, called \C{repeat_twice}.  We also see that this object
is a function argument the argument of which is a function of
type \C{nat -> nat}.  For later reference in the definition of
\C{repeat_twice}, the argument is given the name \C{g}.

Reading the second line of this statement, we see that the value
returned by \C{repeat_twice} when applied to its argument is a new
function, described using the ``\C{fun .. => ..}'' construct.  The
argument to that function is called \C{x}.  After the \C{=>} sign, we
find the ultimate value of this function.  This fragment of text, \C{g
  (g x)}, also deserves some explanation.  This fragment describes the
application of function \C{g} to an expression \C{(g x)}.  In turn,
the fragment \C{g x} describes the application of function \C{g} to
\C{x}.  The lesson here is that the application of a function to an
argument is not systematically written using parentheses, as is
customary in mathematics, but it is usually only written by
juxtaposing the function (on the left) and the argument (on the
right).  Parentheses are only added when they are needed to resolve
ambiguity.  Also expressions written with several subexpressions side
by side should be read as if there were parentheses around the
subgroups on the left.  We will illustrate this in the next few
examples.

When we want to apply the function \C{repeat_twice} to the function
\C{f} and the number \C{2} and perform the computation, this can be
written as follows:
\begin{coq}{name=eval_repeat_twice_f_two}{width=6cm,title=Evaluating
    an expression}
Compute repeat_twice f 2
\end{coq}
\coqrun{name=eval_run}{eval_repeat_twice_f_two}
\begin{coqout}{run=eval_f_run}{title=Response,width=6cm}
  = 4 : nat
\end{coqout}
From the syntax point of view, we wrote three subexpressions only
separated by space.  By default, the parser understands this as
\C{(repeat_twice f) 2}, so we actually have a first subexpression
which is \C{repeat_twice} applied to \C{f}.  According to the
definition of the first function, this returns an intermediate
function from \C{nat}
to \C{nat}, which is then applied to \C{2}.  The intermediate function
actually is \C{fun x => f (f x)}, so the result expression is \C{f (f
  2)}.  Remembering the definition of \C{f}, this expression can also
be read as \C{(2 + 1) + 1}.  Thus, after computation, the result is \C{4}.

\section{Data: cases and induction}
It is also possible to define a datatype by giving in one declaration
the type, methods to build elements of this type, and methods to
use elements of the type while computing.  This approach is used
systematically in Coq to define a variety of basic datatypes among
which boolean values, natural numbers, pairs and sequences of values
are the most prominents examples.  We will study these examples in
turn.
\subsection{Boolean values}
The type \C{bool} of boolean values contains two values that can be
distinguished in computations.  The declaration of this type happens
in one of the first files to be automatically loaded when Coq starts.
We can recover this declaration by using the \C{Print} command.

\begin{coq}{name=print_bool}{width=6cm,title=Type bool}
Print bool.
\end{coq}
\coqrun{name=print_bool_run}{print_bool}
\begin{coqout}{run=print_bool_run}{width=6cm,title=Response}
Inductive bool : Set := true : bool | false : bool
\end{coqout}
This declaration states explicitely that there are only two cases for
elements of type \C{bool}.  the first case is given by the constant
\C{true}, the second case by constant \C{false}.  Thus, the
declaration of the type gives in an obvious manner the type, \C{bool},
and ways to build elements, \C{true}, and \C{false}.  All definitions
in Coq, like this one, which define a type by providing at the same
time the only ways to build elements of the type are called {\em
  inductive} definitions.  The two objects \C{true} and \C{false} are
called constructors.

In practice, this means that we can build a well-formed expression of
type \C{bool} by using either \C{true} or \C{false}.  Coq provides a
command to check that an expression is well-formed.  We can use this
command here to illustrate a use of the constructors.

\begin{coq}{name=check_true}{width=6cm}
Check true.
\end{coq}
\coqrun{name=check_true_run}{check_true}
\begin{coqout}{run=check_true_run}{width=6cm,title=Response}
true : bool
\end{coqout}

To use boolean values in computations, we need a construct that makes
it possible to return different values depending on whether some
boolean input is \C{true} or \C{false}.  This is provided by an \C{if
  .. then .. else} construct, as illustrated here:

\begin{coq}{name=if_example}{}
 if true then 3 else 2
\end{coq}
More generally, we can define a function that takes a boolean value as
input and returns one of two possible natural numbers in the following
manner:

\begin{coq}{name=definef23}{}
Definition f23 b := if b then 2 else 3.
\end{coq}
\coqrun{name=definef23_run}{definef23}
Readers are invited to test this function using the \C{Compute} command.

\subsection{natural numbers}
The description of natural numbers in the Coq system is inspired from
the work of Peano at the beginning of the twentieth century.  The
basic idea is that any natural number is either 0 or the successor of
an existing natural number.  Moreover, the successor operation is
injective.  Peano also considers supplementary operations, like
addition and multiplication, but we shall see that the Coq system
provides enough machinery so that these operations can be described as
defined functions on top of the basic tools.

The description of natural numbers as essentially generated by a
constant \C{O} (to represent 0) and a function \C{S} to represent 
the successor operation is given in the definition of the type
\C{nat}. This can
be obtained from the Coq system by using the \C{Print} command.

\begin{coq}{name=print_nat}{width=6cm,title=Type nat}
Print nat.

\end{coq}
\coqrun{name=print_nat_run}{print_nat}
\begin{coqout}{run=print_nat_run}{width=6cm,title=Response}
Inductive nat : Set :=  O : nat | S : nat -> nat
\end{coqout}

This declaration states that \C{O} is a natural number, \C{S O} is a
natural number, \C{S (S O)}, and so on, and these are the only natural
numbers.  When interacting with Coq, we will often see decimal
notations, but these are only a parsing and display
facility provided to the user for readability.  So \C{O} is displayed
\C{0}, \C{S O} is displayed \C{1}, etc.  The decimal notations can
also be used interactively.

The ssreflect library provides a few notations to make uses of the
constructor {\tt S} more intuitive to read.  In particular, if \C{x}
is a value of type \C{nat}, \C{x.+1} is another way to write \C{S
  x}.  The \C{.+1} notation binds more strongly than function
application, so that this notation makes it possible to avoid some
needs for parentheses.
Similar notations are provided for up to 4 uses of the \C{S}
constructor.  This can be illustrated by the following dialog (where
we assume that \C{f} is a function of type \C{nat -> nat}).
  For instance, we can write the following
expression, when \C{f} is already defined with type \C{nat -> nat}.

\begin{coq}{name=f_plus_one}{width=6cm}
Check fun x => f x.+1.

Locate ".+4".
$~$
$~$
$~$
\end{coq}
\coqrun{name=f_plus_one_run}{f_plus_one}
\begin{coqout}{f_plus_one_run}{width=6cm,title=Response}
fun x => f x.+1 : nat -> nat

Notation        Scope
"n.+4" := S (S (S (S n)))  : nat_scope
    (default interpretation)
\end{coqout}

When writing functions that compute on natural numbers, we can
proceed by cases, as was done in the previous section for boolean
values.  Again, there are two cases, either the natural number used in
the computation is \C{O} (also written \C{0}) or it is \C{n.+1} for
some \C{n}, but in the latter case, it is often useful to also be able
to use \C{n} for further computations.  The usual approach in this
case is to describe the two cases as patterns: if the data fits one of
the patterns, the computation proceeds with the corresponding
computation.  Here is an example:

\begin{coq}{name=pattern_on_nat}{}
match n with | O => true | p.+1 => false end
\end{coq}
In this expression we describe a computation where some decision is
taken depending on the value of the number \C{n}.  The fragment 
\C{| 0 => true} expresses that when \C{n} is \C{0}, the final value is
\C{true}.  In this expression, \C{0} is a pattern and the computation
checks whether \C{n} matches this pattern.  The fragment
\C{| p.+1 => false}  expresses that when \C{n} is the successor of
some number \C{p} the final value is \C{false}.  In other words, when
\C{n} is the successor of somebody, then the returned value is
\C{false}.  The value \C{p} mentioned in this pattern is not known in
advance, it is actually computed at the moment the \C{n} is matched
against the pattern.  For instance, if \C{n} is \C{5}, then the value
computed for \C{p} is \C{4}.  In this particular instance, \C{p} is
not used, so that we can also write as follows:

\begin{coq}{name=pattern_on_nat}{}
match n with | 0 => true | _.+1 => false end
\end{coq}
The symbole \C{_} is to represent a pattern whose value will never be
used.

This pattern can also be written using an ``\C{if .. then .. else}''
syntax:
\begin{coq}{name=pattern_on_nat_0}{}
if n is 0 then true else false
\end{coq}

For an example where the pattern variable is actually used, we can
observe the function that returns the predecessor of a natural number
when it exists.  This function already exists in the library, but we
could redefine it as follows:

\begin{coq}{name=pred}{}
Definition my_pred n := if n is u.+1 then u else n.
\end{coq}
Reading this function in detail, we see that the argument \C{n} is
matched with the pattern \C{u.+1}.  When this comparison
succeeds, the variable \C{u} receives the value of the immediate
subterm of \C{n} the computation proceeds by computing the expression
in the \C{then} branch of the \C{if} statement.  This branch contains
exactly \C{u}, so this is the result value.  When the comparison
fails, this means that \C{n} has the form \C{0}, the returned value is
\C{n}, or equivalently \C{0}.

Assume for instance that \C{n} is \C{2}, in other words \C{n} is the
successor of the successor of O, which we could also write
\C{0.+1.+1}.  When matching \C{0.+1.+1} against the pattern \C{u.+1}
the value of \C{u} is found to be \C{0.+1}, in other words \C{1}.

The pattern used in the \C{if} statement can use several nested levels
of the \C{.+1} pattern.  For instance, if we want to write a function
that returns \(n-5\) for every input larger than or equal to 5 and 0
for every input smaller than 5, we can write the following definition:

\begin{coq}{name=pred5}{}
Definition my_pred5 n :=
  if n is u.+1.+1.+1.+1.+1 then u else 0.
\end{coq}
On the other hand, if we want to describe a different computation for
three different cases and use variables in more than one case, we need
to revert to the ``\C{match .. with .. end}'' syntax.  Here is an
example:

\begin{coq}{name=awkward5}{}
Definition three_patterns n :=
  match n with
  | u.+1.+1.+1.+1.+1 => u
  | v.+1 => v
  | O => n
  end.
\end{coq}
This function maps any number \(n\) larger than or equal to 5 to \(n-5\),
any number \(n \in \{1, \ldots, 4\}\) to \(n-1\), and \(0\) to \(0\).

The pattern matching construct \C{match .. with | .. => .. end}
contains an arbitrary large number of {\em pattern matching rules} of
the form \C{| \(pattern\) => \(result\)}.  For the symbols that are allowed
in the pattern, they are essentially restricted to \C{O}, \C{S}, and
variable names.  Thanks to notations, a pattern can also contains
occurrences of the notation ``\C{.+1}'' which represents \C{S}, and
decimal numbers, which represent the corresponding terms built with
\C{S} and \C{O}.  When a variable name occur, this variable can be
re-used in the result part.  When computing with a natural number, all
the pattern matching rules are tried successively against this number.
For instance, if the input is \C{2}, in other \C{0.+1.+1}, the first
rule cannot match, because this would require that \C{0} matches
\C{u.+1.+1.+.1} and we know that \(0\) is not the successor of any
natural number, when it comes to the second rule \C{0.+1.+1} matches
\C{v.+1}, because the rightmost \C{.+1} in the value of \C{2} matches
the \C{.+1} part in the pattern and \C{0.+1} matches the \C{v} part in
the pattern.


With only pattern-matching, we do not cope well with the fact that the
type \C{nat} of natural numbers actually contains an infinity of
elements.  To really handle infinity, the Coq system provides another
facility, known as {\em recursivity}.  The idea behind recursivity is
that we can define a function while supposing that it is already
defined for a subset of the type.  This adds a new element for which
the function is defined, and progressively this makes that the
function is defined for all possible inputs.

Many usual functions to deal with natural numbers are
defined recursively.  For instance, we can define addition in the
following manner:

\begin{coq}{name=redefine_add}{}
Fixpoint my_add n m :=
  match n with
  | 0 => m
  | p.+1 => (my_add p m).+1
  end.
\end{coq}
In this line, we learn that the keyword for defining a recursive
function is \C{Fixpoint}.  We see also that the function being
defined, here called \C{my_add}, is used in the definition of the
function \C{my_add} itself.  This text expresses that the value of
\C{my_add 0 m} is \C{m} and that the value \C{my_add p.+1 m} is
\C{(my_add p m).+1}.

Each of the pattern matching rules in this definition expresses an
expected behavior of the addition function.  The first pattern
matching rule expresses that \C{my_add 0 m = m}; as expected adding 0
to any number \C{m} returns \C{m}.  The second pattern matching rule
expresses that \C{my_add p.+1 m = (my_add p m).+1}.  This equality may
seem redundant, but there is progress when reading this equality from
left to right: addition of \C{p.+1} is explained with the help of
addition of \C{p}, which is a smaller number.  When considering the
expression \C{my_add 2 3}, the computation progresses as follows
\begin{tabbing}
\C{adfasdfasdfafafafafafaf}\=\kill
\C{my_add 2 3} \> use the second pattern matching rule, \C{p = 1}\\
\C{(my_add 1 3).+1} \> use the second pattern matching rule, \C{p = 0}\\
\C{(my_add 0 3).+1.+1} \> use the first pattern matching rule\\
\C{3.+1.+1}\> remember that \C{5 = 3.+1.+1}\\
\end{tabbing}

Theoretical content:
\begin{itemize}
\item Functions with simple types ($\lambda$, $\rightarrow$): functions are the primitive concept
\item Inductive {\bf datas}
\item Programs by case analysis and recursion
\item Compute (beta, delta, iota) example of beta (that helps later on to explain a predicate for elim principles)
\item Polymorphic datatypes (introduce $\Pi$, and its \Coq{} notation
  \C{forall}, for quantification over datatypes only)
\item Everyone has a type : \C{0 : nat : Type : Type}, types avoid confusion
\end{itemize}
This is more or less a standard introduction to (a flavor of)
functional programming, with two possible difficulties:
\begin{itemize}
\item Be precise but not too technical (e.g. on inductive types)
\item Find a line of speech which does not bore/discourage
  mathematicians.
\item Somehow the syntax of (this fragment of the) terms should made
  be clear and precise.
% \item types depending on terms (matrix x m)
\end{itemize}


\begin{itemize}
\item Use monomorphic instances/compatible versions of the notations
  that will later be generalized using canonical structures;
\item For instance the infix \C{==} is the comparison on \C{nat}
\item Further examples: \verb+\sum_(i <- l) F i+, \verb+\sum_(a <= b <) F i+
in order to illustrate \C{foldr}.
\end{itemize}
\Coq{} commands and features:
\begin{itemize}
\item Implicit arguments (only to go from system F to ML), \C{@}
\item Sections and its discharging, implicit types
\end{itemize}


\Coq{} types introduced:
\begin{itemize}
\item \C{bool, nat, seq, option, prod}
\end{itemize}

Programs presented in detailed examples/exercises:
\begin{itemize}
\item Elementary programs on \C{option}: \C{odflt, obind,}\dots
\item Elementary programs on \C{seq} (without the \C{eqType}):
  \C{size, map, iota,...}
\item Comparison functions on \C{bool, nat}
\item Comparison functions on containers, taking the comparison
  function on the type of stored elements in argument (mind the
  higher-order)
\item Boolean connectives, arithmetic operations on \C{nat}
\item Do not forget to mention \C{if .. then .. else}
\item Euclidean division, computation of prime factors, examples from
  elementary number theory
\item Examples of G{\"o}del-style encoding from the {\tt choice.v} library.
\item Examples/exercises about extended gcd (egcdn), which mix lists
  and arithmetic.
\end{itemize}
If possible give a few context to the exercises, in order not to bore
the reader not familiar with programming. For instance do not say that
you encode sequences of nats in nats but give a few hints about the
use of G{\"o}del encoding.

Examples and exercises can be executed in an empty context, or
libraries can be required for the purpose of (re)using and combine existing
programs (non proofs here).

The current contents are organized like the tutorial at ITP15 I gave (Enrico).
It was on standard Coq and was intended not to be difficult class ;-)
It is a possible plan, no strong opinions.

\section*{Things needed by chapter 2}
\begin{itemize}
\item type annotations on arguments of lemmas/definitions can be omitted
\item if then else
\item all boolean connectives: \C{orb andb negb implb xorb}
\item recursive programs: \C{addn muln subn leq eqn expn dvdn}
\item notations with associativity: \C{+ * - == != .+1 < <= \%| \~\~}
\end{itemize}


\section{Functional programming in a nutshell}
Only intuitions here.

For a mathematician this is perfectly natural, the main problem is the syntax.  E.g.
$$f(x) = x * 2\qquad\qquad f(7)$$
here we define a function named f that doubles its input.  Then we denote f(7) the value of f
when the input is 7. The novelty is that:
\begin{enumerate}
\item functions are anonymous, and the names. \verb+(fun x => x * 2)+ is the function that
	doubles.  We can name it: \verb+Definition f := fun x => x * 2.+.  We don't need to
	name a function in order to use it in an expression. (there is something like
	\verb+x |-> x * 2+, but this is always attached to a name somehow).
\item function application is \verb+(f 7)+.
\end{enumerate}

For a computer scientist used to imperative languages, these are the main weird points:
\begin{enumerate}
\item there is no return statement, AKA expressions are already programs.  e.g.
	4 is a program, and 2+2 as well.  Programs then evaluate like a mathematical expression
	can be simplified
\begin{verbatim}
        if (false || true) then 2 + 2 else 7
        if true then 2 + 2 else 7
        2 + 2
        4
\end{verbatim}
also
\begin{verbatim}
        2 + (if 7 == 2 then 4 else 2)
        2 + (if false then 4 else 2)
        2 + 2
        4
\end{verbatim}
\item programs are really first class data (HO programming, not reasonably popular even outside
	the functional world). E.g.
    This program takes in input a function f and uses it twice
\begin{verbatim}
      (fun f => f 3 + f 4)
\end{verbatim}
hence this is a valid program computing 14
\begin{verbatim}
      (fun f => f 3 + f 4) (fun x => x + x)
\end{verbatim}
\end{enumerate}


\subsection{Build and destruct simple data}
Simplest data is bool.

\begin{coq}{name=bool}{}
Inductive bool : Type := true | false.
Check bool : Type.
Check true : bool.
Check false.
Check 3 : bool. (* boom *)
\end{coq}

This tells you that one can construct a boolean using true or false but not a number.
Types tells you how your values are (in normal form, since (true || false) is also of type bool, recall the example before).
Hence it makes sense to consider only true and false when one inspects a bool.

\begin{coq}{name=negb}{}
Definition negb (b : bool) : bool :=
  match b with
  | true => false
  | false => true
  end.

Check negb.
Check negb true.
Check negb (negb true).
Check negb 3. (* boom *)

Eval compute in negb true.
Eval compute in negb false.
\end{coq}
We see the function type (arrow) and how typing works in this simple case.
Also that functions compute in Coq.
Sugar:

\begin{coq}{name=negb}{}
Definition another_negb (b : bool) : bool :=
  if b then false else true.
Definition yet_another_negb :=
  (fun b : bool =>
      if b then false else true).
Definition andb (b1 : bool) (b2 : bool) :=
  if b1 then b2 else false.
Notation "x && y" := (andb x y).
Eval compute in true && false.
Eval compute in true && true.
\end{coq}

\subsection{Polymorphic containers and binding in match}

This is not the syntax used in ssr I guess.

\begin{coq}{name=option}{}
 Inductive option (A : Type) : Type :=
 | None
 | Some (a : A).
Check option.
Check option bool : Type.
Check Some true. (* Implicit argument *)
\end{coq}

Talk about implicit arguments here.

\begin{coq}{name=implicits}{}
About Some.
(* The @ locally disables the implicit arguments *)
Check @Some bool true.
Check @Some _ true.
\end{coq}

Inspecting a container

\begin{coq}{name=matchopt}{}
Definition is_empty A (box : option A) : bool :=
  match box with
  | None => true
  | Some _ => false  (* Here _ means discard the little a *)
  end.
Eval compute in is_empty None.
Eval compute in is_empty (Some true).
(* Note: the function is polymorphic! *)
Eval compute in is_empty (Some 4).
\end{coq}

Two words about polymorphism.

Now binding in a match.

\begin{coq}{name=matchopt2}{}
Definition get_default A (box: option A) (a : A) : A :=
  match box with
  | None => a
  | Some x => x  (* this x is a name on the left bound to the contents *)
  end.

Eval compute in get_default None 3.
Eval compute in get_default (Some 4) 3.
\end{coq}

More containers

\begin{coq}{name=pair}{}
 Inductive prod (A B : Type) : Type :=
 | pair (a : A) (b : B).

 Notation "A * B" := (prod A B).
 Notation "( a , b )" := (pair a b).

Check (true, Some false).

Definition fst A B (p : A * B) :=
  match p with
  | ( x , _ ) => x
  end.

Eval compute in fst (true, None).

Definition snd A B (p : A * B) :=
  match p with (_, y) => y end.
\end{coq}

\subsection{Recursive data}

Nat, with a special syntactic sugar

\begin{coq}{name=nat}{}
   Inductive nat : Type :=
   | O
   | S (n : nat).

Check S (S O).
Check 2.
Check 1.
\end{coq}

Recursive functions

\begin{coq}{name=plus}{}
Fixpoint plus (n : nat) (m : nat) : nat :=
  match n with
  | O => m
  | S w => S (plus w m)
  end.
Infix "+" := plus.

Check 2 + 3.
Eval compute in 2 + 3.
\end{coq}

execution step by step

\begin{coq}{name=execplus}{}
   S (S 0) + 3
   S ((S O) + 3)
   S (S (O + 3))
   S (S 3)
   5
\end{coq}

Here I was also showing

\begin{coq}{name=plusrec}{}
Fixpoint fast_plus (n : nat) (m : nat) : nat :=
  match n with
  | O => m
  | S w => fast_plus w (S m)
  end.

    S (S O) + 3
    S O + 4
    O + 5
    5
\end{coq}

and making the point that reasoning about these two plus is not equally easy (short parenthesis on symbolic computation).

\begin{coq}{name=plusrec}{}
Eval simpl in
  (fun n => fast_plus (S n) 3).  (* no progress *)
Eval simpl in
  (fun n => plus (S n) 3).  (* some output already, we can prove that it is not 0 *)
\end{coq}

Lists

\begin{coq}{name=list}{}
Inductive list (A : Type) : Type :=
| nil
| cons (x : A) (xs : list A).

Infix "::" := cons.
Arguments nil {A}.
Arguments cons {A} x xs.

(* The type of lists imposes all the elements to
    be in the same type! *)
Check true :: false :: nil.
Fail Check 1 :: false :: nil.

(* A non recursive function on lists *)
Definition tl A (l : list A) : list A :=
  match l with
  | nil => nil
  | _ :: xs => xs
  end.

Eval compute in tl (6 :: 99 :: nil).

(* The most popular function on lists *)
Fixpoint len A (l : list A) : nat :=
  match l with
  | nil => O
  | x :: xs => 1 + (len xs)
  end.

Eval compute in len (1 :: 2 :: 3 :: nil).
Fixpoint split A B (l : list (A * B)) : list A * list B :=
  match l with
  | nil => (nil, nil)
  | (x,y) :: rest =>
      let xs_ys := split rest in
      (x :: fst xs_ys, y :: snd xs_ys)
  end.

Eval compute in
  split ((1,2) :: (3,4) :: nil).

Fixpoint zip A B (la : list A) (lb : list B) : list (A * B) :=
  match la, lb with
  | nil, nil => nil
  | x::xs, y::ys => (x,y) :: zip xs ys
  | _, _ => nil
  end.

Eval compute in
  zip (1 :: 2 :: nil) (true :: false :: nil).

Eval compute in
  let xs_ys := split ((1,2) :: (3,4) :: nil) in
  zip (fst xs_ys) (snd xs_ys).
\end{coq}

\subsection{termination}

Here we say how termination is checked, which are the alternative when the
heuristic fails (not very relevant for mathcomp I guess) and relate that to
logical inconsistency (maybe too early here, needs curry howard).

\begin{coq}{name=paradoxes}{}
Fail
Fixpoint wrong A (l : list A) {struct l} :=
  match l with
  | nil => 0
  | x :: xs => 1 + wrong (x :: nil)
  end.

Fixpoint loop (n : nat) : False := loop n.

Check loop 3.
Fail Timeout 2 Eval compute in loop 3.
\end{coq}

Also data must be checked.

\begin{coq}{name=paradoxes2}{}
Inductive non_positive : Type :=
| Call (f : non_positive -> False)

Definition self (t : non_positive) : False :=
  match t with
  | Call f => f t
  end.

Definition loop2 : False := self (Call self).

Fail Timeout 2 Eval compute in loop2.
\end{coq}

\subsection{HO programming}

A function can be abstracted over another
   function.  It is a useful mechanism to write
   code that can be reused, especially in the context
   of polymorphic containers.

\begin{coq}{name=map}{}
Fixpoint map A B (f : A -> B) (l : list A) : list B :=
  match l with
  | nil => nil
  | x :: xs => f x :: map f xs
  end.

Eval compute in
  map (fun x => x + 2) (3 :: 4 :: 7 :: nil).
Eval compute in
  map negb (true :: false :: nil).

(* fold f (x1 :: x2 :: .. xn :: nil) a
     =
            (f xn (.. (f x2 (f x1 a))))
*)
Fixpoint fold A B (f : B -> A -> A) (l : list B) (a : A) : A :=
  match l with
  | nil => a
  | x :: xs => fold f xs (f x a)
  end.

(* what does this do? *)
Eval compute in fold cons (1 :: 2 :: 3 :: nil) nil.
\end{coq}

Here one could use a section for A B and talk about all that.

\section{old contents (before Enrico's tutorial)}

Do use \C{About} for informations (not \C{Check}).
\begin{coq}{name=beta}{}
Eval beta in (fun x => x + x) 3. (* 3 + 3 : nat *)
Definition f := fun x : nat => x + x.
Definition f (x : nat) := x + x.
About f : nat -> nat.
\end{coq}

TODO: "beta" alone is not a reduction tactic, but we could add it.

maybe also talk about delta here and make example of f.

\subsection{Inductive data, case analysis and recursion}
bool, nat.

\begin{coq}{name=ind-data}{}
Inductive bool : Type := true | false.
Inductive nat :Type := O | S of nat.
Check true : bool : Type. (* on a side note .. : Type : Type *)
Check (S (S O)). (* 2 : nat *)
\end{coq}




match, fix, termination.

\begin{coq}{name=bool-conn}{}
Definition andb := ...
Fixpoint addn := ..
Fixpoint eq_nat
Fixpoint leq
\end{coq}

discuss example of a real computation, not just beta.

\begin{coq}{name=compute}{}
Compute (addn 3 4)
\end{coq}

now simple notation come in to play

\begin{coq}{name=notation-infix}{}
Infix "+" := addn.
\end{coq}

\subsection{Polymorphism and HO programming}
option, seq, pairs.

\begin{coq}{name=option}{}
Inductive option A := None | Some of A.
Check option. (* Type -> Type *)
Check Some. (* : forall A : Type, A -> option A *)
Fixpoint map A B (f : A -> B) := ...
Fixpoint eq_seq A (eq_A : A -> A -> bool) l := ...
\end{coq}

polymorphism as in F

may be also examples of polymorphisms that can be defined in pure
$\lambda$-calculus (identity, argument swaping).

\section{programming in Coq}
this contains real programs, and is the excuse to talk about:

\subsection{Sections}
and Implicit Type, to factor the type parameter of containers like
sequences.  Write more stupid programs on seq.

\begin{coq}{name=seq}{}
Section Seq.
Variable A : Type.
Variable x0 : A.
Implicit Type l : seq A.
...
Fixpoint fold f l := ...
Fixpoint rev l := ...
\end{coq}


\subsection{Implicit arguments}
to imitate polymorphism a-la ML, simplest example of type inference
like \C{Some _ 3}.  Set implicit for inductive types/constructors too,
and functions on them like the ones on seq we have seen before.

\begin{coq}{name=Arguments}{}
Arguments seq {T}.
Arguments nil {T}
Arguments cons {T} x xs.
About seq.
Check cons 3 nil.
(* we have notataions *)
Check [:: 3, 4 ].
Fixpoint size A l := ...
\end{coq}

About is bad because it mention names that are not necessarily displayed.
Maybe we should tell people to open the document and/or talk about Locate,
Print.  Or else use Search (that does all that) but in an empty
file, where no theorems pop up.

\subsection{Exercises (explained): arithmetic}
by now we should have the infrastructure to write program on arithmetic

\begin{coq}{name=stuff}{}
divn
prime  (* an simpler version *)
\end{coq}

from choice.v

\begin{coq}{name=smart}{}
encode
decode
\end{coq}
