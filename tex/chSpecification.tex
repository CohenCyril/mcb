\chapter{More statements, more proofs}{Advanced specifications}

in addition to the photos:
\begin{itemize}
\item talk about /= in 2 as a decorator for elim on a list (since arithmetics is all loked with nosimpl).
\item talk about nosimpl in 3.3, say that according to our experience simpl is not
always a good idea hence nosimpl.
\item good practice (3.3 or 3.4): state and prove the fixpoint unfolding/folding
equations.
\end{itemize}

\section{Type Theory}

\subsection{Curry-Howard correspondance for propositional logic}

In TT proofs are terms terms and statements are types.
In particular inductive data types like the ones we programmed with in
the previous chapters can be used to describe the usual logical
connectives and atomic predicates.

First, A -> B, then forall x : A, Bx.  \C{fun x : A => b} as the constructor
of the function space.

\begin{center}
\AxiomC{$A$}
\noLine
\UnaryInfC{$B$}
\RightLabel{$\to_I$}
\UnaryInfC{$A \to B$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$B$}
\RightLabel{$\forall_I$ ($x$ fresh)}
\UnaryInfC{$\forall x, B$}
\DisplayProof
\end{center}

For example the connective and is usually described by the introduction rule

\begin{center}
\AxiomC{$A$} \AxiomC{$B$}
\RightLabel{Conj}
\BinaryInfC{$A \wedge B$}
\DisplayProof
\end{center}

We call such rule Conj.  In Coq

\begin{coq}{name=And}{}
Inductive And (A B : Prop) : Prop :=
| Conj (pa : A) (pb : B)
\end{coq}

Here A and B are parameters ranging over logical propositions (Prop),
exactly as the rule above is a schema (on A and B). The single constructor
of And plays the role of the intro rule: to create a term of type And
you must use Conj, exactly as to Create a term of type A*B you must use
pair.  Indeed

\begin{coq}{name=And}{}
Infix "/\" := And.
About Conj : forall A B : Prop, A -> B -> A /\ B.
\end{coq}

Repeat that argument passing is like instantiation.

We have seen how to inspect pairs and extract the components. Given that
also the proofs of And are data we can do the same.

\begin{coq}{name=Ande1}{}
Definition elimAndleft A B (ab : A /\ B) : A :=
match ab with
| Conj a _ => a
end.
About elimAndleft : forall A B, A /\ B -> A.
\end{coq}

Pattern matching implements elimination

$$
\frac{A \wedge B}{A}elim\_left
$$

We do the same with Or.

What are tactics?  Tactics are commands that build proofs, hence
they construct terms.  E.g. \C{apply}, \C{case} on \C{nat},
\C{split}, \C{left}, \C{right}, for intro rules.  \C{case} tactic as
the only elim rule (for all inductives, since it is always a match).

A simple exercise to show "curryfication" and take that as an excuse
to prefer the curryfied form.

Inductives for \C{True}, \C{False} (elimination principle is ex falso
quod libet). Definition of \C{not}.

\subsection{Curry-Howard for quantifiers}
Dependent types and CH for forall.

CH for exists, like conj but dependent.

\begin{coq}{name=Ex}{}
Inductive Ex A (P : A -> Prop) : Prop :=
| exI (a : A) (pa : P a).
About exI.
\end{coq}

\begin{itemize}
\item Again \C{case} as the eliminator and the  \C{exists} tactic.

\item Her come the more complex the explaination of \C{=>} and
\C{:}. Warning the \C{:} of \C{apply:} is of a different nature (but
not the one of \C{apply/view:})...

\item General intro patterns: casing brackets \C{[]}, \C{/(_ x), ->, _}
\end{itemize}

\subsection{Curry-Howard correspondance for inductive reasoning}

CH: how to inhabit the type of induction on nat.
elim applies such principle.
\begin{itemize}
\item  This is recursive programming.
\item Mention case analysis as match.
\item Complex \C{elim} like \C{elim: {2}n (leqnn n)}.
\end{itemize}
\subsection{Constructivism}

TT is constructive.  As for nat and bool the \emph{only} way
to ... also for proposition. Eg. exists can only be proved
by exhibiting the witness and a proof that is satisfies the predicate.

It is pretty clear that our proofs are programs, we used match and fix
to prove exactly as we used them to program.

\section{Boolean reasoning, \C{Prop} reasoning, going back and forth}

\begin{itemize}
\item Comparison between \C{bool} and \C{Prop} (the usual diagram,
  cf. slides)
\item Boolean reflection.
\item We want to navigate bewteen the possible representations of a
  statements.
\item \C{is_true} coercion, which gives the illusion of inhabiting a \C{bool}
\item \C{reflect} as the specialized ``if and only if'' equivalence
  relation (the real definition comes in section 4, as a spec
  inductive. Plus we need more to explain it is in Type and talk about
  \C{insub}
\item The litany of lemmas needed ($\Leftarrow$, $\Rightarrow$,
  negations, etc (these are the hint views in fact).
\item This goind back and forth is going to happen all the time, so we
  need infrastructure to save us the bureaucracy: this is the view
  mechanism.
\item Hint views remove the names of the lemmas in the previous
  litany, slash removes the name of the tactic applying the view.
\item Use of views: in intro patterns (like in \C{=> /v [-> ]}), in
  \C{case/view: t}.
\item Proving views (\C{apply/v1/v2}, \C{iffP}, ...)

\end{itemize}


% It is the fragment of decidable stuff (EM as case).
% It is a concrete data type on which you can program (SSR), automation by
% computation.

% % \begin{coq}{name=Ex}{}
% % Lemma muln_eq0 m n :
% %   ((m * n = 0) -> (m = 0) \/ (n = 0)) /\
% %   ((m = 0) \/ (n = 0) -> (m * n = 0))
% % Proof.
% % Qed.
% %
% % Lemma leq_mul2l m n1 n2 :
% %   (m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
% % Proof.
% % Qed.
% % \end{coq}



% \begin{coq}{name=Ex}{}
% Lemma leq0n n : (0 <= n) (* = true *).
% \end{coq}

% NOt everything can be in bool, e.g. exists or a real reasoning by cases
% on a disjunction. Inductives give you the tree structure in natural
% deduction, not bools.

% \begin{coq}{name=Ex}{}
% Lemma ...
% case/orbP : (leq_total n m)
% \end{coq}

% We need lemmas to relate

% \begin{coq}{name=Meaning of reflect}{}
% Definition reflect P b : Prop :=  b -> P /\ P -> b

% Lemma orbP p q : reflect (p \/ q) (p || q).
% \end{coq}

% so frequent and so many variations that we have proper infrastructure like
% being able to invoke views everywhere and have 1 view per connective (negate or
% not...).

% \begin{coq}{}{}
% Lemma introT  : P -> b.            Proof using Pb. exact: introTF true _. Qed.
% Lemma introF  : ~ P -> b = false.  Proof using Pb. exact: introTF false _. Qed.
% Lemma introN  : ~ P -> ~~ b.       Proof using Pb. exact: introNTF true _. Qed.
% Lemma introNf : P -> ~~ b = false. Proof using Pb. exact: introNTF false _. Qed.
% Lemma introTn : ~ P -> b'.         Proof using Pb'. exact: introTFn true _. Qed.
% Lemma introFn : P -> b' = false.   Proof using Pb'. exact: introTFn false _. Qed.
% \end{coq}

% \subsection{how to use reflect lemmas as tactic decorators}

% we make examples with andP orP negP in move/P, apply/P, case/P.

% we explain the hint view, plus the extra impl arguments.

% some view can be partial, A -> B -> reflect B c.

% \subsubsection{The view mechanism in intro pattern}

%   a == b \&\& bb

% views applied to top, inline destructuring and subst:
%   => /andP[/eqP-> pb] ->.

\section{Structuring proofs}

May be a real 10 lines proofs would help here. Lemmas about Euclidean
division?
 \begin{itemize}
\item Proofs have a structure, to ensure readability (in a certain
  sense) and maintenance; we list here some tools and good practice.
\item Declare intermediate steps: forward (\C{have}), backward
  (\C{suff}), symmetries (\C{gen have} and mention \C{wlog}),
abbreviations \C{set}
\item: Punctuation to help the reader: bullets, indentation,
  terminating tactics.
\item Good practices: local/early error detection, checkpoints via
  \C{have}, naming policies (lemmas, but also hypotheses and bound
  variables), robust rewrite.
\end{itemize}

% Fwd and backward declarative steps.
% have : P x := ... H ...
% suff.

% Handling symmetries:
% gen have: x Hx / P x.

% managing large goals and contexts: set, -/x /x

% help the reader with typographical comments, like leaving an empty
% line in latex (here we use bullets).

Not everything needs to be a tactic, the logic is powerful
enough to express special connectives that induce a line of
reasoning. Hence the next section.

\section{Advanced statements}

\begin{itemize}
\item Use macros (\C{left_commutative} or notations like
\C{\{in A, bijective f\}}, and3, ...)
\item Use naming conventions
\item Classically (do not insist too much)
\item iff (\C{AGM}): find examples?
\item Tuning of implicit arguments
\item Spec lemmas in order: to implement the most appropriate
  branching, to chose the extra hypotheses (like equations) that pop
  up in each branch, to have automatic substitution (via
  indexes). Explain (finally) the \C{reflect} predicate in the light
  of these. But we cannot yet explain sort \C{Type}.

\end{itemize}

\section{STOP HERE}

THIS CHAPTER IS ABOUT METHODOLOGY, plus introduces the other logical
connectives. May be merged into the previous chapter.


% Where one learns to do proofs.
% Boolean reflection in practice, views, discussion on the definition of leq,
% proofs on things defined in the
% previous chapter, associated tactics, exercises on prime, div,
% binomial, etc.
%
% spec? A new vernacular to declare specs without typing coinductive and
% by writing explicitly the equations.

Discussion prop/bool, intuitionism, extraction (we should be able to
avoid talking about impredicativity, but use Prop for computationally
irrelevant).


\begin{itemize}
\item can we specify all we have written so far using just = and forall? No.
	Example dvdn needs exists to be specified
\item exists, and, or, neg, False, True as inductives (again CH style)
\item related tactics: split, left, right,exists,case
\end{itemize}

Anyway to take advantage of computation (ssr style) we want to
work with bool as much as possible:

\begin{itemize}
\item reflect is the right way to write iff, <->, specialized to bool
	so that the proof language recognizes it and offer a bit more ergonomic
\item is-true
\item infrastructure for reflect: iffp, altp
\item no split if goal is \&\& (metodology)
\end{itemize}

Writing good statements

\begin{itemize}
\item = as iff for bool, because rewrite is easy to use
\item and3p, spec (drive your proof),
\item advanced stuff: classically P instead of not-not P (can be
  skipped for beginners)
\item in general good quantifications and implicit arguments and good library
	makes it possible to work without evars
\item . \C{<=} . ?= iff .
\end{itemize}

Statements do also occur in the middle of proofs.  There we have many ways to
write them compactly, wlog and have.

Comparison with other possible ways of writing properties:
\begin{itemize}
\item impact of le v.s. leq in a proof
\end{itemize}

In this chapter we should distill a description of our
systematic-reactions, reflexes, to typical situations a
beginner would screw up. In fact it would be great to explain here the
mix of Gallina (unless, classically, etc.) and of tactics (wlog,
have,...) that lead to a convenient modelling of the math prose.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEARN{Declaring implicit arguments}
\mcbREQUIRE{Canonical}
\mcbPROVIDE{stating lemmas}
\mcbLEVEL{2}
\mcbsection{Declaring implicit arguments}\label{sec:declaringimpl}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

here we describe how to choose which arguments are implicit,
that one has to think ahead how  a lemma is used and hence
which data type inference has at hand.  Also that the order
of quantifiers is relevant.
\begin{itemize}
\item lemmas: fwd/backward reasoning
\item equations, look at the concl too, free vars are abstracted
\item compare with eapply style
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEARN{Coercions}
\mcbREQUIRE{}
\mcbPROVIDE{}
\mcbLEVEL{1}
\mcbsection{Notational aspects of specifications}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Even if the main way to extend the type inference algorithm
% is via Canonical Structures, another mechanism is available
% and used all over the library, even if it plays a minor role.
% The language of Canonical Structures lets one program how the value of
% an implicit argument can be synthesized, but can hardly be used to
% explain \Coq{} how to ``fix'' an ill-typed term written by the user.

When a typing error arises, it always involves three objects:
a term \lstinline/t/, its type \lstinline/ity/ and the type
expected by its context \lstinline/ety/.  Of course, for this
situation to be an error, the two types \lstinline/ity/ and
\lstinline/ety/ do not compare as equal.
The simplest way one has to explain \Coq{} how to fix \lstinline/t/,
is to provide a functional term \lstinline/c/ of type
\lstinline/(ity -> ety)/ that is inserted around \lstinline/t/.
In other words, whenever the user writes \lstinline/t/ in a context
that expects a term of type \lstinline/ety/, the system instead of
raising an errors replaces \lstinline/t/ by \lstinline/(c t)/.

A function automatically inserted by \Coq{} to prevent a type
error is called \emph{coercion}.
The most pervasive coercion in the \mcbMC{} library is
\lstinline/is_true/ that lets one write statements using boolean
predicates.\marginnote{I guess in a way or another is true has
already been introduced}.

\begin{coqdef}{name=istrue}
Lemma example : prime 17.
Proof.
Set Printing Coercions. Redirect "g1" Show.
by [].
Qed.
\end{coqdef}
\begin{coq}{def=istrue}{title=Coercion \lstinline/is_true/,width=6cm}
Lemma example : prime 17.
Proof.  by [].  Qed.
\end{coq}
\coqrun{name=r3}{ssr,istrue}
\begin{coqout}{run=r3;out=g1}{title=Goal after line 3,width=6cm}
1 subgoal

============================
is_true (prime 17)
\end{coqout}

The statement of the example is processed by type inference,
it is enforced to be a type, but \lstinline/(prime 27)/ is actually
a term of type \lstinline/bool/.  Early in the library the
function \lstinline/is_true/ is declared as a coercion from
\lstinline/bool/ to \lstinline/Prop/ and hence is it inserted
by \Coq{} automatically.

\begin{coq}{name=istruedef}{}
Definition is_true b := b = true.
Coercion is_true : bool >-> Sortclass. (* Prop *)
\end{coq}

Another coercion that is widely used injects booleans into naturals.
Two examples follow.
\marginnote{Mention Kronecker delta as a math example of the same hack}

\begin{coq}{name=natofbool}{}
Variable T : eqType.
Fixpoint count (a : pred T) (s : seq T) :=
  if s is x :: s' then a x + count a s' else 0.
Lemma count_uniq_mem (s : seq T) x :
  uniq s -> count_mem x s = (x \in s).
\end{coq}
\coqrun{name=ex}{ssr,istruedef,natofbool,abort}

In line number 2 the term \lstinline/(a x)/ is a boolean.  The
\lstinline/nat_of_bool/ function is automatically inserted to turn
\lstinline/true/ into 1 and \lstinline/false/ into \lstinline/0/.
Similarly, in the last line the membership test is turned into
a number, that is shown to be equivalent to the count of any
element in a list that is duplicate free.

Another example of a coercion that is related to the running example
of the current chapter is \lstinline/sort/.  Typically the projection
of a record type extracting the data type is declared as a coercion
letting one state generic theorems like in the following example.

\begin{coqdef}{name=sotc}
Lemma example (e : eqType) : forall x y : e, x == y -> y == x.
\end{coqdef}
\begin{coq}{def=sotc}{}
Lemma example (e : eqType) : forall x y : e, x == y -> ...
\end{coq}
\coqrun{name=r5}{ssr,sotc,abort}

Here the type of \lstinline/x/ and \lstinline/y/ is
\lstinline/(sort e)/ and not \lstinline/e/ as the user initially wrote.
Indeed \lstinline/e/ is a term (of type \lstinline/eqType/) while
the \lstinline/forall/ quantification expects a type after the
colon.  The \lstinline/sort/ function mapping an \lstinline/eqType/
into a \lstinline/Type/ is inserted automatically.

Coercions are composed transitively.

\begin{coq}{name=b2z}{}
Definition zerolist n := mkseq (fun _ => 0) n.
Coercion zerolist : nat >-> seq.
Check 2 :: true == [:: 2; 0].
\end{coq}
\coqrun{name=r6}{ssr,b2z}

For the convenience of the reader we list here the most widely
used coercions. there are also a bunch on Funclass not listed
and elimT surely deserves some explanation.

\noindent
\begin{tcolorbox}[colframe=blue!60!white,before=\hfill,after=\hfill,center
	title,tabularx={l|l|l},fonttitle=\sffamily\bfseries,title=Coercions]
coercion & source & target \\ \hline
\lstinline/Posz/ & \lstinline/nat/ & \lstinline/int/ \\
\lstinline/nat_of_bool/ & \lstinline/bool/ & \lstinline/nat/ \\
\lstinline/elimT/ & \lstinline/reflect/ & \lstinline/Funclass/ \\
\lstinline/isSome/ & \lstinline/option/ & \lstinline/bool/ \\
\lstinline/is_true/ & \lstinline/bool/ & \lstinline/Sortclass/ \\
\hline
\end{tcolorbox}

\marginnote{This may go in Chapter 1}
Another device that is used to help type inference is the
\lstinline/Implicit Types/ directive.  This directive lets
one attach a default type to variable names.

\begin{coq}{name=itype}{title=Example of \lstinline/Implicit Types/}
Implicit Types m n : nat.
Check forall m n, n == m.
\end{coq}
\coqrun{name=r7}{ssr,itype}

In the example above the statement we \lstinline/Check/ does not
contain enough information alone to be well types.  The overloaded
\lstinline/==/ notation needs the terms to which it is applied to
have a type for which a \lstinline/Canonical Structure/ is declared.
Even if we did not annotate \lstinline/n/ and \lstinline/m/ with a
type, the directive on the first line does it for us.

The reader already familiar with the concept of coercion
may find the presentation of this chapter nonstandard.
Indeed coercions are usually presented as a device to model
subtyping in a theory that, like \mcbCIC{}, does not
feature subtyping.  As we will see in Chapter~\ref{ch:hierarchy}
the role played by coercions is in the modelling of the hierarchy
of algrabraic structure is minor.  Indeed what is hard is not to
forget some fields of a structure to obtain a simpler one.  What
is hard is to reconstruct the missing fields of a structure
or compare two structures finding the minimum super structure.
These tasks are mainly implemented using canonical structures.

