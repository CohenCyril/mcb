% vim:set tw=70:
% vim:set spell:
% vim:set errorformat="":
\begin{coqdef}{name=ssr}
Require Import Ssreflect.ssreflect.
From Ssreflect Require Import ssrfun ssrbool ssrnat eqtype fintype seq div prime.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.
Set Asymmetric Patterns.
\end{coqdef}
\begin{coqdef}{name=abort}
Abort.
\end{coqdef}
\begin{coqdef}{name=show1}
Redirect "g1" Show.
\end{coqdef}
\begin{coqdef}{name=require-tuple}
Require Import tuple.
\end{coqdef}

\Chapter{Sub-Types}{Terms with properties}\label{ch:sigmabool}

Inductive data types have been used to both code data, like lists, and
logical connectives, like and.  Properties were always expressed with
boolean programs.  The questions addressed in this chapter are the
following ones.  What
stuts do we want to give to, say, lists of size 5,  or integers
smaller than 7?  Which relation to put between integrs and
integers smaller than 7.  How to benefit from extra properties
integers smaller than 7 have, like being a finite collection?

In standard mathematics one would simple say that the integers are an
infinite set (called \C{nat}), and that the integers smaller that 7
form a finite subset of the integers (called \C{'I_7}).  Integers and
integers smaller than 7 are interchangeable data: if \C{(n : nat)} and
\C{(i : 'I_7)} one can clearly add \C{n} to \C{i}, and eventually show
that the sum is still smaller than 7.  Also, an informed reader
knows which operations are compatible with a subset. E.g. \C{(i-1)}
stays in \C{'I_7}, as well as \C{(i+n \%| 7)}.  So in a sense, subsets
also provide a linguistic construct to ask the reader to track an
easy invariant and relieving the proof text from boring details.

The closest notion provided by the \mcbCIC{} is the one of $\Sigma-$types,
i.e. records.  One can define the type \C{'I_7} as $\Sigma_{(n:nat)} n
\leq 7.$  Indeed proofs are terms, so one can 
pack together objects and proofs of some properties to
represent the objects that have those properties.  For example $3$
when seen as an inhabitant of \C{'I_7} is represented by a dependent
pair \C{(3, p)} where \C{(p : 3 <= 7)}.  Note that by forgetting the
proof \C{p} one recovers a \C{nat} that can be passed to, say, the
program computing the addition of natural numbers, or to theorems
quantified on any \C{nat}.  Also, an inhabitant of \C{'I_7} can always
be proved smaller than 7, since such evidence is part of the
object itself.
We call this construction a \emph{sub-type}.

Such representation can be expensive in the sense that it imposes
extra work (proofs!) to create a sub-type object, so it must be used
with care.  The \mcbMC{} library provides several facilities that
support the creation of record-based sub-types, and of their
inhabitants.  We shall in particular see how both type inference and
dynamic tests can be used to supply the property proofs, modelling
once again the eye of a trained reader.

Finally, let us point out that we have already encountered proof-carrying
records in the previous chapter, with \C{eqType}.
The \C{eqType} record played the role of an interface,
expressing a relation between a type and a function (the comparison operation),
and giving to access a whole theory of results through type inference.
Many such interfaces can be extended to sub-types, and we shall see that
the \mcbMC{} library provides facilities to automate this.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbLEARN{}
\mcbREQUIRE{eqtype, fintype, CS}
\mcbPROVIDE{tuple}
\mcbNOTES{}
\mcbsection{$n$-tuples, lists with an invariant on the length}

We begin by defining the type of $n$-tuples: sequences of length $n$.
In this section we focus on how tuples are defined, used as regular
sequences and how to program type inference to track for us the
invariant on tuples' length.  Next section will complete the
definition of the tuple sub-type by making the abstract theory
attached to the \C{eqType} interface available on tuples whenver it is
available on sequences.

A tuple is a sequence of values (of the same type) whose length is
made explicit in the type.

\begin{coq}{name=tupx}{width=\textwidth,title=Tuple sub-type of seq}
Structure tuple_of n T :=  Tuple { tval :> seq T; _ : size tval == n }.
Notation "n .-tuple T" := (tuple_of n T) (at level 2).
\end{coq}
\coqrun{name=r1}{ssr,tupx}

% Recall that the statement \lstinline/(size tval == n)/
% is the argument of a hidden \lstinline/is_true/ coercion.
% If we unfold its definition we clearly see that the statement
% is an equality on \lstinline/bool/.

The key property of this type is that it tells us the length of its
elements when seen as sequences:

\begin{coq}{name=sizetup}{}
Coercion tval : tuple_of >-> seq.
Lemma size_tuple {T n} (t : n.-tuple T) : size t = n.
Proof. by case: t => s /eqP. Qed.
\end{coq}
\coqrun{name=r2}{ssr,tup,sizetup}

In other words each inhabitant of the tuple type carries,
in the form of an equality proof, its length.  As test bench
we pick this simple example: a tuple is processed using
functions defined on sequences, namely \lstinline/rev/ and
\lstinline/map/.  These operations do preserve the invariant of
tuples, i.e. they don't alter the length of the subjacent list.

\begin{coq}{name=p1}{}
Example seq_on_tuple n (t : n.-tuple nat) :
  size (rev [seq 2 * x | x <- rev t]) = size t.
\end{coq}

There are two ways to prove that lemma.  The first one is
to ignore the fact that \lstinline/t/ is a tuple, consider it
as a regular sequence, and use only the theory of sequences.

\begin{coq}{name=p2}{}
Proof. by rewrite map_rev revK size_map. Qed.
\end{coq}
\coqrun{name=r3}{ssr,tup,sizetup,p1,p2}

Mapping a function over the reverse of a list, it equivalent to
first map the function over the list and then reverse the result
(\lstinline/map_rev/).  Then, reversing twice a list is a no-op, since
\lstinline/rev/ is an involution
(\lstinline/revK/).  Finally, mapping a function over a list does not
change its size (\lstinline/size_map/).  The sequence of rewritings
make the left hand side of the conjecture identical to the right hand
side, and we can conclude.

This simple example shows that the theory of sequences is usable
on terms of type tuple.  Still we didn't take any advantage of
the fact that  \lstinline/t/ is a tuple.

The second way to prove this theorem is to rely on the rich type
of \lstinline/t/ to actually compute the length of the underlying 
sequence.

\begin{coq}{name=p3}{}
Example just_tuple_attempt n (t : n.-tuple nat) :
  size (rev [seq 2 * x | x <- rev t]) = size t.
Proof. rewrite size_tuple.
\end{coq}
\coqrun{name=r4;fail}{ssr,tup,sizetup,p3,show1}
\begin{coqout}{run=r4;out=g1}{}
1 subgoal

 n : nat
 t : n .-tuple nat
 ============================
 size (rev [seq 2 * x | x <- rev t]) = n
\end{coqout}

The rewriting replaces the right hand side with \lstinline/n/ as
expected, but we can't go any further: the lemma does not
apply (yet) the left hand side, even if we are working
with a tuple \lstinline/t/.  Why is that?  In the left hand side
\lstinline/t/ is processed using functions on sequences.
The type of \lstinline/rev/ for example is
\lstinline/(forall T, seq T -> seq T)/.  The coercion \lstinline/tval/
from \lstinline/tuple_of/ to \lstinline/seq/ make the
expression \lstinline/(rev (tval t))/ well typed, but the output
is of type \lstinline/(seq nat)/.  
We would like the functions on sequences to return
data as rich as the one taken in input, i.e. preserve the invariant
expressed by the tuple type.  Or, alternative, we would like the
system to recover such information.

Let us examine what happens if try to unify the left hand side of the
\lstinline/size_tuple/ equation with the redex
\lstinline/(rev t)/, using the following toolkit:

\begin{coq}{name=infrastructure}{title= Unification debugging toolkit}
(* toolkit *)
Notation "X (*...*)" :=
  (let x := X in let y := _ in x)   (at level 100, format "X  (*...*)").
Notation "[LHS 'of' equation ]" :=
  (let LHS := _ in
   let _infer_LHS := equation : LHS = _ in LHS)   (at level 4).
Notation "[unify X 'with' Y ]" :=
  (let unification := erefl _ : X = Y in True).
\end{coq}

We can now simulate the unification problem
encountered by \lstinline/rewrite size_tuple/

\begin{coq}{name=showunif}{}
Check forall T n (t : n.-tuple T),
 let LHS := [LHS of size_tuple _] in
 let RDX := size (rev t) in
 [unify LHS with RDX].
\end{coq}

The corresponding error message is the following one:

\coqrun{name=r5;fail}{ssr,tup,sizetup,infrastructure,showunif}
\begin{coqout}{run=r5}{title=Response}
Error:
In environment
T : Type
n : nat
t : n .-tuple T
LHS := size (tval ?94 ?92 ?96) (*...*) : nat
RDX := size (rev (tval n T t))           : nat
The term "erefl ?95" has type "?95 = ?95" while
it is expected to have type "LHS = RDX".
\end{coqout}

Unifying \lstinline/(size (tval ?$_n$ ?$_T$ ?$_t$))/
with \lstinline/(size (rev (tval n T t)))/ is hard.
Both term's head symbol is \lstinline/size/, but then
the projection \lstinline/tval/ applied to unification
variables has to be unified with \lstinline/(rev ...)/,
and both terms are in normal form.

Such problem is nontrivial because to solve it one has to infer a
record for \lstinline/?$_t$/ that contains a proof: a
tuple whose \lstinline/tval/ field
is \lstinline/rev t/ (and whose other field contains a
proof that such sequence has length \lstinline/?$_n$/).

We have seen in the previous chapter that this is exactly the class of
problems that is addressed by canonical structure instances.
We can thus use \C{Canonical} declarations to teach Coq
the effect of list operations on the length of their input.

\begin{coq}{name=t1}{width=13cm}
Lemma rev_tupleP n A (t : n.-tuple A) : size (rev t) == n.
Proof. by rewrite size_rev size_tuple. Qed.
Canonical rev_tuple n A (t : n.-tuple A) := Tuple (rev_tupleP t).

Lemma map_tupleP n A B (f: A -> B) (t: n.-tuple A) : size (map f t) == n.
Proof. by rewrite size_map size_tuple. Qed.
Canonical map_tuple n A B (f: A -> B) (t: n.-tuple A) := Tuple (map_tupleP f t).
\end{coq}

Even if it is not needed for the lemma we took as our test bench,
we add another example where the length is not preserved.

\begin{coq}{name=t2}{}
Lemma cons_tupleP n A (t : n.-tuple A) x : size (x :: t) == n.+1.
Proof. by rewrite /= size_tuple. Qed.
Canonical cons_tuple n A x (t : n.-tuple A) : n.+1 .-tuple A :=
  Tuple (cons_tupleP t x).
\end{coq}

The global table of canonical solutions is extended as follows.

\noindent
\begin{tcolorbox}[colframe=blue!60!white,before=\hfill,after=\hfill,center title,tabularx={ll|l|l},fonttitle=\sffamily\bfseries,title=Canonical Structures Index]
projection & value & solution & combines solutions for \\ \hline
\lstinline/tval N A/ & \lstinline/rev A S/ & \lstinline/rev_tuple N A T/
	& \lstinline/T/ $\leftarrow$ (\lstinline/tval N A/, \lstinline/S/) \\
\lstinline/tval N B/ & \lstinline/map A B F S/ & \lstinline/map_tuple N A B F T/
	& \lstinline/T/ $\leftarrow$ (\lstinline/tval N A/, \lstinline/S/) \\
\lstinline/tval N.+1 A/ & \lstinline/X :: S/ & \lstinline/cons_tuple N A T X/
	& \lstinline/T/ $\leftarrow$ (\lstinline/tval N A/, \lstinline/S/) \\
\end{tcolorbox}

Thanks to the now extended capability of type inference
we can prove our lemma by just reasoning about tuples.

\begin{coq}{name=t3}{}
Example just_tuple n (t : n.-tuple nat) :
  size (rev [seq 2 * x | x <- rev t]) = size t.
Proof. by rewrite !size_tuple. Qed.
\end{coq}
\coqrun{name=r6}{ssr,tup,sizetup,t1,t2,t3}

The iterated rewriting acts now twice replacing both the left hand
and the right hand side with \lstinline/n/.  It is worth observing
that the size of this proof (two rewrite steps) does not depend on the
complexity of the formula involved, while the one using only the
theory of lists requires one step per list-manipulating function.
What depends on the size of the formula is the number of canonical
structure resolution steps type inference performs.  Another advantage
of this last approach is that, unlike in the first, one
is not required to know the names of the lemmas:
it the new concept of tuple that takes care of the size related
reasoning.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbREQUIRE{proof language}
\mcbPROVIDE{an example of sub-type of eqType}
\mcbLEARN{it is a schematic process}
\mcbsection{$n$-tuples, a sub-type of sequences}
\label{sec:subtypekit}

We have seen that \lstinline/(seq T)/ is an \lstinline/eqType/
whenever \C{T} is and we want to transport the \C{eqType} structure
on tuples.  We first do it manually.  Then we provide a tookit
to ease the declaration of sub-types.

The first step is to define a comparison function for tuples.

\begin{coq}{name=tupcmp}{title=Comparison of tuples}
Definition tcmp n (T : eqType) (t1 t2 : n.-tuple T) :=
  tval t1 == tval t2.
\end{coq}
\coqrun{name=tupcmp}{ssr,require-tuple,tupcmp}

Here we simply reuse the one on sequences, and we ignore the
proof part of tuples.  What we need now to prove

\begin{coqdef}{name=eqtupP}
Lemma eqtupleP n (T : eqType) : Equality.axiom (@tcmp n T).
Proof.
move=> x y; apply: (iffP eqP); last first.
Redirect "g1" Show.
  by move->.
case: x; case: y => s1 p1 s2 p2 /= E. Redirect "g2" Show.
rewrite E in p2 *.
by rewrite (eq_irrelevance p1 p2).
Qed.
\end{coqdef}
\begin{coq}{def=eqtupP}{}
Lemma eqtupleP n (T : eqType) : Equality.axiom (@tcmp n T).
Proof.
move=> x y; apply: (iffP eqP); last first.
  by move->.
case: x; case: y => s1 p1 s2 p2 /= E.
rewrite E in p2 *.
by rewrite (eq_irrelevance p1 p2).
Qed.
\end{coq}
\coqrun{name=tupcmpP}{ssr,tup,tupcmp,eqtupP}

The first direction is trivial by rewriting.
The converse direction makes an essential use of
the \lstinline/eq_irrelevance/ lemma, that is brefly discussed
in~\ref{hedberg}.

\begin{coqout}{run=tupcmpP;out=g1}{title=Response line 4,width=6cm}
2 subgoals

n : nat
T : eqType
x, y : n .-tuple T
============================
x = y -> tval x = tval y

subgoal 2 is:
  tval x = tval y -> x = y
$~$  
\end{coqout}
\begin{coqout}{run=tupcmpP;out=g2}{title=Response line 6,width=6cm}
1 subgoal

n : nat
T : eqType
s1 : seq T
p1 : size s1 = n
s2 : seq T
p2 : size s2 = n
E : s2 = s1
============================
Tuple p2 = Tuple p1
\end{coqout}

We can then declare the canonical \C{eqType} instance for tuples.

\begin{coq}{name=canontup}{}
Canonical tuple_eqType n T : eqType :=
  Equality.Pack (Equality.Mixin (@eqtupleP n T)).
\end{coq}

As a simple test we check that the notations and the theory
that equips \C{eqType} is available on tuples.

\begin{coq}{name=testtup}{}
Check forall (t : 3.-tuple nat), [:: t] == [::].
Check fun t : 3.-tuple nat => uniq [:: t; t].
Check fun t : 3.-tuple nat => undup_uniq [:: t; t].
\end{coq}
\coqrun{name=tupc}{ssr,require-tuple,testtup}

Although all these proofs and definitions are specific to \C{tuple},
it seems obvious that we are following a schema here, and that the
parameters are three: the original type \C{seq T}, the sub type
\C{n.-tuple T} and the projection \C{tval}.
The sub-type kit lets one write the following:

\begin{coq}{name=subt}{}
Canonical tuple_subType := Eval hnf in [subType for tval].
Definition tuple_eqMixin := Eval hnf in [eqMixin of n.-tuple T by <:].
Canonical tuple_eqType := Eval hnf in EqType (n.-tuple T) tuple_eqMixin.
\end{coq}

Line 1 registers \C{tval} as a canonical projection to obtain a known
type out of the newly defined type of tuple.  Once the projection
is registered the equality axiom can be proved automatically by
\C{[eqMixin of n.-tuple T by <:]}, where \C{<:} is reminescent of
subtyping in functional languages like OCaml.

MOVE that to FINTYPE ORD.

\label{ordfintype}
\begin{coq}{name=subt}{}
Definition ord_enum : seq ordinal := pmap insub (iota 0 n).

Lemma val_ord_enum : map val ord_enum = iota 0 n.
Proof.
rewrite pmap_filter; last exact: insubK.
by apply/all_filterP; apply/allP=> i; rewrite mem_iota isSome_insub.
Qed.
\end{coq}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{2}
\mcbLEARN{Declare a new subtype and derive eqType}
\mcbPROVIDE{usage of \lstinline/[subType for ...]/}
\mcbREQUIRE{}
\mcbsubsection{The sub-type kit}

When one has a base type T and a sub-type ST defined as a boolean
sigma type, the \mcbMC{} library provides facilities to
build all the applicable canonical instances from just
the name of the projection going from ST to T.

For example, for \C{tuple} and \C{tval}, we can replace all the end of the
previous section with

\begin{coq}{name=subt}{}
Canonical tuple_subType := Eval hnf in [subType for tval].
\end{coq}

As we will see in the next section, the \C{subType} structure provides
a generic notation \C{val} for the projector of a sub-type (i.e.,
\C{tval} for \C{tuple}), with an overloaded injectivity lemma
\lstinline/val_inj/ saying that two objects equal in ST are also equal
in T.

In addition to the generic projection we get a generic static
constructor \C{Sub}, which takes a value in T and a proof.

More interestingly the sub-type kit provides the dynamic constructors 
\C{insub} and \C{insubd} that do not need a proof as they dynamically
test the property, and offer 
an attractive encapsulation of the difficult \emph{convoy
pattern}~\cite{AdamCPDT}.
The \C{insubd} constructor takes a default
sub-type value which it returns if the tests fails, while \C{insub}
takes only a base type value and returns an \C{option}; both are
\emph{opaque} and will not evaluate the test, even for a ground base
type value.  Both \C{Sub} and \C{insub} expect the typing context to
specify the sub-type.

Here are a few example uses, using \C{tuple}:

\begin{coq}{name=insub}{}
Variables (s : seq nat) (t : 3.-tuple nat).
Hypothesis size3s : size s == 3.
Let t1 : 3.-tuple nat := Sub s size3s.
Let s2 := if insub s is Some t then val (t : 3.-tuple nat) else nil.
Let t3 := insubd t s. (* : 3.-tuple nat *)
\end{coq}

We put \C{insub} to good use in Section~\ref{ordfintype} when
an enumeration for sub-types is to be defined.

The \C{subType} structure describes a Boolean sigma-type in terms of
its projector, constructor, and elimination rule:

\begin{coq}{name=subtdef}{}
Structure subType : Type := SubType {
  sub_sort :> Type;
  val : sub_sort -> T;
  Sub : forall x, P x -> sub_sort;
  (* elimination rule for sub_sort *)
  _ : forall K (_ : forall x Px, K (@Sub x Px)) u, K u;
  _ : forall x Px, val (@Sub x Px) = x
}.
\end{coq}

Instances can provide unification hints for any of the three named fields,
not just for \lstinline/sub_sort/. Hence, \lstinline/val $?_u$/
unifies with \lstinline/tval t/, and \lstinline/Sub $?_x$ $?_{xP}$/ 
unifies with \lstinline/Tuple s sP/, including in \C{rewrite} patterns.

The \C{subType} constructor notation assumes the sub-type is isomorphic
to a sigma-type, so that its elimination rule can be derived using \Coq{}'s
generic destructuring \C{let}, and the projector-constructor
identity can be proved by reflexivity.

\begin{coq}{name=subtdecl}{}
Local Notation inlined_sub_rect :=
  (fun K K_S u => let (x, Px) as u return K u := u in K_S x Px).

Lemma vrefl_rect {T} {P : pred T} x : P x -> x = x. Proof. by []. Qed.
  
Notation "[ 'subType' 'for' v ]" :=
  (SubType _ v _ inlined_sub_rect vrefl_rect).
\end{coq}

Note how the value of \C{Sub} is determined by unifying the type
of \lstinline/inlined_sub_rect/ with the type expected by \C{SubType}.

A useful variant of \C{[subType for tval]} is \C{[newType for Sval]}.
Such specialized constructors forces the predicate defining the
sub-type to be the trivial one: the sub-type ST adds no property to
the type T, but the resulting type ST is different from T and
inhabitants of ST cannot be mistaken by inhabitats of T.  Of course
all the theory that equips T is also available on ST.  Aliasing a
type is useful to attach to it different notations or coercions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbsubsection{A note on boolean $\Sigma$-types\label{hedberg}}

The \C{eq_irrelevace} theorem used to prove that tuples form an
\C{eqType} is a delicate matter in the \mcbCIC{}.  In particular it
is not valid in general: two proofs of the same predicate may not be
provably equal.

To the rescue comes the result of Hedberg~\cite{Hedberg}
that proves such property for a wide class of predicates.
In particular it show that any type with decidable identity
has unique identity proofs. This result can be proved in its full generality
in the \mcbMC{} library, using to the \C{eqType} interface.

\begin{coq}{name=hedberg}{title=Hedberg}
Theorem eq_irrelevance (T : eqType) (x y : T) : forall e1 e2 : x = y, e1 = e2.
\end{coq}
\coqrun{name=hedberg}{ssr,hedberg,abort}

If we pick the concrete example of \lstinline/bool/,
then all proofs that \lstinline/(b = true)/
for a fixed \lstinline/b/ are identical.

Here we can see another crucial advantage of boolean reflection.
Forming sub-types poses no complication from a logic perspective since
proofs of boolean identities are very simple, canonical, objects.

In the \mcbMC{} library, where \emph{all predicates that can} be
expressed as a boolean function \emph{are expressed as a boolean
function}, forming sub-types is extremely easy.

\mantra{It is convenient to define new types as sub-types of exinsting
ones, since they inherit all the theory.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbLEARN{}
\mcbREQUIRE{eqtype,CS}
\mcbPROVIDE{fintype}
\mcbNOTES{}
\mcbsection{Finite types and their theory}

Before describing other sub-types we introduce the interface of
types equipped with a finite enumeration.  \marginnote{talk about
count mem before}.

\begin{coq}{name=fintype}{title=Interface for finite types}
Module finite.

Definition axiom (T : eqType) (e : seq T) :=
  forall x : T, count_mem x e = 1.

Record mixin_of (T : eqType) := Mixin {
  enum : seq T;
  _ : axiom T enum;
}

End finite.
\end{coq}

The axiom asserts that any inhabitant of \C{T} occurs exactly once
in the enumeration \C{e}.  We omit here the full definition of the
interface, as it will be discussed in detail in the next chapter.
What is relevant for the current section is that \C{finType} is the
structure of types equipped with such enumeration, that any \C{finType}
is also an \C{eqType} (see the parameter of the mixin), and that
to declare a \C{finType} instance one can write:

\begin{coq}{name=fintype}{title=Declare a finType}
Definition mytype_finMixin := Finite.Mixin mytype_enum mytype_enumP.
Canonical mytype_finType := @Finite.Pack mytype mytype_finMixin.
\end{coq}

Given that the most recurrent way of showing that an enumeration
validates \C{Finite.axiom} is by proving that it both duplicate free
and exhaustive, a conveniente mixin constructor is provided.

\begin{coq}{name=fintype}{title=Declare a finType}
Lemma myenum_uniq : uniq myenum.
Lemma mem_myenum : forall x : T, x \in myenum.
Definition mytype_finMixin := Finite.UniqFinMixin myenum_uniq mem_myenum.
\end{coq}

The interface of \C{finType} comes equipped with a theory that, among
other things, provides a caridinality operator \C{#|T|} and bounded
boolean quantifications \C{[forall x, P]}.

\begin{coq}{name=fintype-th}{title=Some theory for finType}
Lemma cardT (T : finType) : #|T| = size (enum T).
Lemma forallP (T : finType) (P : pred T) : reflect (forall x, P x) [forall x, P x].
\end{coq}

Give that \C{[forall x, P x]} is a boolean expression
it enables reasoning by excluded middle and also combines well with
other boolean connectives.

What makes this formulation of finite types handy is the explicit
enumeration.  It is hence easy to iterate over the inhabintants of the
finite type, making them easy to integrate to the bigop library.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbLEARN{}
\mcbREQUIRE{eqtype,CS}
\mcbPROVIDE{fintype}
\mcbNOTES{}
\mcbsection{The ordinal subtype}

Apart from the aforementioned theory, finite types can serve as a
powerful notational device for ranges.  For example one may want
to state that a matrix of size $m \times n$ is only accessed inside
its bounds, i.e. that one cannot get the $m+1$ row.  The way this will
be formulated in the \mcbMC{} library is by saying that that its row
accessor accepts only inhabitants of a finite type of size $m$.
Accessing a matrix out of its bounds becomes a type error.
Of course one wants to access a matrix using integer coordinates, but
integers are inifite.  Hence the first step is to define the sub-type
of bounded integers.

\begin{coq}{name=ordinals}{title=Ordinals}
Inductive ordinal (n : nat) : Type := Ordinal m of m < n.
Notation "''I_' n" := (ordinal n)

Coercion nat_of_ord i := let: Ordinal m _ := i in m.

Canonical ordinal_subType := [subType for nat_of_ord].
Definition ordinal_eqMixin := Eval hnf in [eqMixin of ordinal by <:].
Canonical ordinal_eqType := Eval hnf in EqType ordinal ordinal_eqMixin.
\end{coq}

We start by making ordinals a subtype of natural numbers, and hence
inherit the theory of \C{eqType}.  To show they form a \C{finType}
we need to provide a good enumeration.

\begin{coq}{name=ordinals}{title=Enumerating a sub type via insub}
Definition ord_enum n : seq (ordinal n) := pmap insub (iota 0 n).
\end{coq}

The \C{iota} function produces the sequence \C{[:: 0, 1, ... n.-1]}.
Such sequence is mapped via \C{insub} that tests if an element \C{x}
is smaller than \C{n}.  If it is the case it produces \C{(Some x)},
where \C{x} is an ordinal, else \C{None}.  \C{pmap} drops all \C{None}
items, and removes the \C{Some} constructor from the others.

What \C{ord\_enum} produces is hence a sequence of ordinals, i.e.
a sequence of terms like \C{(Ordinal m p)} where \C{m} is a natural
number (as produces by \C{iota}) and \C{p} is a proof that \C{(m <=
n)}.  What we are left to show is that such enumeration is complete
and non redundant.

\begin{coq}{}{}
Lemma val_ord_enum : map val ord_enum = iota 0 n.
Proof.
rewrite pmap_filter; last exact: insubK.
by apply/all_filterP; apply/allP=> i; rewrite mem_iota isSome_insub.
Qed.

Lemma ord_enum_uniq : uniq ord_enum.
Proof. by rewrite pmap_sub_uniq ?iota_uniq. Qed.

Lemma mem_ord_enum i : i \in ord_enum.
Proof. by rewrite -(mem_map ord_inj) val_ord_enum mem_iota ltn_ord. Qed.
\end{coq}

It is worth pointing out how the \C{val\_ord\_enum} lemma
shows that the ordinals in \C{ord\_enum} are exactly the
natural nubers generatd by \C{(iota 0 n)}.  In particular,
the \C{insub} construction completely removes the need for
complex depent case analysis.

\begin{coqout}{}{}
2 subgoals
n : nat
============================
[seq x <- iota 0 n | isSome (insub x)] = iota 0 n

subgoal 2 is:
  ocancel insub val
\end{coqout}

The view \C{all\_filterP} shows that
\C{reflect ([seq x <- s | a x] = s) (all a s)} for any
sequence \C{s} and predicate \C{a}.  After applying
that view one has to prove that if \C{(i \\in iota 0 n)} then \C{(i <
n)}, that is trivialized by \C{mem\_iota}.

We can now declare the type of ordinals as a instance of \C{finType}.

\begin{coq}{}{}
Definition ordinal_finMixin n :=
  Eval hnf in UniqFinMixin (ord_enum_uniq n) (mem_ord_enum n).
Canonical ordinal_finType n :=
  Eval hnf in FinType (ordinal n) (ordinal_finMixin n).
\end{coq}

An example of ordinals at work is the \C{tnth} function.
It extracts the $n$-th element of a tuple exactly as
\C{nth} for a sequence without requiring a default element.
Indeed one can use ordinals to type the index making Coq statically
check that the index is smaller than the size of the tuple.

\begin{coq}{name=subtdecl}{}
Lemma tnth_default T n (t : n.-tuple T) : 'I_n -> T.
Proof. by rewrite -(size_tuple t); case: (tval t) => [|//] []. Qed.

Definition tnth T n (t : n.-tuple T) (i : 'I_n) : T :=
  nth (tnth_default t i) t i.
\end{coq}

Another use of ordinals is to express the position of an
inhabitant of a \C{finType} in its enumeration.

\begin{coq}{name=subtdecl}{}
Definition enum_rank (T : finType) : T -> 'I_#|T|.
\end{coq}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbLEARN{}
\mcbPROVIDE{}
\mcbREQUIRE{}
\mcbsection{Finite functions}

In standard mathematics functions that are pointwise equal are
considered as equal.  This principle, that we call \emph{functional
extensionality} is compatible with the \mcbCIC{} but is not built-in.
Indeed, at the time of writing, only very recent variations of CIC,
as Cubical Type Theory, include such principle.

Still there is a class of functions for which such principle is
provable in Coq.  These are the functions with a finite domain:
given their graph is a finite set of points we can represent them
as regular lists, and lists with the same values are indeed equal.

\begin{coq}{name=subtdecl}{}
Section FinFunDef.

Variables (aT : finType) (rT : Type).
Inductive finfun : Type := Finfun of #|aT|.-tuple rT.
Definition fgraph f := let: Finfun t := f in t.
Canonical finfun_subType := Eval hnf in [newType for fgraph].
End FinFunDef.
Notation "{ 'ffun' fT }" := (finfun fT).
\end{coq}

The actual definition in the \mcbMC{} library is sligthly more complex
to statically check that the domain is finite using the tricks
explained in~\ref{sec:phantom}.  I.e. Coq rejects \C{\{ffun nat -> nat\}}
but accepts \C{\{ffun 'I_7 -> nat\}}.

Other utilities let one apply a finite function as a regular function
or build a finite function from a regular function.

\begin{coq}{name=subtdecl}{}
Definition fun_of_fin aT rT f x := tnth (@fgraph aT rT f) (enum_rank x).
Coercion fun_of_fin : finfun >-> FunClass.
Definition finfun aT rT f := @Finfun aT rT (codom_tuple f).
Notation "[ 'ffun' x : aT => F ]" := (finfun (fun x : aT => F))
\end{coq}

What \C{codom\_tuple} builds is a list of values \C{f} takes
when applied to the values in the enumeration of its domain.

example playing with ffun.

\begin{coq}{name=subtdecl}{}
Check [ffun i : 'I_4 => i + 2].
\end{coq}

Finite functions inherit from tuples the \C{eqType} structure
whenever the codomain is an \C{eqType}.

\begin{coq}{}{}
Definition finfun_eqMixin aT (rT : eqType) :=
  Eval hnf in [eqMixin of finfun aT rT by <:].
Canonical finfun_eqType :=
  Eval hnf in EqType (finfun aT rT) finfun_eqMixin.
\end{coq}

When the codomain is finite, the type of finite functions is itself
finite.  This property is again inherited from tuples.

Is that snippet interesting?  One could ask to write such enum
as exercise of ch 1, and here simply add insub.

\begin{coq}{}{}
Definition tuple_enum (T : finType) n : seq (n.-tuple T) :=
  let extend e := flatten (codom (fun x => map (cons x) e)) in
  pmap insub (iter n extend [::[::]]).

Lemma enumP T n : Finite.axiom (tuple_enum T n).

Definition tuple_finMixin := Eval hnf in FinMixin (@FinTuple.enumP n T).
Canonical tuple_finType :=
  Eval hnf in FinType (n.-tuple T) tuple_finMixin.
 
Definition finfun_finMixin (aT rT : finType) :=
  [finMixin of (finfun aT rT) by <:].
Canonical finfun_finType  aT rT :=
  Eval hnf in FinType (finfun aT rT) (finfun_finMixin aT rT).
\end{coq}

A relevant property of the finType of finite functions is its
cardinality, begin \C{#|rT| ^ #|aT|}.

\begin{coq}{}{}
Lemma card_ffun (aT rT : finType) : #| {ffun aT -> rT} | = #|rT| ^ #|aT|.
\end{coq}

An application of the type of finite functions is the following lemma.

\begin{coq}{}{}
Lemma bigA_distr_bigA (I J : finType) F :
  \big[*%M/1]_(i : I) \big[+%M/0]_(j : J) F i j
    = \big[+%M/0]_(f : {ffun I -> J}) \big[*%M/1]_i F i (f i).
\end{coq}

explain it states independence of i j.

$$
\prod_{i \in I} \sum_{j \in J} F i j = \sum_{f \in I \to J} \prod_{i \in I} F i (f i)
$$


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbLEARN{}
\mcbPROVIDE{}
\mcbREQUIRE{}
\mcbsection{Matrix}

all together to achieve compact notation.

\begin{coq}{}{}
Inductive matrix : predArgType := Matrix of {ffun 'I_m * 'I_n -> R}.

Definition mx_val A := let: Matrix g := A in g.

Canonical matrix_subType := Eval hnf in [newType for mx_val].

Coercion fun_of_matrix : matrix >-> Funclass.

Definition mxtrace (A : 'M[R]_n) := \sum_i A i i.
Local Notation "'\tr' A" := (mxtrace A) : ring_scope.

\end{coq}

note how ordinals infer everything in tr

\begin{coq}{}{}
Lemma mxtrace_mulC m n (A : 'M[R]_(m, n)) B :
   \tr (A *m B) = \tr (B *m A).
Proof.
have expand_trM C D: \tr (C *m D) = \sum_i \sum_j C i j * D j i.
  by apply: eq_bigr => i _; rewrite mxE.
rewrite !{}expand_trM exchange_big /=.
by do 2!apply: eq_bigr => ? _; apply: mulrC.
Qed.
\end{coq}

put gen have.

another example is multiplication and matrix in extension

\begin{coq}{}{}
Notation "''M[' R ]_ ( m , n )" := (matrix R m n) (only parsing): type_scope.
Notation "\matrix_ ( i  , j  ) E" := ...

Definition mulmx {m n p} (A : 'M_(m, n)) (B : 'M_(n, p)) : 'M[R]_(m, p) :=
  \matrix[mulmx_key]_(i, k) \sum_j (A i j * B j k).

Local Notation "A *m B" := (mulmx A B) : ring_scope.
\end{coq}

note the type making it impossible to multiply wrong matrices.
this is not like in / 0, that we default.

determinant and ffun

\begin{coq}{}{}

(* The determinant, in one line with the Leibniz Formula *)
Definition determinant n (A : 'M_n) : R :=
  \sum_(s : 'S_n) (-1) ^+ s * \prod_i A i (s i).

Lemma det_mulmx n (A B : 'M[R]_n) : \det (A *m B) = \det A * \det B.
Proof.
rewrite big_distrl /=.
pose F := ('I_n ^ n)%type; pose AB s i j := A i j * B j (s i).
transitivity (\sum_(f : F) \sum_(s : 'S_n) (-1) ^+ s * \prod_i AB s i (f i)).
  rewrite exchange_big; apply: eq_bigr => /= s _; rewrite -big_distrr /=.
  congr (_ * _); rewrite -(bigA_distr_bigA (AB s)) /=.
  by apply: eq_bigr => x _; rewrite mxE.
rewrite (bigID (fun f : F => injectiveb f)) /= addrC big1 ?add0r => [|f Uf].
  rewrite (reindex (@pval _)) /=; last first.
    pose in_Sn := insubd (1%g : 'S_n).
    by exists in_Sn => /= f Uf; first apply: val_inj; apply: insubdK.
  apply: eq_big => /= [s | s _]; rewrite ?(valP s) // big_distrr /=.
  rewrite (reindex_inj (mulgI s)); apply: eq_bigr => t _ /=.
  rewrite big_split /= mulrA mulrCA mulrA mulrCA mulrA.
  rewrite -signr_addb odd_permM !pvalE; congr (_ * _); symmetry.
  by rewrite (reindex_inj (@perm_inj _ s)); apply: eq_bigr => i; rewrite permM.
transitivity (\det (\matrix_(i, j) B (f i) j) * \prod_i A i (f i)).
  rewrite mulrC big_distrr /=; apply: eq_bigr => s _.
  rewrite mulrCA big_split //=; congr (_ * (_ * _)).
  by apply: eq_bigr => x _; rewrite mxE.
case/injectivePn: Uf => i1 [i2 Di12 Ef12].
by rewrite (determinant_alternate Di12) ?simp //= => j; rewrite !mxE Ef12.
Qed.
\end{coq}

\mcbLEVEL{2}
\mcbsubsection{blocks and casts}

Casts and block\_mx.

