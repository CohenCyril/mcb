% vim:set tw=70:
% vim:set spell:
% vim:set errorformat="":
\begin{coqdef}{name=ssr}
Require Import Ssreflect.ssreflect.
From Ssreflect Require Import ssrfun ssrbool ssrnat eqtype fintype seq div prime.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.
Set Asymmetric Patterns.
\end{coqdef}
\begin{coqdef}{name=abort}
Abort.
\end{coqdef}
\begin{coqdef}{name=show1}
Redirect "g1" Show.
\end{coqdef}
\begin{coqdef}{name=require-tuple}
Require Import tuple.
\end{coqdef}

\Chapter{Sub-Types}{Terms with properties}\label{ch:sigmabool}

Inductive data types have been used to both code data, like lists, and
logical connectives, like and.  Properties were always expressed with
boolean programs.  Now the question is, what stuts do we want to give
to, say, lists of size 5,  or integers smaller than 7?  And which
relation to put between integrs and integers smaller than 7.  And how
to benefit from extra properties integers smaller than 7 have, like
being a finite collection.

In standard mathematics one would simple say that the integers are an
infinite set (called \C{nat}), and that the integers smaller that 7
form a finite subset of the integers (called \C{'I_7}).  Integers and
integers smaller that 7 are interchangeable data: if \C{n:nat} and
\C{i:'I_7} one can clearly add \C{n} with \C{i}, and eventually show
that their sum is still smaller than 7.  Also, an informed reader
knows which operations are compatible with a subset, eg \C{(i-1)}
stays in \C{'I_7}, as well as \C{(i+n \%| 7)}.  So in a sense, subsets
also provide a linguistic construct to ask the reader to track an
easy invariant relieving the proof text from uninteresting details.

The closest notion we have in \mcbCIC{} is the one of $\Sigma-$types,
i.e. records.  One can define the type \C{'I_7} as $\Sigma_{(n:nat)} n
\leq 7.$  Indeed in the \mcbCIC{} proofs are terms, so one can easily
pack together objects and proofs of some properties to
represent the objects that have those properties.  For example $3$,
when seen as an inhabitant of \C{'I_7} is represented by a dependent
pair \C{(3,p)} where \C{(p : 3 <= 7)}.  Note that by forgetting the
proof \C{p} one recovers a \C{nat} that can be passed to, say, the
program computing the addition of natural numbers, or to theorems
holding for any \C{nat}.  Still an inhabitant of \C{'I_7} can always
be proved smaller than 7, since such evidence is part of the
object itself.
We call this construction a \emph{sub-type}.

Such representation can be expensive in the sense that it imposes
extra work (proofs!) to create a sub-type object, so it must be used
with care.  The \mcbMC{} library provides several facilities that
support the creation of record-based sub-types, and of their
inhabitants.  We shall in particular see how both type inference and
dynamic tests can be used to supply the property proofs, modelling
once again the eye of a trained reader.

Finally, let us point out that we have already encountered proof-carrying
records in the previous chapter, with \C{eqType}.
The \C{eqType} record played the role of an interface,
expressing a relation between a type and a function (the comparison operation),
and giving to access a whole theory of results through type inference.
Many such interfaces can be extended to sub-types, and we shall see that
the \mcbMC{} library provides facilities to automate this.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbLEARN{}
\mcbREQUIRE{eqtype, fintype, CS}
\mcbPROVIDE{tuple}
\mcbNOTES{}
\mcbsection{$n$-tuples, lists with an invariant on the length}

We begin by defining the type of tuples: sequences of a given length.
In this section we focus on how tuples are defined, used as regular
sequences and how to program type inference to track, for us, the
invariant on a tuples' length.  Next section will complete the
definition of the tuple sub-type by making the abstract theory
attached to the \C{eqType} interface available on tuples whenver it is
available on sequences.

A tuple is a sequence of values (of the same type) whose length is
made explicit in the type.

\begin{coq}{name=tupx}{width=\textwidth,title=Tuple sub-type of seq}
Structure tuple_of n T :=  Tuple { tval :> seq T; _ : size tval == n }.
Notation "n .-tuple T" := (tuple_of n T) (at level 2).
\end{coq}
\coqrun{name=r1}{ssr,tupx}

% Recall that the statement \lstinline/(size tval == n)/
% is the argument of a hidden \lstinline/is_true/ coercion.
% If we unfold its definition we clearly see that the statement
% is an equality on \lstinline/bool/.

The key property of this type is that it tells us the length of its
elements when seen as sequences:

\begin{coq}{name=sizetup}{}
Coercion tval : tuple_of >-> seq.
Lemma size_tuple {T n} (t : n.-tuple T) : size t = n.
Proof. by case: t => s /eqP. Qed.
\end{coq}
\coqrun{name=r2}{ssr,tup,sizetup}

In other words each inhabitant of the tuple type carries,
in the form of a proof, its length.  As test bench for the notion
of tuple we pick this simple example: a tuple is processed using
functions defined on sequences, namely \lstinline/rev/ and
\lstinline/map/.

\begin{coq}{name=p1}{}
Example seq_on_tuple n (t : n.-tuple nat) :
  size (rev [seq 2 * x | x <- rev t]) = size t.
\end{coq}

There are two ways to prove that lemma.  The first one is
to ignore the fact that \lstinline/t/ is tuple, consider it
as a regular sequence, and use only the theory of sequences.

\begin{coq}{name=p2}{}
Proof. by rewrite map_rev revK size_map. Qed.
\end{coq}
\coqrun{name=r3}{ssr,tup,sizetup,p1,p2}

Mapping a function over the reverse of a list, it equivalent to
first map the function over the list and then reverse the result
(\lstinline/map_rev/).  Then, reversing twice a list is a no-op, since
\lstinline/rev/ is an involution
(\lstinline/revK/).  Finally, mapping a function over a list does not
change its size (\lstinline/size_map/).  The sequence of rewritings
make the left hand side of the conjecture identical to the right hand
side, and we can conclude.

This simple example shows that the theory of sequences is usable
on terms of type tuple.  Still we didn't take any advantage of
the fact that  \lstinline/t/ is tuple.

The second way to prove this theorem is to rely on the rich type
of \lstinline/t/ to actually compute the length of the sequence.

\begin{coq}{name=p3}{}
Example just_tuple_attempt n (t : n.-tuple nat) :
  size (rev [seq 2 * x | x <- rev t]) = size t.
Proof. rewrite size_tuple.
\end{coq}
\coqrun{name=r4;fail}{ssr,tup,sizetup,p3,show1}
\begin{coqout}{run=r4;out=g1}{}
1 subgoal

 n : nat
 t : n .-tuple nat
 ============================
 size (rev [seq 2 * x | x <- rev t]) = n
\end{coqout}

The rewriting replaces the right hand side with \lstinline/n/ as
expected, but we can't go any further: the lemma is not replacing
the right hand side with \lstinline/n/, even if we are working
with a tuple \lstinline/t/.  Why is that?  In the left hand side
\lstinline/t/ is processed using functions on sequences.
The type of \lstinline/rev/ for example is
\lstinline/(forall T, seq T -> seq T)/.  The coercion \lstinline/tval/
from \lstinline/tuple_of/ to \lstinline/seq/ make the
expression \lstinline/(rev (tval t))/ well typed, but the output
is of type \lstinline/(seq nat)/.  
We would like the functions on sequences to return
data as rich as the one taken in input.

Let us examine what happens if try to unify the left hand side of the
\lstinline/size_tuple/ equation with the redex
\lstinline/(rev t)/, using the following toolkit

\begin{coq}{name=infrastructure}{title= Unification debugging toolkit}
(* toolkit *)
Notation "X (*...*)" := (let x := X in let y := _ in x)
  (at level 100, format "X  (*...*)").
Notation "[LHS 'of' equation ]" :=
  (let LHS := _ in
   let _infer_LHS := equation : LHS = _ in LHS)
  (at level 4).
Notation "[unify X 'with' Y ]" :=
  (let unification := erefl _ : X = Y in
   True).
\end{coq}

This simulation of \lstinline/rewrite size_tuple/

\begin{coq}{name=showunif}{}
Check forall T n (t : n.-tuple T),
 let LHS := [LHS of size_tuple _] in
 let RDX := size (rev t) in
 [unify LHS with RDX].
\end{coq}

generates the following diagnostic

\coqrun{name=r5;fail}{ssr,tup,sizetup,infrastructure,showunif}
\begin{coqout}{run=r5}{title=Response}
Error:
In environment
T : Type
n : nat
t : n .-tuple T
LHS := size (tval ?94 ?92 ?96) (*...*) : nat
RDX := size (rev (tval n T t))           : nat
The term "erefl ?95" has type "?95 = ?95" while
it is expected to have type "LHS = RDX".
\end{coqout}

Unifying \lstinline/(size (tval ?$_n$ ?$_T$ ?$_t$))/
with \lstinline/(size (rev (tval n T t)))/ is hard.
Both term's head symbol is \lstinline/size/, but then
the projection \lstinline/tval/ applied to unification
variables has to be unified with \lstinline/(rev ...)/,
and both terms are in normal form.

Such problem is nontrivial because to solve it one has to infer a
record for \lstinline/?$_t$/ that contains a proof: a
tuple whose \lstinline/tval/ field
is \lstinline/rev t/ (and whose other field contains a
proof that such sequence has length \lstinline/?$_n$/).

We have seen in the previous chapter that this is exactly the class of
problems that is addressed by \C{Canonical} structure instances.
We can thus use \C{Canonical} declarations to teach Coq
the effect of list operations on the length of their input.

\begin{coq}{name=t1}{}
Lemma rev_tupleP n A (t : n.-tuple A) : size (rev t) = n.
Proof. by rewrite size_rev size_tuple. Qed.
Canonical rev_tuple n A (t : n.-tuple A) := Tuple (rev_tupleP t).

Lemma map_tupleP n A B (f: A -> B) (t : n.-tuple A) : size (map f t) = n.
Proof. by rewrite size_map size_tuple. Qed.
Canonical map_tuple n A B f (t : n.-tuple A) : n.-tuple B :=
  Tuple (map_tupleP f t).
\end{coq}

Even if it is not needed for the lemma we took as our test bench,
we add another example where the length is not preserved.

\begin{coq}{name=t2}{}
Lemma cons_tupleP n A (t : n.-tuple A) x : size (x :: t) = n.+1.
Proof. by rewrite /= size_tuple. Qed.
Canonical cons_tuple n A x (t : n.-tuple A) : n.+1 .-tuple A :=
  Tuple (cons_tupleP t x).
\end{coq}

The global table of canonical solutions is extended as follows.

\noindent
\begin{tcolorbox}[colframe=blue!60!white,before=\hfill,after=\hfill,center title,tabularx={ll|l|l},fonttitle=\sffamily\bfseries,title=Canonical Structures Index]
projection & value & solution & combines solutions for \\ \hline
\lstinline/tval N A/ & \lstinline/rev A S/ & \lstinline/rev_tuple N A T/
	& \lstinline/T/ $\leftarrow$ (\lstinline/tval N A/, \lstinline/S/) \\
\lstinline/tval N B/ & \lstinline/map A B F S/ & \lstinline/map_tuple N A B F T/
	& \lstinline/T/ $\leftarrow$ (\lstinline/tval N A/, \lstinline/S/) \\
\lstinline/tval N.+1 A/ & \lstinline/X :: S/ & \lstinline/cons_tuple N A T X/
	& \lstinline/T/ $\leftarrow$ (\lstinline/tval N A/, \lstinline/S/) \\
\end{tcolorbox}

Thanks to the now extended capability of type inference
we can prove our lemma by just reasoning about tuples.

\begin{coq}{name=t3}{}
Example just_tuple n (t : n.-tuple nat) :
  size (rev [seq 2 * x | x <- rev t]) = size t.
Proof. by rewrite !size_tuple. Qed.
\end{coq}
\coqrun{name=r6}{ssr,tup,sizetup,t1,t2,t3}

The iterated rewriting acts now twice replacing both the left hand
and the right hand side with \lstinline/n/.  It is worth observing
that the size of this proof (two rewrite steps) does not depend on the
complexity of the formula involved, while the one using only the
theory of lists requires one step per list-manipulating function.
What depends on the size of the formula is the number of canonical
structure resolution steps type inference performs.  Another advantage
of this last approach is that, unlike in the first, one
is not required to know the names of the lemmas:
it the new concept of tuple that takes care of the size related
reasoning.

% Going back to the example of (coloured) points, once a coloured point
% is defined as a record embedding a simple point
% 
% \begin{coq}{name=col}{}
% Record CP := Coloured { coords_of :> P; colour_of : color }
% \end{coq}
% 
% \noindent
% the way we implement sub-type polymorphism between \lstinline/CP/
% and \lstinline/P/ is by assigning the typed \lstinline/(P -> P)/ to
% \lstinline/move/ but:
% \begin{itemize}
% \item thanks to the automatically inserted
% 	\emph{forgetful coercion} \lstinline/coords_of/
% 	we can apply \lstinline/move/ to a coloured point \lstinline/c/
% 	obtaining \lstinline/(move (coords_of c))/
% \item thanks to \emph{programmable type inference} such	expression
% 	can be automatically injected back in the type of coloured
% 	points by using the color of \lstinline/c/ and obtain
% 	\lstinline/(Coloured (move (coords_of c))$~$(colour_of c))/
% \end{itemize}
% That is pretty much what ones expects \lstinline/move/ to do when
% applied to a coloured point: act on its coordinates and leave
% its colour untouched.
% 
% We have seen how to implement the glue that links a type (sequences)
% with a sub-type (tuples), but only in a very simple case.
% A tuple is trivially a sequence (by forgetting something), hence the
% theory of sequences ``trivially'' applies to tuples.
% 
% We now revise the definition of \lstinline/eqType/, turning it into a
% real interface bringing with it a specific theory.  Later we show that
% since \lstinline/seq/ is an instance of that interfaces and since
% \lstinline/tuple/ is a sub-type of \lstinline/seq/, then the theory
% of \lstinline/eqType/ also applies to tuples.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbREQUIRE{proof language}
\mcbPROVIDE{an example of sub-type of eqType}
\mcbLEARN{it is a schematic process}
\mcbsection{$n$-tuples, a sub-type of sequences}
\label{sec:subtypekit}

We have that \lstinline/(seq T)/ is an \lstinline/eqType/ and
we want to transport \lstinline/==/ on tuples.  First we need to
defined a comparison function for tuples.

\begin{coq}{name=tupcmp}{title=Comparison of tuples}
Definition tcmp n (T : eqType) (t1 t2 : n.-tuple T) :=
  tval t1 == tval t2.
\end{coq}
\coqrun{name=tupcmp}{ssr,require-tuple,tupcmp}

Here we reuse the one on sequences, and we ignore the
proof part of tuples.

We need now to prove

\begin{coqdef}{name=eqtupP}
Lemma eqtupleP n (T : eqType) : Equality.axiom (@tcmp n T).
Proof.
move=> x y; apply: (iffP eqP); last first.
Redirect "g1" Show.
  by move->.
case: x; case: y => s1 p1 s2 p2 /= E. Redirect "g2" Show.
rewrite E in p2 *.
by rewrite (eq_irrelevance p1 p2).
Qed.
\end{coqdef}
\begin{coq}{def=eqtupP}{}
Lemma eqtupleP n (T : eqType) : Equality.axiom (@tcmp n T).
Proof.
move=> x y; apply: (iffP eqP); last first.
  by move->.
case: x; case: y => s1 p1 s2 p2 /= E.
rewrite E in p2 *.
by rewrite (eq_irrelevance p1 p2).
Qed.
\end{coq}
\coqrun{name=tupcmpP}{ssr,tup,tupcmp,eqtupP}

The first direction is trivial

\begin{coqout}{run=tupcmpP;out=g1}{title=Response line 4,width=5cm}
2 focused subgoals (shelved: 2)

n : nat
T : eqType
x, y : n .-tuple T
============================
x = y -> tval x = tval y

subgoal 2 is:
  tval x = tval y -> x = y
\end{coqout}

For the other one the crucial step is the use
of \lstinline/eq_irrelevance/.

\begin{coqout}{run=tupcmpP;out=g2}{title=Response line 6,width=7cm}
1 subgoal

n : nat
T : eqType
s1 : seq T
p1 : size s1 = n
s2 : seq T
p2 : size s2 = n
E : s2 = s1
============================
Tuple p2 = Tuple p1
\end{coqout}

We can then declare

\begin{coq}{name=canontup}{}
Canonical tuple_eqType n T :=
  Equality.Pack (Equality.Mixin (@eqtupleP n T)).
\end{coq}

Simple test

\begin{coq}{name=testtup}{}
Check forall (t : 3.-tuple nat), [:: t] == [::].
Check fun t : 3.-tuple nat => uniq [:: t; t].
Check fun t : 3.-tuple nat => undup_uniq [:: t; t].
\end{coq}
\coqrun{name=tupc}{ssr,require-tuple,testtup}

Although all these proofs and definitions are specific to \C{tuple},
they are obviously schematic and generalize to similarly defined types,
like ordinals.  The sub-type kit lets one write the following

\begin{coq}{name=subt}{}
Canonical tuple_subType := Eval hnf in [subType for tval].
Definition tuple_eqMixin := Eval hnf in [eqMixin of n.-tuple T by <:].
Canonical tuple_eqType := Eval hnf in EqType (n.-tuple T) tuple_eqMixin.
\end{coq}

Line 1 registers \C{tval} as a canonical projection to obtain a known
type out of the newly defined type of tuple.  Once the projection
is registered the equality axiom can be proved automatically by
\C{[eqMixin of n.-tuple T by <:]}, where \C{<:} is reminescent of
subtyping in functional languages like OCaml.

In addition to that the sub-type kit provides insub.

\begin{coq}{name=subt}{}
Definition ord_enum : seq ordinal := pmap insub (iota 0 n).

Lemma val_ord_enum : map val ord_enum = iota 0 n.
Proof.
rewrite pmap_filter; last exact: insubK.
by apply/all_filterP; apply/allP=> i; rewrite mem_iota isSome_insub.
Qed.
\end{coq}

explain why this is better than the horror with dependent types.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{2}
\mcbLEARN{Declare a new subtype and derive eqType}
\mcbPROVIDE{usage of \lstinline/[subType for ...]/}
\mcbREQUIRE{}
\mcbsubsection{The sub-type kit}

When one has a base type T and a sub-type ST defined as a boolean
sigma type, the \mcbMC{} library provides facilities to
build all the applicable canonical instances from just
the name of the projection going from ST to T.

For example, for \C{tuple} and \C{tval}, we can replace all the end of the
previous section with

\begin{coq}{name=subt}{}
Canonical tuple_subType := Eval hnf in [subType for tval].
Definition tuple_eqMixin := Eval hnf in [eqMixin of n.-tuple T by <:].
Canonical tuple_eqType := Eval hnf in EqType (n.-tuple T) tuple_eqMixin.
\end{coq}

Line 1 creates an instance of the \C{subType} structure that registers the
relation between \C{tuple} and \C{seq}; line 2 accesses the \C{subType}
interface to create an \C{eqMixin}.

As we will see in the next section, the \C{subType} structure provides
a generic notation \C{val} for the projector of a sub-type (i.e.,
\C{tval} for \C{tuple}),
with an overloaded injectivity lemma \lstinline/val_inj/.

We also get a generic static constructor \C{Sub}, which takes a base
type value and a proof, and more interestingly dynamic constructors
\C{insub} and \C{insubd} that do not need a proof as they dynamically
test the property, and offer an attractive encapsulation of the
difficult \emph{convoy} dependent progamming pattern. The \C{insubd}
constructor takes a default sub-type value which it returns if the
tests fails, while \C{insub} takes only a base type value and returns
an \C{option}; both are \emph{opaque} and will not evaluate the test,
even for a ground base type value.  Both \C{Sub} and \C{insub} expect
the typing context to specify the sub-type.

Here are a few example uses, using \C{tuple}:

\begin{coq}{name=insub}{}
Variables (s : seq nat) (t : 3.-tuple nat).
Hypothesis size3s : size s == 3.
Let t1 : 3.-tuple nat := Sub s size3s.
Let s2 := if insub s is Some t then val (t : 3.-tuple nat) else nil.
Let t3 := insubd t s. (* : 3.-tuple nat *)
\end{coq}

The \C{subType} structure describes a Boolean sigma-type in terms of
its projector, constructor, and elimination rule:

\begin{coq}{name=subtdef}{}
Structure subType : Type := SubType {
  sub_sort :> Type;
  val : sub_sort -> T;
  Sub : forall x, P x -> sub_sort;
  (* elimination rule for sub_sort *)
  _ : forall K (_ : forall x Px, K (@Sub x Px)) u, K u;
  _ : forall x Px, val (@Sub x Px) = x
}.
\end{coq}

Instances can provide unification hints for any of the three named fields,
not just for \lstinline/sub_sort/. Hence, \lstinline/val \mcbimpl{u}/
unifies with \lstinline/tval t/, and \lstinline/Sub \mcbimpl{x} \mcbimpl{xP}/ 
unifies with \lstinline/Tuple s sP/, including in \C{rewrite} patterns.

The \C{subType} constructor notation assumes the sub-type is isomorphic
to a sigma-type, so that its elimination rule can be derived using \Coq{}'s
generic destructuring \C{let}, and the projector-constructor
identity can be proved by reflexivity.

\begin{coq}{name=subtdecl}{}
Local Notation inlined_sub_rect :=
  (fun K K_S u => let (x, Px) as u return K u := u in K_S x Px).

Lemma vrefl_rect {T} {P : pred T} x : P x -> x = x. Proof. by []. Qed.
  
Notation "[ 'subType' 'for' v ]" :=
  (SubType _ v _ inlined_sub_rect vrefl_rect).
\end{coq}

Note how the value of \C{Sub} is determined by unifying the type
of \lstinline/inlined_sub_rect/ with the type expected by \C{SubType}.

Also explain \C{[newType for Sval]} for simple wrappers.

\mcbLEVEL{2}
\mcbsubsection{A note on boolean $\Sigma$-types}

Unfortunately the irrelevance of proof components of records like
ordinals is in general not true in \mcbCIC{}: all
components are relevant to equality.

To the rescue comes the result of Hedberg~\cite{Hedberg}
that proves such property for a wide class of predicates.
In particular it implies that any type with decidable identity
has unique identity proofs. This result can be proved in its full generality
in the \mcbMC{} library, using to the \C{eqType} interface.

\begin{coq}{name=hedberg}{title=Hedberg}
Theorem eq_irrelevance (T : eqType) (x y : T) : forall e1 e2 : x = y, e1 = e2.
\end{coq}
\coqrun{name=hedberg}{ssr,hedberg,abort}

If we pick the concrete example of \lstinline/bool/,
then all proofs that \lstinline/(b = true)/
for a fixed \lstinline/b/ are identical.

Here we can see another crucial advantage of boolean reflection.
Forming sub-types poses no complication from a logic perspective since
proof of boolean identities are very simple, canonical, objects.

In the \mcbMC{} library, where \emph{all predicates that can} be
expressed as a boolean function \emph{are expressed as a boolean
function}, forming sub-types is extremely easy.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbLEARN{}
\mcbREQUIRE{eqtype,CS}
\mcbPROVIDE{fintype}
\mcbNOTES{}
\mcbsection{Finite types and their theory}

The first example of sub-type we describe is the one of ordinals:
natural numbers smaller than a given bound.  Such type has a finite
number of elements, a property we associate to the following
interface.

\begin{coq}{name=fintype}{title=Interface for finite types}
Module finite.

Definition axiom (T : eqType) e :=
  forall x : T, count_mem x e = 1.

Record mixin_of (T : eqType) := {
  enum : seq T;
  _ : axiom T enum;
}

Record class_of (T : eqType) := Class {
  base : Equality.class_of T;
  mixin : mixin_of (Equality.Pack base)
}.

Structure type : Type := Pack {
  sort :> Type;
  class : class_of sort;
}

End Finite.

Notation finType := Finite.type.
Notation enum T := (Finite.enum (Finite.mixin (Finite.class T))).
\end{coq}

The details of this interface are explained in details in the next
chapter.  What is relevant to the current chapter is that \C{finType}
adds on top of \C{eqType} an enumeration (a sequence of values) that
lists exactly once all elements in the type.  Indeed \C{count_mem}
counts how many elements of \C{e} are equal to \C{x}.

The interface of \C{finType} comes equipped with a theory that, among
other things, provides a caridinality operator \C{#|T|} and bounded
quantifications like \C{[forall x, P]}.

\begin{coq}{name=fintype-th}{title=Some theory for finType}
Lemma cardT (T : finType) : #|T| = size (enum T).
Lemma forallP (T : finType) (P : pred T) :
  reflect (forall x, P x) [forall x, P x].
\end{coq}

Note that \C{[forall x, P x]} is a boolean expression, hence naturally
enables reasoning by expluded middle.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbLEARN{}
\mcbREQUIRE{eqtype,CS}
\mcbPROVIDE{fintype}
\mcbNOTES{}
\mcbsection{The ordinal subtype}

Apart from the aforementioned theory, finite types can serve as a
powerful notational device for ranges.  For example one may want
to state that a matrix of size $m \times n$ is only accessed inside
its bounds, i.e. that one cannot get the $m+1$ row.  The way this will
be formulated in the \mcbMC{} library is by saying that that its row
accessor accepts only inhabitants of a finite type of size $m$.
Accessing a matrix out of its bounds becomes a type error.
Of course one wants to access a matrix using integer coordinates, but
integers are inifite.  Hence the first step is to define the sub-type
of bounded integers.


\begin{coq}{name=ordinals}{title=Ordinals}
Inductive ordinal (n : nat) : Type := Ordinal m of m < n.
Notation "''I_' n" := (ordinal n)

Coercion nat_of_ord i := let: Ordinal m _ := i in m.

Definition ord_eqop n (i j : 'I_n) := i == j :> nat.
Lemma ord_eqopP n : Equality.axiom (ord_eqop n).
Definition ord_enum n : seq 'I_n := ... iota 0 n ...
Lemma ord_enumP n : Finite.axiom (ord_enum n).

Definition ord_eqMixin : Equality.mixin ...
Canonical ord_eqType n := Equality.Pack (ord_eqMixin n).
Definition ord_finMixin : Finite.mixin ...
Canonical ord_finType n := Finite.Pack (ord_finMixin n).
\end{coq}

Last line is horrible without the sub-type kit explained afterwards.

An example of ordinals here would be nice.

Now we can declare ordinals an eqtype and a fintype, since we have the
enumeration and comparison.  Note that the comparison simply ignores
the proof component: two ordinals are equal iff their integer values
are.

Declaring eqType and finType for ordinals required some work.
While the enumeration part is expected, indeed it is the property one
gets by defining the new sub-type, the one about eqtype is not
interesting.  Indeed the \mcbMC{} library provides a kit to transport
properties of a type A to a sub-type of A (described in
Section~\ref{sec:subtypekit}).  In this case the eqtype
for nat in inherited by ordinals.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \mcbLEVEL{2}
% \mcbLEARN{curiosity}
% \mcbPROVIDE{}
% \mcbREQUIRE{}
% \mcbsection{Sub-types in HoTT}

% Recent advances in HoTT identify the class of propositions that have a
% canonical proof, mere propositions, and such class is closed under
% forall quantification, while the one we use is not (only bounded
% forall) but the idea is pretty much the same.  Mere propositions can
% be easily used to form a subtype.

% Also Cyril had other arguments on the fact that one can
% ask less (be more general) and recover all required properties later
% on, but I've to ask him again cause I've forgotten the example.

\mcbLEVEL{1}
\mcbLEARN{}
\mcbPROVIDE{}
\mcbREQUIRE{}
\mcbsection{Finite functions}

\begin{coq}{name=subtdecl}{}
Lemma tnth_default t : 'I_n -> T.
Proof. by rewrite -(size_tuple t); case: (tval t) => [|//] []. Qed.

Definition tnth t i := nth (tnth_default t i) t i.

Section Def.

Variables (aT : finType) (rT : Type).

Inductive finfun_type : predArgType := Finfun of #|aT|.-tuple rT.
  
Definition finfun_of of phant (aT -> rT) := finfun_type. 

Identity Coercion type_of_finfun : finfun_of >-> finfun_type.

Definition fgraph f := let: Finfun t := f in t.

Canonical finfun_subType := Eval hnf in [newType for fgraph].

End Def.

Notation "{ 'ffun' fT }" := (finfun_of (Phant fT)).


Local Notation fun_of_fin_def :=
  (fun aT rT f x => tnth (@fgraph aT rT f) (enum_rank x)).

Local Notation finfun_def := (fun aT rT f => @Finfun aT rT (codom_tuple f)).

Notation "[ 'ffun' x : aT => F ]" := (finfun (fun x : aT => F))
\end{coq}

just recall newtype since it is in 1* section.
recall Phant since the source must be finite and you just want to
write ffun ordinal n.

example playing with ffun.

\begin{coq}{name=subtdecl}{}
Check [ffun i : 'I_4 => i + 2]
\end{coq}

They are finite, hence == if codom is eqtype and fintype if codom is
finite.  All that inherited from tuples.

\begin{coq}{}{}
Definition tuple_eqMixin := Eval hnf in [eqMixin of n.-tuple T by <:].
Canonical tuple_eqType := Eval hnf in EqType (n.-tuple T) tuple_eqMixin.

Variables (n : nat) (T : finType).

Canonical tuple_finMixin := Eval hnf in FinMixin (@FinTuple.enumP n T).
Canonical tuple_finType := Eval hnf in FinType (n.-tuple T) tuple_finMixin.
Canonical tuple_subFinType := Eval hnf in [subFinType of n.-tuple T].

Lemma card_tuple : #|{:n.-tuple T}| = #|T| ^ n.
\end{coq}

See how easy one can add new datatypes and relate them to existing one
via the subtype kit.

An application of ffun is

\begin{coq}{}{}
Lemma bigA_distr_bigA (I J : finType) F :
  \big[*%M/1]_(i : I) \big[+%M/0]_(j : J) F i j
    = \big[+%M/0]_(f : {ffun I -> J}) \big[*%M/1]_i F i (f i).
\end{coq}

$$
\prod_{i \in I} \sum_{j \in J} F i j = \sum_{f \in I \to J} \prod_{i \in I} F i (f i)
$$


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbLEARN{}
\mcbPROVIDE{}
\mcbREQUIRE{}
\mcbsection{Matrix}

all together to achieve compact notation.

\begin{coq}{}{}
Inductive matrix : predArgType := Matrix of {ffun 'I_m * 'I_n -> R}.

Definition mx_val A := let: Matrix g := A in g.

Canonical matrix_subType := Eval hnf in [newType for mx_val].

Coercion fun_of_matrix : matrix >-> Funclass.

Definition mxtrace (A : 'M[R]_n) := \sum_i A i i.
Local Notation "'\tr' A" := (mxtrace A) : ring_scope.

\end{coq}

note how ordinals infer everything in tr

\begin{coq}{}{}
Lemma mxtrace_mulC m n (A : 'M[R]_(m, n)) B :
   \tr (A *m B) = \tr (B *m A).
Proof.
have expand_trM C D: \tr (C *m D) = \sum_i \sum_j C i j * D j i.
  by apply: eq_bigr => i _; rewrite mxE.
rewrite !{}expand_trM exchange_big /=.
by do 2!apply: eq_bigr => ? _; apply: mulrC.
Qed.
\end{coq}

put gen have.

another example is multiplication and matrix in extension

\begin{coq}{}{}
Notation "''M[' R ]_ ( m , n )" := (matrix R m n) (only parsing): type_scope.
Notation "\matrix_ ( i  , j  ) E" := ...

Definition mulmx {m n p} (A : 'M_(m, n)) (B : 'M_(n, p)) : 'M[R]_(m, p) :=
  \matrix[mulmx_key]_(i, k) \sum_j (A i j * B j k).

Local Notation "A *m B" := (mulmx A B) : ring_scope.
\end{coq}

note the type making it impossible to multiply wrong matrices

determinant and ffun

\begin{coq}{}{}

(* The determinant, in one line with the Leibniz Formula *)
Definition determinant n (A : 'M_n) : R :=
  \sum_(s : 'S_n) (-1) ^+ s * \prod_i A i (s i).

Lemma det_mulmx n (A B : 'M[R]_n) : \det (A *m B) = \det A * \det B.
Proof.
rewrite big_distrl /=.
pose F := ('I_n ^ n)%type; pose AB s i j := A i j * B j (s i).
transitivity (\sum_(f : F) \sum_(s : 'S_n) (-1) ^+ s * \prod_i AB s i (f i)).
  rewrite exchange_big; apply: eq_bigr => /= s _; rewrite -big_distrr /=.
  congr (_ * _); rewrite -(bigA_distr_bigA (AB s)) /=.
  by apply: eq_bigr => x _; rewrite mxE.
rewrite (bigID (fun f : F => injectiveb f)) /= addrC big1 ?add0r => [|f Uf].
  rewrite (reindex (@pval _)) /=; last first.
    pose in_Sn := insubd (1%g : 'S_n).
    by exists in_Sn => /= f Uf; first apply: val_inj; apply: insubdK.
  apply: eq_big => /= [s | s _]; rewrite ?(valP s) // big_distrr /=.
  rewrite (reindex_inj (mulgI s)); apply: eq_bigr => t _ /=.
  rewrite big_split /= mulrA mulrCA mulrA mulrCA mulrA.
  rewrite -signr_addb odd_permM !pvalE; congr (_ * _); symmetry.
  by rewrite (reindex_inj (@perm_inj _ s)); apply: eq_bigr => i; rewrite permM.
transitivity (\det (\matrix_(i, j) B (f i) j) * \prod_i A i (f i)).
  rewrite mulrC big_distrr /=; apply: eq_bigr => s _.
  rewrite mulrCA big_split //=; congr (_ * (_ * _)).
  by apply: eq_bigr => x _; rewrite mxE.
case/injectivePn: Uf => i1 [i2 Di12 Ef12].
by rewrite (determinant_alternate Di12) ?simp //= => j; rewrite !mxE Ef12.
Qed.
\end{coq}

\mcbLEVEL{2}
\mcbsubsection{blocks and casts}

Casts and block\_mx.

