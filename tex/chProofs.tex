\Chapter{What is a (Coq) proof\\The syntax of proofs}{Constructing proofs as programs}

% From calculability to proofs, hence the CC, and the fact that
% reasoning principles without a computational content become axioms.
%
% This is a non technical chapter and message should be:
% \begin{itemize}
% \item instantiation of a universal statement is application (also the pair)
% \item Excluded middle is not available by default (choice?)
% \item Conversion as a pervasive indistinguishably, what inside
%   (beta, definition unfolding,...)
% \item Dependent types: eq, sigma (which example?)
% \end{itemize}
%
% One options is: avoid relating type theory and other logics. We say:
% we have a formal game where the basic elements are programs/functions
% that come with types to avoid confusion. full stop. (no relation with
% proof theory, set theory). maybe mention that roots are in calculability (hence
% the choice to pick functions as primitive and not sets). This is lucky because
% (computable) functions are today executable by a computer.  Still not all
% concepts are "computable" hence some principles are problematic: EM,.... we
% mainly stay in the lucky fragment (again no propaganda on intuitionistic logic,
% constructive math; just a mention).
%

running topic: statements and their proofs. This chapter provides a gentle
introduction to the implicative fragment of the logic and to the
interactive construction of formal proofs. The reference to
Curry-Howard should come as late as possible. It should indeed be
possible to present a substantial amount of example and intuitions
before explaining this. Specially if we carefully use the automated
introduction of variables bound before the semi-column. At the tactic
level, we should be able to avoid the need for Curry Howard related
constructions like \C{apply: (H x)} in the first part of the chapter.

\begin{itemize}
\item \C{Prop} as the type of statements
\item forall-lambda, predicates as functions to Prop.  The difference with the forall in the previous chapter is that the type the var ranges in is not "Type" but a data type like nat.
\item examples with implicative predicate logic, modus ponens
\item definition = lemma (proofs of implications are lambdas-app)
\item tactics to generate the terms in a less pedestrian way (move, apply)
\item if one calls Show Proof in the middle he sees one is building
	the proof term incrementally, as one draws a proof tree (in CH style)
\end{itemize}

Now we make the point of Qed, the kernel checks the term produced via
tactics (or hand-written).

Examples of predicates: equality
\begin{itemize}
\item not to talk about indexes of inductive families we introduce eq as
	an axiom and refl as another axiom to prove eq and we insist on
	conversion
\item examples, among which a beta expansion (to help later on with elimination)
\item now, what are the proofs of an equality? maybe we start with rewrite
\item examples are symmetry, transitivity
\item then we give the elimination principle as an axiom, and explain the
	work rewrite does in synthesizing the predicate
\item the job of rewrite is not trivial nor un-ambiguous: to drive the synthesis show occurrence selection (later on we see the same problem for elim)
\item other exercise on other eq related "commands" like discriminate, injection arrows, congr.
\end{itemize}

Showing universal properties on inductive data
\begin{itemize}
\item first enouce some lemmas on concrete examples, like not true = false,
	then try to say "froall b : bool, ...".
\item first on enumerated types (bool) via case
\item them on nat via case and elim
\item then show the proof term as an application of nat-rect, again the problem
	is to write down P and elim does that.
\item here an additional problem: loading the goal before using it to generate P
\end{itemize}

We should manage to prove stuff on the concepts defined in chapter 1,
notably \C{odd(a+b) = xor (odd a) (odd b)}.  But before you need lemmas
on "odd (S x) = not (odd x)", to make the point that the proof is trivial with
a library that has all the needed facts.  Also the base case goes away by ssr (in general spell out where the computation saves work).

Comparison with other approaches:
\begin{itemize}
\item Compare an axiomatic, equational presentation of arithmetic to
  its formalization as an inductive type with functions that
  compute.
\end{itemize}


Another example is set-nth of rcons as done by Florent Hivert, that has not
developed the theory of set-nth with cat, and hence messes up the proof
that gets shorter if one does the homework.

Another example could be a proof that requires the induction principle
on nat that (strong/course of values induction).

A maybe good example that forces you to do patterns or occ numbers and explain
that 2  contains syntactically 0 is the proof that code/decode cancel (in
choice).

We lack example with a mathematical interest, maybe arithmetic is sufficient like binomial.v.

We need also /= and hence Arguments simple never (and we try to omit nosimpl).
Maybe we should document that nosimpl has been superseeded by
the option of Arguments in the manual.
Let say that controlling reduction is an important topic when you
do ssr style.

In this chapter we present several features of the proof language, but it it is
not about the proof language itself (reference manual). What one adds to the
reference manual here is an example of usage in the right context of the
commands.  E.g. we give an hint of what patterns do (rewrite) but we don't
discuss all the matching discipline... nor the most advanced syntaxes)

\section{Equality, proofs of equality}

Coq comes with an equality predicate, that we see as axiomatic for the
moment (in this section). It is called \C{eq} and has an infix
notation \C{=}. Can we avoid talking about \C{Prop} at this stage?

\begin{coq}{}
Check eq  (* : forall A : Type, A -> A -> Prop *)
Notation "x = y" := eq _ x y.
\end{coq}

Now we can state equalities and prove some of them, showing along the way
that equality is modulo computation (or is it too early?). This could
be our first interactive proof script:

\begin{coq}{}
Lemma toto1 : 3 + 2 = 5. by []. Qed.
\end{coq}

and we comment the different parts of this sentence.  Other examples
of proofs, this time by rewriting (assumptions stated
outside of the goal). Soft intro to pattern matching of \C{(_ + _)}

Examples could be to prove trans/symmetry of eq via rewrite (no proof terms
here).

Show \C{rewrite -H}, plus the idea that one may want to select
occurrences (with simple patterns).

Proofs can be done by case analysis, like brute force
proofs of boolean tautologies: Start with simple tests, analogues of
the example on numbers.

\begin{coq}{}
Lemma l1 : true && false = false. by []. Qed.
Lemma l2 : false && false = false. by []. Qed.
\end{coq}

An other example on nats:

\begin{coq}{}
Lemma eqn_refl (x : nat) : eqn x x = true.
\end{coq}

Then show that we also want

\begin{coq}{}
Lemma andbF b : b && false = false
\end{coq}

and hence easoning by cases. Now the analogue for nat:

\begin{coq}{}
Lemma addnC x : x + 0 = x.
\end{coq}

requires induction.

We also need ways to control computations of symbolic stuff,
Arguments simpl, or write the equations or \C{/=} and similar.


 Can we already show how \C{= true} can be used
in programs? We can also introduce basic proofs by recurrence like
\C{addnC}.

At which moment do we start using the coercion \C{is_true}? Anyhow, it
should be in this chapter.

May be should we say rather early that rewriting under binders is not
allowed by the system.
\section{Implication, universal quantification}

\subsection{Implication}
Here we need to introduce \C{Prop}, which is like \C{Type} but for provable
things. compare the source and target of arrows.

\begin{coq}{}
Inductive |*list*| (A : Type) : Type :=
    nil : list A | cons : A -> list A -> list A

list: Type -> Type

Definition |*is_equal_to_2*| (x : nat) : x = 2.

is_equal_to_2 : nat -> Prop
\end{coq}

Note: impredicativity is out of topic here.

We then show more examples of interactive proof scripts, introducing
(simple) \C{apply} and introduction steps. More examples of proofs by
induction?

\subsection{Universal quantification}

In fact all the statements that we have proved so far with parameters
are universally quantified statements. They use the same \C{forall} as
the one we saw on types.

\begin{coq}{}
nil   : forall A : Type, (seq A : Type)
andbF : forall b : bool, (b && false = b : Prop)
\end{coq}

Show the \C{move} tactic. Is this the place were we start talking
about CH? If so this is were we put:

Implication is arrow, Lemma = Definition.
Curry-Howard (terms are proofs)

\begin{coq}{}
Variable A : Prop.
Definition toto : A -> A := fun x => x.
Lemma  toto : A -> A.
 Proof.
  move => x.
  Show Proof.
  apply: x.
 Qed.
\end{coq}

Note : \C{toto :  A -> A : Prop}
discuss interactive proof construction, other example with a real
apply that open subgoals.

In CH style we see a proof, where lambdas/apply work too (same tactics)

Specialization of an quantified lemma via application (maybe also
\C{move/(_ x) in H}).
Soft intro of the work of unification (FO) during application (infer
arguments of conclusion's predicate symbol \C{prime _}).

We should also display her  HO "predicators": commutative.  Discuss
order of quantification in transitive and similar, naming conventions

\section{Curry-Howard for equality proofs}

\subsection{proof term for rewrite (CH)}

There are also proof terms for equality proofs (show \C{refl})
The work rewrite does is non trivial (infer P)

\begin{coq}{}
Check eq_rect (* : forall P : nat -> Prop, .... forall n, P n *)
\end{coq}

Write a proof term by hand.
(note that it works because of beta being part of conversion).
See that rewrite does the verbose part for you (infer P).

An example of ambiguous P from above, driving rewrite means driving the
synthesis of P.

\subsection{other eq related tactics}

Congr, injection \C{[= ]}, discriminate (//), \C{->}.


\subsection{proof term for induction}

Again show that it boils down to infer P


\subsection{proofs by induction in their generality}

Show that even for commutativity of addition one needs to
"load the goal" (or to help synthesize a more general P).


\section{Exercises (explained)}

xor-odd, then cancel encode decode, or something on primes.

Take the occasion to present last/first, bullets, by, syntaxes for
\C{=> [|IH x xs]} after a case.
