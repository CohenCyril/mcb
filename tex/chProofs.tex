\Chapter{Statements and proofs}{First steps in formal proofs}

\section{Equality}

\begin{itemize}
\item Coq comes with an equality predicate, that we see as axiomatic for the
moment (in this section). It is called \C{eq} and has an infix
notation \C{=}. Example: \C{Check 3 = 3}, \C{Check 3 = 4}.
\item Observe that, \C{Check} just checks the well-formedness of the
  statement, not its truth. Well-formedness here means that \C{=}
  requires both hand-sides to be of the same type.
  Example \C{Check 3 = [::4]}. Observe that statement also have a
  type, called \C{Prop}.
\item We can give a name to a statement, that we would like to prove
  formally. Example \C{Lemma foo : 3 = 3}. Observe what happens at the
  level of the interface (we start a proof).
\item And now, how to prove equality statements. Observationaly, \C{=}
  behaves as expected: this is trivally true because \C{=} is
  reflexive.
\item End of the proof, \C{Qed}.
\item Now we have a theorem called \C{foo} at hand in the
  environement: \C{Check foo}. We can use it but it is useless...
\item In fact the libraries you load provide theorems that you can use
  in your proofs. Example:  \C{Check add0n}, \C{Check addnC}. Note the
  universal quantification.
\item How to state lemmas like this:
\C{Example toto a b : 0 + (a + b) = a + b}.
\item Equality is not just reflexive, it is also substitutive. This is
  implemented via the \C{rewrite} tactic, that we can use to prove
  this lemma, using \C{add0n}. Note that the tactic found the right
  instance of \C{add0n} to be used, with \C{(a + b)}.
\item \C{Qed}, \C{Check}, observe the universal quantification.
\item Rewrite steps can be chained, in order. Example:
\C{Example toto a b : 0 + (a + b) = b + a}. can be proved by rewriting
\C{add0n} then, \C{addnC}. Note that \C{addnC} then \C{add0n} does
something different.
\item In fact reflexivity is more than syntactic equality. Prove
\C{3 + 1 = 4}, \C{true || false = true}. But also with variables,
e.g. \C{add0n}, connect with the programs written in the previous
chapters.

\item More advanced forms of proofs by the \C{rewrite} tactic allow to
  select a pattern and to simplify the goal for free by
  computation. Hence \C{addn0} just does not need to be stated
  explicitely in the proof script. Warning: simpl is a Pandora
  box. This should come very early
  and go with/before boolean reflection style proofs by rewriting.

\item Special case of equality statements that play a pervasive role
  throughout the libraries: \C{_ = true}. For instance
  \C{odd (2 * x + 7) = true}. This is both a 'logical' statement,
  saying that any expression \C{(2x+7)} is an odd number, and
  an equation that can be rewriten during the course of a proof. Find
  an example, like \C{odd (2 * x + 7) || odd (2 * x)}. rewrite and
  compute.

\item Now we should point the coercion, because people will search and
  check.
\end{itemize}



\section{Case analysis}

Proofs can be done by case analysis, like brute force
proofs of boolean tautologies: Start with simple tests, analogues of
the example on numbers.

\begin{coq}{}
Lemma l1 : true && false = false. by []. Qed.
Lemma l2 : false && false = false. by []. Qed.
\end{coq}

An other example on nats:

\begin{coq}{}
Lemma eqn_refl (x : nat) : eqn x x = true.
\end{coq}

Then show that we also want

\begin{coq}{}
Lemma andbF b : b && false = false
\end{coq}

and hence reasoning by cases.


\section{Hypotheses, implications}

Here comes \C{apply}. The ambiguity will be explained later in the CH
section.


\section{Proofs by induction}

\begin{coq}{}
Lemma addnC x : x + 0 = x.
\end{coq}

requires induction.

\section{Curry-Howard}

Explain CH for arrows, foralls, equality and induction. Show Proof for
some examples of proofs.

First implication, start with comparing the source and target of the
arrows that are common to this chapter and the preceeding.

\begin{coq}{}
Inductive |*list*| (A : Type) : Type :=
    nil : list A | cons : A -> list A -> list A

list: Type -> Type

Definition |*is_equal_to_2*| (x : nat) : x = 2.

is_equal_to_2 : nat -> Prop
\end{coq}






\section{To be sorted}

\subsection{Universal quantification}

\begin{coq}{}
Variable A : Prop.
Definition toto : A -> A := fun x => x.
Lemma  toto : A -> A.
 Proof.
  move => x.
  Show Proof.
  apply: x.
 Qed.
\end{coq}

Note : \C{toto :  A -> A : Prop}
discuss interactive proof construction, other example with a real
apply that open subgoals.

In CH style we see a proof, where lambdas/apply work too (same tactics)

Specialization of an quantified lemma via application (maybe also
\C{move/(_ x) in H}).
Soft intro of the work of unification (FO) during application (infer
arguments of conclusion's predicate symbol \C{prime _}).

We should also display her  HO "predicators": commutative.  Discuss
order of quantification in transitive and similar, naming conventions

\subsection{Curry-Howard for equality proofs}


Show \C{rewrite -H}, plus the idea that one may want to select
occurrences (with simple patterns).


May be should we say rather early that rewriting under binders is not
allowed by the system.

\subsection{proof term for rewrite (CH)}

There are also proof terms for equality proofs (show \C{refl})
The work rewrite does is non trivial (infer P)

\begin{coq}{}
Check eq_rect (* : forall P : nat -> Prop, .... forall n, P n *)
\end{coq}

Write a proof term by hand.
(note that it works because of beta being part of conversion).
See that rewrite does the verbose part for you (infer P).

An example of ambiguous P from above, driving rewrite means driving the
synthesis of P.

\subsection{other eq related tactics}

Congr, injection \C{[= ]}, discriminate (//), \C{->}.


\subsection{proof term for induction}

Again show that it boils down to infer P


\subsection{proofs by induction in their generality}

Show that even for commutativity of addition one needs to
"load the goal" (or to help synthesize a more general P).


\section{Exercises (explained)}

xor-odd, then cancel encode decode, or something on primes.

Take the occasion to present last/first, bullets, by, syntaxes for
\C{=> [|IH x xs]} after a case.


\section{Notes}

% From calculability to proofs, hence the CC, and the fact that
% reasoning principles without a computational content become axioms.
%
% This is a non technical chapter and message should be:
% \begin{itemize}
% \item instantiation of a universal statement is application (also the pair)
% \item Excluded middle is not available by default (choice?)
% \item Conversion as a pervasive indistinguishably, what inside
%   (beta, definition unfolding,...)
% \item Dependent types: eq, sigma (which example?)
% \end{itemize}
%
% One options is: avoid relating type theory and other logics. We say:
% we have a formal game where the basic elements are programs/functions
% that come with types to avoid confusion. full stop. (no relation with
% proof theory, set theory). maybe mention that roots are in calculability (hence
% the choice to pick functions as primitive and not sets). This is lucky because
% (computable) functions are today executable by a computer.  Still not all
% concepts are "computable" hence some principles are problematic: EM,.... we
% mainly stay in the lucky fragment (again no propaganda on intuitionistic logic,
% constructive math; just a mention).
%

running topic: statements and their proofs. This chapter provides a gentle
introduction to the implicative fragment of the logic and to the
interactive construction of formal proofs. The reference to
Curry-Howard should come as late as possible. It should indeed be
possible to present a substantial amount of example and intuitions
before explaining this. Specially if we carefully use the automated
introduction of variables bound before the semi-column. At the tactic
level, we should be able to avoid the need for Curry Howard related
constructions like \C{apply: (H x)} in the first part of the chapter.

\begin{itemize}
\item \C{Prop} as the type of statements
\item forall-lambda, predicates as functions to Prop.  The difference with the forall in the previous chapter is that the type the var ranges in is not "Type" but a data type like nat.
\item examples with implicative predicate logic, modus ponens
\item definition = lemma (proofs of implications are lambdas-app)
\item tactics to generate the terms in a less pedestrian way (move, apply)
\item if one calls Show Proof in the middle he sees one is building
	the proof term incrementally, as one draws a proof tree (in CH style)
\end{itemize}

Now we make the point of Qed, the kernel checks the term produced via
tactics (or hand-written).

Examples of predicates: equality
\begin{itemize}
\item not to talk about indexes of inductive families we introduce eq as
	an axiom and refl as another axiom to prove eq and we insist on
	conversion
\item examples, among which a beta expansion (to help later on with elimination)
\item now, what are the proofs of an equality? maybe we start with rewrite
\item examples are symmetry, transitivity
\item then we give the elimination principle as an axiom, and explain the
	work rewrite does in synthesizing the predicate
\item the job of rewrite is not trivial nor un-ambiguous: to drive the synthesis show occurrence selection (later on we see the same problem for elim)
\item other exercise on other eq related "commands" like discriminate, injection arrows, congr.
\end{itemize}

Showing universal properties on inductive data
\begin{itemize}
\item first enouce some lemmas on concrete examples, like not true = false,
	then try to say "froall b : bool, ...".
\item first on enumerated types (bool) via case
\item them on nat via case and elim
\item then show the proof term as an application of nat-rect, again the problem
	is to write down P and elim does that.
\item here an additional problem: loading the goal before using it to generate P
\end{itemize}

We should manage to prove stuff on the concepts defined in chapter 1,
notably \C{odd(a+b) = xor (odd a) (odd b)}.  But before you need lemmas
on "odd (S x) = not (odd x)", to make the point that the proof is trivial with
a library that has all the needed facts.  Also the base case goes away by ssr (in general spell out where the computation saves work).

Comparison with other approaches:
\begin{itemize}
\item Compare an axiomatic, equational presentation of arithmetic to
  its formalization as an inductive type with functions that
  compute.
\end{itemize}


Another example is set-nth of rcons as done by Florent Hivert, that has not
developed the theory of set-nth with cat, and hence messes up the proof
that gets shorter if one does the homework.

Another example could be a proof that requires the induction principle
on nat that (strong/course of values induction).

A maybe good example that forces you to do patterns or occ numbers and explain
that 2  contains syntactically 0 is the proof that code/decode cancel (in
choice).

We lack example with a mathematical interest, maybe arithmetic is sufficient like binomial.v.

We need also /= and hence Arguments simple never (and we try to omit nosimpl).
Maybe we should document that nosimpl has been superseeded by
the option of Arguments in the manual.
Let say that controlling reduction is an important topic when you
do ssr style.

In this chapter we present several features of the proof language, but it it is
not about the proof language itself (reference manual). What one adds to the
reference manual here is an example of usage in the right context of the
commands.  E.g. we give an hint of what patterns do (rewrite) but we don't
discuss all the matching discipline... nor the most advanced syntaxes)
