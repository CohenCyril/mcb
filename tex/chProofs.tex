\chapter{What is a (Coq) proof\\The syntax of proofs\\[2ex]\Large\itshape Constructing proofs as programs}

% From calculability to proofs, hence the CC, and the fact that
% reasoning principles without a computational content become axioms.
%
% This is a non technical chapter and message should be:
% \begin{itemize}
% \item instantiation of a universal statement is application (also the pair)
% \item Excluded middle is not available by default (choice?)
% \item Conversion as a pervasive indistinguishably, what inside
%   (beta, definition unfolding,...)
% \item Dependent types: eq, sigma (which example?)
% \end{itemize}
%
% One options is: avoid relating type theory and other logics. We say:
% we have a formal game where the basic elements are programs/functions
% that come with types to avoid confusion. full stop. (no relation with
% proof theory, set theory). maybe mention that roots are in calculability (hence
% the choice to pick functions as primitive and not sets). This is lucky because
% (computable) functions are today executable by a computer.  Still not all
% concepts are "computable" hence some principles are problematic: EM,.... we
% mainly stay in the lucky fragment (again no propaganda on intuitionistic logic,
% constructive math; just a mention).
%

running topic: statements and their proofs, as in curry howard and
tactics.

\begin{itemize}
\item \C{Prop} as the type of statements
\item forall-lambda, predicates as functions to Prop.  The difference with the forall in the previous chapter is that the type the var ranges in is not "Type" but a data type like nat.
\item examples with implicative predicate logic, modus ponens
\item definition = lemma (proofs of implications are lambdas-app)
\item tactics to generate the terms in a less pedestrian way (move, apply)
\item if one calls Show Proof in the middle he sees one is building
	the proof term incrementally, as one draws a proof tree (in CH style)
\end{itemize}

Now we make the point of Qed, the kernel checks the term produced via
tactics (or hand-written).

Examples of predicates: equality
\begin{itemize}
\item not to talk about indexes of inductive families we introduce eq as
	an axiom and refl as another axiom to prove eq and we insist on
	conversion
\item examples, among which a beta expansion (to help later on with elimination)
\item now, what are the proofs of an equality? maybe we start with rewrite
\item examples are symmetry, transitivity
\item then we give the elimination principle as an axiom, and explain the
	work rewrite does in synthesizing the predicate
\item the job of rewrite is not trivial nor un-ambiguous: to drive the synthesis show occurrence selection (later on we see the same problem for elim)
\item other exercise on other eq related "commands" like discriminate, injection arrows, congr.
\end{itemize}

Showing universal properties on inductive data
\begin{itemize}
\item first enouce some lemmas on concrete examples, like not true = false,
	then try to say "froall b : bool, ...".
\item first on enumerated types (bool) via case
\item them on nat via case and elim
\item then show the proof term as an application of nat-rect, again the problem
	is to write down P and elim does that.
\item here an additional problem: loading the goal before using it to generate P
\end{itemize}

We should manage to prove stuff on the concepts defined in chapter 1,
notably \C{odd(a+b) = xor (odd a) (odd b)}.  But before you need lemmas
on "odd (S x) = not (odd x)", to make the point that the proof is trivial with
a library that has all the needed facts.  Also the base case goes away by ssr (in general spell out where the computation saves work).

Comparison with other approaches:
\begin{itemize}
\item Compare an axiomatic, equational presentation of arithmetic to
  its formalization as an inductive type with functions that
  compute.
\end{itemize}


Another example is set-nth of rcons as done by Florent Hivert, that has not
developed the theory of set-nth with cat, and hence messes up the proof
that gets shorter if one does the homework.

Another example could be a proof that requires the induction principle
on nat that (strong/course of values induction).

A maybe good example that forces you to do patterns or occ numbers and explain
that 2  contains syntactically 0 is the proof that code/decode cancel (in
choice).

We lack example with a mathematical interest, maybe arithmetic is sufficient like binomial.v.

We need also /= and hence Arguments simple never (and we try to omit nosimpl).
Maybe we should document that nosimpl -> Arguments in the manual.
Let say that controlling reduction is an important topic when you
do ssr style.

In this chapter we present several features of the proof language, but it it is
not about the proof language itself (reference manual). What one adds to the
reference manual here is an example of usage in the right context of the
commands.  E.g. we give an hint of what patterns do (rewrite) but we don't
discuss all the matching discipline... nor the most advanced syntaxes)

This chapter could discuss the merits of a computable plus versus
the relational plus (Peano versus Coq).


\section{Implication, Forall}

Prop is like Type but for provable things. compare the source and target of
arrows.

\begin{coq}{}
list: Type -> Type
prime : nat -> Prop
\end{coq}

Ignore impredicativity here.

Implication is arrow, Lemma = Definition.
Curry-Howard (terms are proofs)

\begin{coq}{}
Variabl A : Prop.
Definition toto : A -> A := fun x => x.
Lemma  toto : A -> A.
 Proof.
  move => x.
  Show Proof.
  apply: x.
 Qed.
\end{coq}
Note : \C{toto :  A -> A : Prop}
discuss interactive proof construction, other example with a real
apply that open subgoals.

\subsection{Qed}

proof checker, Qed/Defined.

\subsection{forall}

\begin{coq}{}
cons: forall A: Type, A -> (seq A : Type)
even_no_prime : forall n : nat, even n -> (not (prime n) : Prop)
\end{coq}



In CH style we see a proof, where lambdas/apply work too (same tactics)

Specialization of an quantified lemma via application (maybe also
\C{move/(_ x) in H}).
Soft intro of the work of unification (FO) during application (infer
arguments of conclusion's predicate symbol \C{prime _}).

\section{Equality}

see eq as an axiom here.

\begin{coq}{}
Check eq  (* : forall A : Type, A -> A -> Prop *)
Check refl (* : forall A, forall x : A, x = x. *)
Notation "x = y" := eq _ x y.
Lemma toto : 3 + 2 = 5.by exact refl.
\end{coq}

discussion about conversion

\subsection{use of equality in proofs via rewrite}

soft intro to pattern matching of \C{(_ + _)}

Examples could be to prove trans/symmetry of eq via rewrite (no proof terms
here)

Show \C{rewrite -H}, plus the idea that one may want to select
occurrences (with simple patterns).

\subsection{proof term for rewrite (CH)}

The work rewrite does is non trivial (infer P)

\begin{coq}{}
Check eq_rect (* : forall P : nat -> Prop, .... forall n, P n *)
\end{coq}

Write a proof term by hand.
(note that it works because of beta being part of conversion).
See that rewrite does the verbose part for you (infer P).

An example of ambiguous P from above, driving rewrite means driving the
synthesis of P.

\subsection{other eq related tactics}

Congr, injection \C{[= ]}, discriminate (//), \C{->}.

\section{Induction}

Start with simple test

\begin{coq}{}
Lemma l1 : true && false = false
Lemma l2 : false && false = false
\end{coq}

But we want

\begin{coq}{}
Lemma andbF : forall b, b && false = false
\end{coq}

Reasoning by cases

The do the same for a nat.

\begin{coq}{}
Lemma addnC x : x + 0 = x.
\end{coq}

We need induction

We also need ways to control computations of symbolic stuff,
Arguments simpl, or write the equations or \C{/=} and similar.

\subsection{proof term for induction}

Again show that it boils down to infer P


\subsection{proofs by induction in their generality}

Show that even for commutativity of addition one needs to
"load the goal" (or to help synthesize a more general P).


\section{Exercises (explained)}

xor-odd, then cancel encode decode, or something on primes.

Take the occasion to present last/first, bullets, by, syntaxes for
\C{=> [|IH x xs]} after a case.
