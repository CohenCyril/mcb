% Some Coq snippets to be used later on
\begin{coqdef}{name=ssr}
Require Import Ssreflect.ssreflect.
From Ssreflect Require Import ssrfun ssrbool ssrnat eqtype seq.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.
\end{coqdef}
\begin{coqdef}{name=abort}
Abort.
\end{coqdef}
\begin{coqdef}{name=qed}
Qed.
\end{coqdef}
\begin{coqdef}{name=done}
by [].
\end{coqdef}
\begin{coqdef}{name=verbose}
Unset Silent.
\end{coqdef}
\begin{coqdef}{name=quiet}
Set Silent.
\end{coqdef}
\begin{coqdef}{name=show1}
Redirect "g1" Show.
\end{coqdef}
\begin{coqdef}{name=show2}
Redirect "g2" Show.
\end{coqdef}

\Chapter{Statements and proofs}{ First steps in formal proofs}
\label{ch:proofs}
% In this chapter we explain how to state a lemma,
% how to prove it, and how to search existing, loaded library.
% We focus here on simple proof commands, conventions and a first taste
% of boolean reflection. Views and the related tactics are postponed to the
% next chapter, and so are conjunctions and existential statements.
The \Coq{} system lets one not only define data types and programs, but
also prove properties about them.  In this chapter we explain how
theorems are stated and proved.  We focus on simple statements and
basic proof commands.  Stating a lemma is a very delicate matter.  Even if two
formulations for the same statements are logically equivalent, one can be much
simpler to prove or invoke in the proof of another theorem.
The approach we follow in the current chapter and that we
fully develop in Chapter~\ref{ch:boolrefl} is paradigmatic in the
\mcbMC{} library and roughly consist in favouring the use of computable
definitions and equational reasoning whenever possible.

\mcbLEARN{Stating basic theorems involving boolean statements,
  equalities, and arrows. Universal quantification is presented via
  parameters.}
\mcbREQUIRE{About, Check, implicit arguments, notations for the
  constants defined at chapter 1, principles of notations
  (associativity,...), definition of 'boolean predicate', sections}
\mcbPROVIDE{\C{Lemma},\C{Admitted}, eq, is-true, Lemma, \C{Prop}, \C{->}}
\mcbLEVEL{1}

\mcbsection{First formal statements}


In this section, we illustrate how to state rather simple (tentative)
theorems, starting with the simplest, and most pervasive, kind of
mathematical sentences: identities.

\subsection{Ground equalities}\label{ssec:groundeq}

\Coq{} provides a binary predicate named \C{eq} and equipped with the
infix notation \C{=}. This predicate is used to write sentences
expressing that two objects are \emph{equal}, like in $2 + 2 = 4$.
Let us start with examples of \Coq{} \emph{ground} equality
statements: \emph{ground} means that these statements do not feature
parameter variables\footnote{For instance $2 + 2 = 4$ is a ground
  statement, but $(a + b)^2 = a^2 + 2ab + b^2$ is not ground.}.

In Chapter~\ref{ch:prog}, we have used the \C{Check}
vernacular command to query the type of a defined object: we can use
the same very same command to \emph{check} whether a formal statement
is well formed:

\begin{coq}{name=check-eq}{width=6cm,title=Equality predicate}
Check 3 = 3.
Check false || true = true.
\end{coq}
\coqrun{name=r1}{ssr,check-eq}
\begin{coqout}{run=r1}{title=Response,width=6cm}
3 = 3 : Prop
false || true = true : Prop
\end{coqout}

Let's anatomize the two above examples. Indeed, just like \Coq{}'s
type system prevents us from applying functions to
arguments of a wrong nature, it also enforces a certain nature of
well-formedness at the time we enunciate sentences that are candidate
theorems. On first important thing to
keep in mind is that, in \Coq{}, formal statements are themselves
\marginnote{Where do we define what are terms and what are types...}
\emph{terms}. And therefore, statements also have a \emph{type}. An
equality statement is obtained by applying the constant \C{eq} to two
arguments, of the same type, which results in a well-formed term of
type \C{Prop}, for \emph{proposition}. Throughout this book, we will
use the word \emph{proposition} for a term of type \C{Prop}, typically
something one wants to prove. The \C{About} vernacular
command, which allows to obtain information on a constant, like its
type and the status of its argument, applies just as well to
propositions and their components. For instance we can learn more
about the constant \C{eq}:

\begin{coq}{name=about}{width=6cm,title=Equality predicate}
About eq.
$~$
\end{coq}
\coqrun{name=abouteq}{about}
\begin{coqout}{run=abouteq}{title=Response,width=6cm}
eq : forall A : Type, A -> A -> Prop
Argument A is implicit ...
\end{coqout}

We learn here that the constant \C{eq} is a \emph{predicate}, i.e. a
function having \C{Prop} as return type. Moreover, the equality
predicate is polymorphic: exactly as we have seen in the previous
chapter the \C{forall} quantifier is used to make the variable \C{A}
range over types\marginnote{What does the display of \C{forall} change between
  listings and inline?}. This is why we were able to use the same equality
constant in both our examples, once for equating two terms of type
\C{nat} and once for equating two terms of type \C{bool}.

\marginnote{Did we say earlier that implicit arguments should not be
  provided? LR:yes}
Its first argument being implicit, it value is not provided by the
user\footnote{The system even raises an error if it is provided.} but
guessed from the type of the hand-sides of the equality we state: \C{(3
= 3)} unfolds to \C{(eq _ 3 3)} and the missing value is set at
\C{nat}, the type of \C{3}. Similarly, \C{(true = false || true)}
unfolds to \C{(eq _ true (false || true))} and the missing value is set
at \C{bool}, the common type of \C{true} and \C{(false || true)}.

As the \Coq{} system checks the well -typedness of statements,
the two hand sides of a well-formed equality should have the same
type:

\begin{coq}{name=check-eq2}{width=4cm,title=Ill-typed Equality}
Check 3 = [:: 3].
$~$
\end{coq}
\coqrun{name=r2;fail}{ssr,check-eq2}
\begin{coqout}{run=r2}{title=Response,width=8cm}
Error: The term "[:: 3]" has type "seq nat"
 while it is expected to have type "nat".
\end{coqout}

Yet it does not check the provability of the statement!

\begin{coq}{name=false-statement}{width=4cm,title=Equality predicate}
Check 3 = 4.
\end{coq}
\coqrun{name=check34}{false-statement}
\begin{coqout}{run=check34}{title=Response,width=8cm}
3 = 4 : Prop
\end{coqout}

In order to establish that a certain equality holds, the user should
first announce that she is going to prove a sentence, using a special
command like \C{Lemma} (or \C{Theorem}, \C{Remark},
\C{Corollary},\dots which are all synonyms for what matters here).
The \C{Lemma} keyword is followed by the name chosen for the lemma and
then by the statement itself. \C{Lemma} (and its siblings) is in fact
a variant of the \C{Definition} syntax we used in
Chapter~\ref{ch:prog}: everything we mentioned about it also applies
here. The \C{Proof} keywords marks the beginning of the proof and
after it is executed, the system displays the current state of the
formal proof in a separated windows.

\begin{coqdef}{name=first-lemma}
Lemma my_first_lemma : 3 = 3.
Proof. Redirect "goal" Show.
\end{coqdef}
\begin{coq}{def=first-lemma}{width=6cm,title=Starting a proof}
Lemma |*my_first_lemma*| : 3 = 3.
Proof.
\end{coq}
\coqrun{name=r3}{ssr,first-lemma,abort}
\begin{coqout}{run=r3;out=goal}{title=Response,width=6cm}
1 subgoal

  ============================
   3 = 3
\end{coqout}
Indeed, \Coq{} is now in so-called \emph{proof mode}. The
current proof state consists in a list of named hypotheses, on top of
the horizontal bar (empty here), and the statement of the current goal
below the bar.

\marginnote{Is is an ok transition? Lemma is needed to postpone forall...}
Before explaining in section~\ref{ssec:proofcomp} how to proceed with
such a proof, we will spend the rest of the present section with
a tour of slightly more complex formal statements.
For now, let us then just admit this result, using the \C{Admitted}
command:

\begin{coq}{name=first-lemma-admitted}{width=6cm,title=Aborting a proof}
Lemma my_first_lemma : 3 = 3.
Admitted.
\end{coq}

Although we have not (yet) provided a proof for this lemma, a new
definition has been added to our environment:

\begin{coq}{name=about-first-lemma}{width=6cm,title= My first lemma}
About my_first_lemma.
\end{coq}
\coqrun{name=about}{ssr,first-lemma-admitted,about-first-lemma}
\begin{coqout}{run=about}{title=Response,width=6cm}
my_first_lemma : 3 = 3
...
\end{coqout}

\marginnote{I guess it is too early to say that this is a
  type... Shall we mention Print Assumptions here?}

\subsection{Identities}\label{ssec:id}


Ground equalities are just a very special case of mathematical
statements called \emph{identities}. An \emph{identity} is an equality
relation $A = B$, which holds regardless of the values that are
substituted for the variables in $A$ and $B$.
Let us state for instance the identity expressing the associativity of
the addition operation \C{addn} on natural numbers:

\begin{coq}{name=addnA}{width=6cm,title=Stating quantified lemmas}
Lemma addnA (n m k : nat) :
  n + (m + k) = m + n + k.
Proof.
\end{coq}
\coqrun{name=addnA}{ssr,addnA,show1,abort}
\begin{coqout}{run=addnA;out=g1}{title=Response,width=6cm}
1 subgoal

 n, m, k : nat
 ============================
  n + (m + k) = m + n + k
\end{coqout}

Note that in the statement of \C{addnA}, the right hand side does not
feature any parentheses but should be read \C{((m + n) + k)}: this
associativity has been prescribed at the definition time of the infix
\C{+} notation.\marginnote{Has this been explained in chapter 1?} Also
\C{Lemma}, just like \C{Definition}, allows for
dropping type annotations if these types can be inferred from the
statement itself:

\begin{coq}{name=addnA2}{title=Stating quantified lemmas}
Lemma addnA n m k : n + (m + k) = m + n + k.
Admitted.
\end{coq}

\marginnote{ I am cheating here and I do not use the associative
  predicator... And the display here is related to the tuning of
  notations (wrt associativity) shall we say a word about it at this
  stage?}

Boolean identities are an important special class of identities. For
instance, the~\C{orbT} statement expresses that \C{true} is a left
neutral for the boolean disjunction operation \C{orb}. Recall that
\C{orb} is equipped with the \C{||} infix notation:

\begin{coq}{name=orbT}{title=A boolean identity}
Lemma orbT b : b || true = true.
Admitted.
\end{coq}


More precisely, lemma \C{orbT}
expresses that the truth table of the boolean formula $b \vee \top$
coincides with the (constant) one of $\top$: otherwise said that the
two propositional formulae are equivalent, or that $b \vee \top$ is a
propositional tautology. We provide below some other examples of such
propositional equivalences stated as boolean identities.
\marginnote{LR: is it clear that $\top$ is true?}

\begin{coq}{name=orbA}{title=Boolean conjunction is associative}
Lemma orbA b1 b2 b4 :
  b1 || (b2 || b3) = b1 || b2 || b3.
\end{coq}

\begin{coq}{name=implybE}{title=Examples of boolean identities}
Lemma implybE a b : (a ==> b) = ~~ a || b.
Admitted.

Lemma negb_and (a b : bool) : ~~ (a && b) = ~~ a || ~~ b.
Admitted.
\end{coq}

\marginnote{I put examples of classical identity on purpose. What
  else? may be some very easy first exercises?}


\subsection{From boolean predicates to formal statements}

More generally, boolean identities involve arbitrary boolean
predicates (not only boolean connectives) and feature variables of
an arbitrary type (not only of type \C{bool}).
\marginnote{Make sure  ``boolean predicate'' is introduced in the
previous chapter. LR: no, boolean are introduced as a ind. type but not the notion of boolean predicate.} For instance, we can state
that for any term \C{n : nat}, the following comparison holds:

\begin{coq}{name=leq0n}{title=Stating that a boolean predicate holds}
Lemma leq0n (n : nat) : 0 <= n = true.
\end{coq}
We are expressing here that the statement $0 \leq n$ holds, because
the truth value of the boolean \C{(0 <= n)} is \C{true}, whatever
term  of type \C{nat} is substituted for the parameter \C{n} in the
statement. In section~\ref{ssec:case}, we will see how to build a
formal proof of such a statement.

Given how frequently we state that a boolean predicate is
equal to true, we are going to omit the ``\C{.. = true}''
part of the statements.  Indeed \Coq{} is able to insert such
piece of ``text'' automatically, whenever it fits.
The \Coq{} mechanism for doing that is out of scope here, it 
will be explained in Section~\ref{sec:coercions}.

\begin{coq}{name=coercion}{title=Coercion}
Lemma leq0n (n : nat) : 0 <= n.
\end{coq}

%In all what follows, we suppose that the coercion is set.
\marginnote{May be show more examples/exercises of statements that
  equate something to true, to make the reader feel the need for the
  coercion.}

We can express that more boolean statements are equivalent using
identities, generalizing the examples of propositional tautologies we
gave in section~\ref{ssec:id}. Here is a few examples, built with the
boolean predicate on natural numbers that we crafted in
Chapter~\ref{ch:prog}: the boolean equality \C{==} and its negation
\C{!=}, the order relation \C{<} and its large version \C{<=}, and the
divisibility predicate \L+%|+.
We omit the type of the parameters, for the sake of
conciseness.\marginnote{At some point, explain the naming conventions
  on bound variables and the use of Implicit Types.}

\begin{coq}{name=equivalences}{title=Examples of equivalences}
Lemma eqn_leq m n : (m == n) = (m <= n) && (n <= m).
Admitted.

Lemma neq_ltn m n : (m != n) = (m < n) || (n < m).
Admitted.

Lemma leqn0 n : (n <= 0) = (n == 0).
Admitted.

Lemma dvdn1 d : (d %| 1) = (d == 1)
Admitted.

Lemma odd_mul m n : odd (m * n) = odd m && odd n.
Admitted.
\end{coq}
\marginnote{Also, at this stage, we have two ways of stating
  equalities between say two natural numbers. It is probably too early
to discuss this but we should do it somewhere in this section.}


\subsection{Conditional statements}

In the previous sections, we have seen statements of unconditional
identities, either equalities between ground terms or identities which
hold for \emph{any} value of their parameters. A property which holds
only when some condition is verified by its parameters is stated using an
\marginnote{This might conflit with the boolean \C{==>} seen on an
  example two sections ago... Shall we discuss this? and say that the
  present one opens a subgoal for instance?}
  \emph{implication}.  The \Coq{} syntax for such connective
  is ``\C{->}''.  For instance:
 % \marginnote{Shall we also introduce here the other idioms like \L+\{in _, _\}+? Or in the next chapter?} 

\begin{coq}{name=implication}{title=Implication sentences}
Lemma leq_pmull m n : n > 0 -> m <= n * m.
Admitted.

Lemma odd_gt0 n : odd n -> n > 0.
Admitted.
\end{coq}

The attentive reader might have noticed that this arrow \C{->} is the
same as the one we have used in chapter~\ref{ch:prog} in order to
represent function types. This is no accident, but we will explain
this phenomenon later in section~\ref{sec:chi}. For now let us remark
that \C{->} associates on the right: therefore a succession of arrows
expressed a conjunction of hypotheses:

\begin{coq}{name=dvdn-mul}{title=A (multi)conditional statement}
Lemma dvdn_mul d1 d2 m1 m2 :
  d1 %| m1 -> d2 %| m2 -> d1 * d2 %| m1 * m2
Admitted.
\end{coq}

\marginnote{Currification deserves more comments but it is probably too
  early... Also I think it is a good place to talk about sections here
as well, but it has probably been introduced somewhere in the previous
chapter? LR: yes}

The \C{Section} mechanism we saw in Chapter~\ref{ch:prog} is also
convenient in order to factor the parameters and the hypotheses shared
by a handful of lemmas. Yet beware, all the parameters are then fixed
inside the section (as well as hypotheses but that's less often
problematic). However we cannot really make sense from this remark as
long as we do not explain formal proofs in more details...

\mcbLEARN{Commands to build and check formal proofs: trivial ones,
  case analysis, rewriting}
\mcbREQUIRE{computation, equality}
\mcbPROVIDE{eq, is-true, \C{rewrite, case, by []}}
\mcbLEVEL{1}
\mcbsection{Formal proofs}

We shall now explain how to turn a well-formed statement into a
machine-checked theorem. Let us come back to our first example, that
we left unproved:
\begin{coq}{name=my-first-proof1}{title=Starting a proof}
Lemma my_first_lemma : 3 = 3.
Admitted.
\end{coq}
In the \Coq{} system, the user builds a formal proof by providing,
interactively, instructions to the proof assistant part of the \Coq{}
system, that describe the gradual construction of the proof she has in
mind. This list of instructions is called a \emph{proof script}, and
the instructions it is made of are called proof commands, or more traditionally
\emph{tactics}.\marginnote{I can't bare with it, I hate ``tactic''.}

\begin{coq}{name=my-first-proof2}{title=Starting a proof}
Lemma my_first_lemma : 3 = 3.
Proof.
(* <your proof script comes here> *)
Admitted.
\end{coq}

Once the proof is complete, we can replace the \C{Admitted} command by
the \C{Qed} one. This calls the proof checker part of  the \Coq{}
system, which validates a posteriori that the formal proof that has
been built so far is actually hole-free and a proof of the initial
statement, here \C{3 = 3}.

\begin{coq}{name=my-first-proof3}{title=Scheme of a complete proof}
Lemma my_first_lemma : 3 = 3.
Proof.
(* <your finished proof script comes here> *)
Qed.
\end{coq}

In this section, we will review different nature of proof steps and
the corresponding tactics.

\subsection{Proofs by computation}\label{ssec:proofcomp}

Here is now the proof scipt that validates the statement $3 = 3$:

\begin{coqdef}{name=my-first-proof4}
Lemma my_first_lemma : 3 = 3.
Proof.
\end{coqdef}
\begin{coq}{def=my-first-proof4,done}{width=7cm,title=Reflexivity of equality}
Lemma my_first_lemma : 3 = 3.
Proof. by [].
\end{coq}
\coqrun{name=firstp4}{ssr,my-first-proof4,verbose,done,abort}
\begin{coqout}{run=firstp4}{width=5cm,title=Proof finished}
No more subgoals.
$~$
\end{coqout}
\index[ssr]{\C{by []}}

Indeed, this statement trivially holds, because the two hand sides of
the equality are the same. The tactic \C{by []} is the command that
implements this nature of \emph{trivial} proof step: the \C{by} prefix
checks that after the next tactic, the proof will be a trivial
\marginnote{Placeholder means really that this is empty list, otherwise
said we could provide a tactic here.}
one, and \C{[]} is a placeholder because really there is nothing more
to explain to the system. The system thus informs the user
that the proof looks complete. We can hence confidently conclude our
first proof by the \C{Qed} command:

\begin{coq}{def=my-first-proof4,done,qed}{width=6cm,title=Reflexivity of equality}
Lemma my_first_lemma : 3 = 3.
Proof. by []. Qed.
\end{coq}
\coqrun{name=firstp5}{ssr,my-first-proof4,done,verbose,qed}
\begin{coqout}{run=firstp5}{title=Response,width=6cm}
my_first_lemma is defined
\end{coqout}

Just like when it was \C{Admitted}, this results in a new definition
added in our context, that can hence be reused in future proofs under
the name \C{my_first_lemma}. Except that this time we have really
machine checked the statement of \C{my_first_lemma}.


Importantly, the \C{by []} tactic can be used not only when both
hand sides of an equality coincide syntactically but also when they are
equal \emph{modulo the evaluation of programs} used in the formal
sentence to be proved. These programs have been defined at an
earlier in the current file, or in the libraries
we loaded. For instance, let us prove that $2 + 1 = 3$:

\begin{coqdef}{name=secondp}
Lemma my_second_lemma : 2 + 1 = 3.
Proof. by [].
\end{coqdef}
\begin{coq}{def=secondp,qed}{width=6.5cm,title=Reflexivity of equality}
Lemma my_second_lemma : 2 + 1 = 3.
Proof. by []. Qed.
\end{coq}
\coqrun{name=secondp}{ssr,secondp,verbose,qed}
\begin{coqout}{run=secondp}{title=Response,width=5.5cm}
my_second_lemma is defined
\end{coqout}


Indeed, this statement holds because the two hand sides of the equality
are the same, once the definition of the \C{addn} function, hidden
behind the infix \C{+} notation, is unfolded, and that the calculation
is performed. We can prove in a similar way the statement \C{(0 <=
1)}. And finally the statement \C{(odd 5)} is proved by the very same
proof script, because \C{(odd 5)} \emph{computes} to
\C{true}.
\marginnote{Should these be exercises? should we add failure
  examples?}
Note that we now have a new result at hand for our future proofs
(although this one is not a very useful one...)

\begin{coq}{name=check1}{width=6cm,title=Printing a lemma statement}
Check my_first_lemma.
\end{coq}
\coqrun{name=c1}{ssr,my-first-proof4,done,qed,check1}
\begin{coqout}{run=c1}{title=Response,width=6cm}
my_first_lemma : 3 = 3
\end{coqout}

Computation is not limited to ground terms, it is really about using
the rules of the pattern matching describing the code of the
function. \marginnote{Take some time to describe this in detail, for instance on
  the example of addition.}
For instance the proof of the \C{addSn} identity:


\begin{coq}{name=addSn}{title=Reflexevity by symbolic computation}
Lemma addSn m n : m.+1 + n = (m + n).+1. Proof. by []. Qed.
\end{coq}
\index[coq]{\C{addSn}}
is trivial because it is a direct application of one of the branches
of the definition of the \C{addn} function. Statements like
\C{(0 + n = n)} or \C{(0 <= n.+1)} can be proved in a similar way, but
also \C{(2 + n = n.+2)}, which requires a two-step computation.
\marginnote{HERE: we could add many examples of what by[] can and cannot do.}

The last word to be said about \C{by []} it that it is a terminating
tactic.  If it is unable to solve the goal it fails.  For this reason
it is coloured in red, so that the eye can immediately spot that a 
proof, or more commonly a subproof, ends there.

\subsection{Case analysis}\label{ssec:case}
%assia : I do not remember why the \C macro does not work here, seems
%to be a problem with ~~...
Let us now consider the tautology~\L+~~ (~~ b) = b+. The
``proof by computation'' technique of section~\ref{ssec:proofcomp}
fails in this case:

\begin{coqdef}{name=negbK}
Lemma negbK (b : bool) : ~~ (~~ b) = b.
Proof.
\end{coqdef}
\begin{coq}{name=negbK,done}{width=7cm,title=Double negation elimination}
Lemma negbK (b : bool) : ~~ (~~ b) = b.
Proof. by [].
\end{coq}
\coqrun{name=negbKerr;fail}{ssr,negbK,done}
\begin{coqout}{run=negbKerr}{width=5cm, title=Failing proof script}
Error: No applicable tactic.
\end{coqout}
\index[coq]{\C{negbK}}

Indeed, proving this identity requires not only unfolding the
definition of the \C{negb}, but also performing a \emph{case analysis}
on the boolean value of the parameter \C{b}. The tactic \C{case}
implements this action:

\begin{coqdef}{name=negbkt2}
Lemma negbK b : ~~ (~~ b) = b.
Proof.
case: b.
\end{coqdef}
\coqrun{name=negbkt2}{ssr,negbkt2,show1,done,show2,verbose,done,qed}
\begin{coq}{def=negbkt2}{width=6cm,title=Double negation elimination}
Lemma negbK b : ~~ (~~ b) = b.
Proof.
case: b.
$~$
$~$
$~$
\end{coq}
\begin{coqout}{run=negbkt2;out=g1}{width=6cm, title=Case analysis}
2 subgoals

  ============================
   ~~ ~~ true = true
subgoal 2 is:
 ~~ ~~ false = false
\end{coqout}
\index[ssr]{\C{case}}

\marginnote{ Say somewhere later that this substitution only happens
  in the goal and not in the hypotheses. BTW Ssr fails if the
  hypotheses feature b. But it is probably too early now.}
More precisely, the tactic \C{case: b} indicates that we want to
perform a case analysis (hence the \C{case} command), on \C{b}, whose
name follows the separator \C{:}. The \Coq{} system displays the state
of the proof after this command: the proof now has two parallel
branches, one in which the parameter \C{b} takes the value \C{true} and
one in which the parameter \C{b} takes the value \C{false}. And we
start with the branch associated with the \C{true}
value\footnote{The order of the subgoals generated by this case
  analysis is the order of the constructors in the definition of the
  inductive type, here \C{bool}.}.

Now we are going to provide two distinct pieces of script, one per
each subproof to be constructed. Hence some indentation. We can
observe that after this case analysis, each proof amounts to a
reflexivity argument, in the spirit of what we did in
section~\ref{ssec:proofcomp}. We first close the first branch:

\begin{coq}{def=negbkt2,done}{width=6cm,title=Double negation elimination}
Lemma negbK b : ~~ (~~ b) = b.
Proof.
case: b.
  by [].
\end{coq}
\begin{coqout}{run=negbkt2;out=g2}{width=6cm, title=Case analysis}
1 subgoal

 ============================
   ~~ ~~ false = false
\end{coqout}

and we can see that we now have only one subgoal left, which we solve
by the very same means. Note that we have indented the code which
applies to this first subgoal, in order to mark that the script
features a branching proof and to distinguish the parts of the script
that apply to each case. See Section~\ref{sec:goodprac} for more about good
practices.


\begin{coq}{def=negbkt2,done,done,qed}{width=6cm,title=Double negation elimination}
Lemma negbK b : ~~ (~~ b) = b.
Proof.
case: b.
  by [].
by [].
Qed.
\end{coq}
\begin{coqout}{run=negbkt2}{width=6cm, title=Case analysis}
No more subgoals.
negbK is defined
$~$
$~$
$~$
$~$
\end{coqout}

In fact, we can use the \C{by} command as a true prefix, to have the
system check that after the \C{case} tactic, the proof becomes
trivial, in both branches of the case analysis. The proof script is
then a one-liner:

\begin{coq}{def=negbkt3,done,done,qed}{width=6cm,title=Double negation elimination}
Lemma negbK b : ~~ (~~ b) = b.
Proof. by case: b. Qed.
\end{coq}
\begin{coqout}{run=negbkt3}{width=6cm, title=Case analysis}
No more subgoals.
negbK is defined
\end{coqout}

The boolean equivalence \C{leqn0} is also an example of statement that
cannot be proved by computation only:

\begin{coq}{def=leqn0,done}{width=7cm,title=No negative natural number}
Lemma |*leqn0*| n : (n <= 0) = (n == 0).
Proof.
\end{coq}
\begin{coqout}{def=leqn0,done}{width=5cm,title=Proof status}
1 subgoal

n : nat
=====================
  (n <= 0) = (n == 0)
\end{coqout}
\index[coq]{\C{leqn0}}

The proof requires unfolding the definition of the comparison operations
\C{<=} and \C{==}, both defined by case analysis on their first
argument, and to inspect their respective values in the case when the
second argument is zero. A case analysis on term \C{n : nat} has two
branches: one in which \C{n} is \C{0} and one in which \C{n} is
\C{(S k)} for some \C{k : nat}. We hence need a variant of the \C{case}
tactic, in order to \emph{name} the parameter \C{k} which pops up in
the second branch:

\begin{coq}{def=leqn01,done}{width=7cm,title=No negative natural numbers}
Lemma |*leqn0*| n : (n <= 0) = (n == 0).
Proof.
case: n => [| k].
\end{coq}
\begin{coqout}{run=leqn01}{width=5cm, title=Proof status}
2 subgoals, subgoal 1

======================
  (0 <= 0) = (0 == 0)

subgoal 2 is:
 (k < 0) = (k.+1 == 0)
\end{coqout}
The tactic \C{case: n => [|k]}  can be decomposed into two components,
separated by the arrow \C{=>}: the left block \C{case: n} indicates
that we  perform a case analysis action, on term \C{n : nat}, and the right
block \C{[|k]} is an \emph{introduction pattern}. The brackets
surround slots separated by vertical pipes, and each slot allows to
name the parameters to be introduced in each subgoal created by the
case analysis, in order. Remember that the inductive type \C{nat} is
defined as:

\begin{coq}{def=natdef}{title=A two constructor inductive type}
Inductive nat := O | S (n : nat)
\end{coq}
with two constructors, \C{O} which has no argument and \C{S} which has
one (recursive) argument. Therefore the introduction pattern \C{[|k]}
of our case analysis command uses two slots: the last one introduces
the name \C{k} in the second subgoal and the first one is
empty. Indeed, in the first subgoal, first branch of the case
analysis, \C{n} is substituted with \C{0}. In the second one, we can
observe that \C{n} has been substituted with \C{k.+1}. 
As hinted in the first chapter, the term \C{(k.+1 <= 0)}
is displayed as \C{(k < 0)}.

The first goal
can be easily solved by computation, as both hand sides of the equality
evaluates to \C{true}.

\begin{coq}{def=leqn02,done}{width=7cm,title=No negative natural numbers}
Lemma |*leqn0*| n : (n <= 0) = (n == 0).
Proof.
case: n => [| k].
  by [].
\end{coq}
\begin{coqout}{run=leqn02}{width=5cm, title=Proof status}
1 subgoal

k : nat
=========================
  (k < 0) = (k.+1 == 0)
\end{coqout}
\index[ssr]{\C{=> [$\mid$m]}}
The second and now only remaining goal corresponds to the case when
\C{n} is the successor \C{k.+1} of a recursively constructed term
\C{k : nat}.
It can also be  solved by computation, as both hand sides
of the equality evaluates to \C{false}.

\begin{coq}{def=leqn03,done}{width=7cm,title=No negative natural numbers}
Lemma |*leqn0*| n : (n <= 0) = (n == 0).
Proof.
case: n => [| k].
  by [].
by [].
\end{coq}
\begin{coqout}{run=leqn03}{width=5cm, title=Proof status}
  No more subgoals.
\end{coqout}
As in the previous example, we can make the proof script even shorter:

\begin{coq}{def=leqn04,done}{title=No negative natural numbers}
Lemma |*leqn0*| n : (n <= 0) = (n == 0).
Proof.  by case: n => [| k].  Qed.
\end{coq}

Here is a similar example, again of a boolean equivalence: the lemma
stating that the product of two (natural) numbers is zero if and only
if one of the numbers is zero:

\begin{coq}{def=almostMulnEq0}{title=A double case analysis}
Lemma |*muln_eq0*| m n : (m * n == 0) = (m == 0) || (n == 0).
\end{coq}
\index{coq}{muln\_eq0}

\marginnote{Can we count on the fact that the first chapter has
  shown all the necessary definitions on nats, like all the arithmetic
  operations? LR: \{struct n\} not yet explained}
Let us look back at the code defining multiplication:

\begin{coq}{def=muldef}{title=Multiplication}
Fixpoint |*muln*| (m n : nat) : nat :=
  if m is p.+1 then n + muln p n else 0.
\end{coq}
\index[coq]{\C{muln}}
In the case when \C{m} is zero, and whatever value \C{n} takes, both
hand sides of the equality evaluate to \C{true}: the left hand side is
equal modulo computation to \C{(0 == 0)}, which itself computes to
\C{true} and the right hand side is equal modulo computation to
\C{((0 == 0) || (n == 0))}, hence to \C{(true || (n == 0))} and finally to
\C{true} because the boolean disjunction \C{(_ || _)} is defined by
case analysis on its first argument.

\begin{coq}{def=almostMulnEq1}{title=First case analysis,width=7cm}
Lemma |*muln_eq0*| m n :
  (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m].
  by [].
\end{coq}
\begin{coqout}{def=almostMulnEq1}{title=Proof status,width=6cm}
1 subgoal

n : nat
m : nat
============================
(m.+1 * n == 0) =
(m.+1 == 0) || (n == 0)
\end{coqout}
Note that we can use the name \C{m} in our case analysis without
ambiguity. The next step in the proof is a case analysis on the number
\C{n}. \marginnote{Is it ok to introduce this here?}
In order to let us treat first the successor case,
despite it corresponds by default to the second subgoal, we are going
to use the \C{last first} tactic:

\begin{coq}{def=almostMulnEq2}{title=Second case analysis,width=7cm}
Lemma |*muln_eq0*| m n :
  (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m].
  by [].
case: n => [|k]; last first.
\end{coq}
\begin{coqout}{def=almostMulnEq2}{title=Proof status,width=6cm}
2 subgoals, subgoal 1 (ID 72)

m : nat
n : nat
============================
(m.+1 * n.+1 == 0) =
  (m.+1 == 0) || (n.+1 == 0)

subgoal 2 is:
 (m.+1 * 0 == 0) =
   (m.+1 == 0) || (0 == 0)
\end{coqout}
Indeed when \C{n} is of the form \C{k.+1}, it is easy to see that the
right hand side of the equality evaluates to \C{false}, as both
arguments of the boolean disjunction do. Now the left hand side also
evaluates to \C{false}: by the definition of \C{muln} term
\C{(m.+1 * k.+1)} evaluates to \C{(k.+1 + (m * k.+1))} and by
definition of the addition \C{addn}, this in turn reduces to
\C{(k + (m * k.+1)).+1}. The left hand side term hence is of the form
\C{t.+1 == 0}, where \C{t} stands for \C{(k + (m * k.+1))}, and this
reduces to false. To conclude, this branch of the case analysis is
also solved by computation.

\begin{coq}{def=almostMulnEq3}{title=Second case analysis,width=7cm}
Lemma |*muln_eq0*| m n :
  (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m].
  by [].
case: n => [|k]; last first.
  by [].
\end{coq}
\begin{coqout}{def=almostMulnEq3}{title=Proof status,width=6cm}
1 subgoal

m : nat
============================
(m.+1 * 0 == 0) =
(m.+1 == 0) || (0 == 0)
\end{coqout}
\marginnote{We should make the remark somewhere explicitly that
  reflexivity for 0
or successor or any closed values is by computation but not
reflexivity for a variable.}

This proof script can be made more compact and more linear by using an
optional part of the introduction pattern, which makes \Coq{}
inspect the subgoals created by the case analysis and solve the
trivial ones using the \C{by []} tactic. For instance in our case,
let us add the optional \C{//} \emph{simplifying} switch to the
introduction pattern of the first case analysis:

\begin{coq}{def=almostMulnEq3}{title=A simplify intro pattern,width=7cm}
Lemma |*muln_eq0*| m n :
  (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m] //.
\end{coq}
\begin{coqout}{def=almostMulnEq11}{title=Proof status,width=6cm}
1 subgoal

n : nat
m : nat
============================
(m.+1 * n == 0) =
(m.+1 == 0) || (n == 0)
\end{coqout}

Only the first generated subgoal is trivial, and has been closed, so
we are left with the second one. Similarly, we can get rid of the
second goal produced by the case analysis on \C{n}:

\begin{coq}{def=almostMulnEq31}{title=A simplify intro pattern,width=7cm}
Lemma |*muln_eq0*| m n :
  (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m] //.
case: n => [|k] //.
\end{coq}
\begin{coqout}{def=almostMulnEq3}{title=Proof status,width=6cm}
1 subgoal

m : nat
============================
(m.+1 * 0 == 0) =
(m.+1 == 0) || (0 == 0)
\end{coqout}

% We will see in Section~\ref{} that
This \C{//} switch can be used in
more general contexts than just this special case of introduction patterns:
it can actually punctuate more complex combinations of tactics,
avoiding spurious branching in proofs in a similar manner~\cite{ssrman}.

Now in the last remaining case, the right hand side evaluates to
\C{true}, as the left argument of the disjunction is \C{false} (modulo
computation) and the right one is \C{true}. However we need
more than symbolic computation to show that the left hand side is
\C{true} as well: the fact that \C{0} is a right absorbing element for
multiplication indeed requires reasoning by induction on the code of the
multiplication. 

To conclude the proof we need to introduce one more proof command:
\C{rewrite}.  This is the subject of the next section.
% Section~\ref{ssec:rw} explains how to complete this proof.

\marginnote{What to say here to conclude? And shall we show here
case analysis on a subterm and how to keep the equation?
The choice of k and m for the sub terms may help recalling where
the goal comes from. Also, equation generation can serve this purpose}

\subsection{Rewriting}\label{ssec:rw}

This section explains how to perform local replacements of certain
subterms of a goal with other terms during the course of a formal
proof. In other words, we explain how to perform a
\emph{rewrite} proof step, thanks to the eponym \C{rewrite} tactic.
Such a replacement is licit when the original subterm is equal
to the final one, up to computation or because of a proved
identity. The \C{rewrite} tactic comes with several options for
an accurate specification of the operation to be performed.

Let us start with a simple example and come back to the proof that we
left unfinished at the end of the previous section:

\begin{coq}{def=almostMulnEq3}{title=First case analysis,width=7cm}
Lemma |*muln_eq0*| m n :
  (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m] //.
case: n => [|k] //.
\end{coq}
\begin{coqout}{def=almostMulnEq3}{title=Proof status,width=5cm}
1 subgoal

m : nat
=======================
(m.+1 * 0 == 0) =
(m.+1 == 0) || (0 == 0)
\end{coqout}
At this stage, if we replace subterm \C{m.+1 * 0} by \C{0}, the
subgoal becomes:

\begin{coqout}{}{}
(0 == 0) = (m.+1 == 0) || (0 == 0)}
\end{coqout}
which is equal modulo computation to \C{(true = true)}. But because of
the definition of \C{muln} by case analysis on its \emph{first}
argument, \C{m.+1 * 0} does not evaluate symbolically to \C{0}: this
equality holds but requires a proof by induction, as explained in
Section~\ref{ssec:ind}.
Anyway, a lemma proving what we need is already available in the library:

\begin{coq}{def=muln0}{title=Multiplying by zero on the left}
Lemma |*muln0*| n : n * 0 = 0.
\end{coq}
\marginnote{But this is not the way lemma \C{muln0} is stated in the library...}
and we call the \C{rewrite} tactic which performs the desired replacement:

\begin{coq}{def=almostMulnEq4}{title=First case analysis,width=7cm}
Lemma |*muln_eq0*| m n :
  (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m] //.
case: n => [|k] //.
rewrite muln0.
\end{coq}
\begin{coqout}{def=almostMulnEq4}{title=Proof status,width=5cm}
1 subgoal

m : nat
=======================
(0 == 0) =
(m.+1 == 0) || (0 == 0)
\end{coqout}
\index[ssr]{\C{rewrite}}

In this case, we have provided the \C{rewrite} tactic with the name
\C{muln0} of a lemma stating a parametric identity: the tactic has
replaced an instance of the left hand side of this identity with the
corresponding instance of the right hand side. The left hand side of
\C{muln0} can be read as a \emph{pattern} \C{(_ * 0)} where we use \C{_}
to denote a wild-card, which reflects the fact that the identity is
valid for any value of its parameter \C{n}. The tactic
automatically  finds  where in the goal the replacement should take
place, by searching for a subterm matching the pattern \C{(_ * 0)}.
In the present case, there is only one such subterm,
\C{(m.+1 * 0)}, for which the parameter (or the wild-card) takes the
value \C{m.+1}. This subterm is hence the replaced by \C{0}, the right
hand side of \C{muln0}, which does not depend on the value of the
pattern. We can now conclude the proof script, using the
prenex \C{by} tactical:

\begin{coq}{def=almostMulnEq5}{title=First case analysis}
Lemma |*muln_eq0*| m n : (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m] //.
case: n => [|k] //.
by rewrite muln0.
Qed.
\end{coq}

% Patterns are more generally useful both for subterm selection (in
% proof mode) and for searching existing results in the current context.
% This is the purpose of the \C{Search} command, which can for instance
% be used to (FIND AN EXAMPLE WHICH IS NOT muln0...)

\marginnote{Patterns are also needed by Search and are a quite
pervasive concept. But have not yet provided the syntax.}

The boolean identity \C{muln_eq0} that we just established expresses a
logical equivalence that can in turn be used in proofs via the
\C{rewrite} tactic. For instance, let us consider the case of lemma
\C{|*leq_mul2l*|}, which provides a necessary and sufficient condition
for the comparison \C{(m * n1 <= m * n2)} to hold:

\begin{coq}{def=LeqMul2l}{title=Ordered products}
Lemma |*leq_mul2l*| m n1 n2 : (m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
\end{coq}

The proof goes as follows: by definition of the order \C{<=}, see exercise
\ref{ex:leq}, the left
hand side can be written as \C{(m * n1 - m * n2 == 0)}, which in turns
factors into \C{(m * (n1 - n2) == 0)}. We then conclude using
lemma \C{muln_eq0}, since \C{(n1 - n2 == 0)} is the definition of
\C{(n1 <= n2)}.

The first step hence consists in using the definition of the
\C{leq} relation, denoted by the \C{<=} infix notation, to replace the
right hand side by a subtraction. This can be performed using the
following equation:

\begin{coq}{def=LeqDef}{title=Definition of Order}
Lemma |*leq_def*| m n : (m <= n) = (m - n == 0).
\end{coq}
For this purpose, we use the rewrite tactic. However, the command
\C{rewrite leq_def} only affects the first occurrence of \C{<=} and we
would like to treat both.

\begin{coq}{def=LeqMul2lproof1}{title=Simple rewrite,width=7.7cm}
Lemma |*leq_mul2l*| m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite leq_def.
\end{coq}
\begin{coqout}{def=LeqMul2lproof1}{title=Proof status,width=5cm}
1 subgoal

m, n1, n2 : nat
==========================
(m * n1 - m * n2 == 0) =
(m == 0) || (n1 <= n2)
\end{coqout}

In order to rewrite \emph{all} the possible instances, we use a
repetition flag:

\begin{coq}{def=LeqMul2lproof1}{title=Ordered products,width=7.7cm}
Lemma |*leq_mul2l*| m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite !leq_def.
\end{coq}
\begin{coqout}{def=LeqMul2lproof1}{title=Proof status,width=5cm}
1 subgoal

m, n1, n2 : nat
==========================
(m * n1 - m * n2 == 0) =
(m == 0) || (n1 - n2 == 0)
\end{coqout}
\index[ssr]{\C{rewrite}! "! (iteration)}

Now the definition of \C{<=} has been exposed
\emph{everywhere} in the goal, i.e. at both its occurrences in this
initial goal. We can now factor \C{m} on the left, using the appropriate
distributivity property:
\marginnote{Here again we cheat and do not use predicators}

\begin{coq}{def=mulnBr}{title=Distributivity of multiplication over subtraction}
Lemma |*mulnBr*| n m p : n * (m - p) = n * m - n * p.
\end{coq}
This time we need to perform a right-to-left rewriting of the
\C{mulnBr} lemma (instead of the
default left-to-right). The rewriting step first finds in the goal an
instance of pattern \C{(_ * _ - _ * _)}, where the terms matched by
the first and the third wild-cards coincide. The syntax for
right-to-left rewriting consists in adding a minus \C{-} to the name
of the rewrite rule:


\begin{coq}{def=LeqMul2lproof2}{title=Ordered products,width=7.7cm}
Lemma |*leq_mul2l*| m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite !leq_def.
rewrite -mulnBr.
\end{coq}
\begin{coqout}{def=LeqMul2lproof2}{title=Proof status,width=5cm}
1 subgoal

m, n1, n2 : nat
==========================
(m * (n1 - n2) == 0) =
(m == 0) || (n1 - n2 == 0)
\end{coqout}
\index[ssr]{\C{rewrite}! \C{-} (right-to-left)}

The last step of the proof uses lemma \C{muln_eq0} to align the left
and the right hand sides of the identity.

\begin{coq}{def=LeqMul2lproof3}{title=Ordered products, width=7.7cm}
Lemma |*leq_mul2l*| m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite !leq_def.
rewrite -mulnBr.
rewrite muln_eq0.
\end{coq}
\begin{coqout}{def=LeqMul2lproof3}{title=Proof status,width=5.5cm}
1 subgoal

m, n1, n2 : nat
==========================
(m == 0) || (n1 - n2 == 0) =
(m == 0) || (n1 - n2 == 0)
\end{coqout}

The proof could now be completed by prefixing the last tactic with the
\C{by} command, which concludes the proof by reflexively. However we
can obtain a much more compact proof script by chaining the three
tactics into a single one: several consecutive rewriting steps can
indeed be performed by a single invocation of the \C{rewrite} tactic.

\begin{coq}{def=LeqMul2lproof}{title=Ordered products}
Lemma |*leq_mul2l*| m n1 n2 : (m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof. by rewrite !leq_def -mulnBr muln_eq0. Qed.
\end{coq}

So far we have learnt the basic use of the \C{rewrite} tactic.
The interested reader can find in Section~\ref{sec:rewrite2} more
details on the matching algorithm and on the flags supported by
\C{rewrite}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{More complex statements and proofs}

\subsection{Universal quantification, first examples}
\marginnote{LR: boolean predicate, not yet defined: we have just seen \C{eq} as a predicate in Prop}
In Chapter~\ref{ch:prog}, we have defined \emph{predicates}, as functions
with boolean values. For instance, the \C{leq} predicate is defined as
a predicate on natural numbers, as:
\begin{coq}{def=LeqDef}{title=Comparison Boolean Predicate}
Definition |*leq*| n m := m - n == 0.
\end{coq}

We recall, as seen in Chapter~\ref{ch:prog}, that this concise syntax stands
for:

\begin{coq}{def=LeqDefFun}{title=Comparison Boolean Predicate}
Definition |*leq*| := fun n m => m - n == 0.
\end{coq}
and the type of the constant \C{|*leq*|} is:

\begin{coq}{name=about-leq}{width=6cm,title= Type of leq}
About leq.
\end{coq}
\coqrun{name=about}{ssr,about-leq,about-leq}
\begin{coqout}{run=about}{title=Response,width=6cm}
leq : nat -> nat -> bool
...
\end{coqout}

In the present Chapter, we have used a similar syntax when stating
parametric statements, like:

\begin{coq}{def=leqn0}{title=A parametric identity}
Lemma |*leqn0*| n : (n <= 0) = (n == 0).
\end{coq}

The curious reader might already have tested the answer of the
\C{About} command on the parametric lemmas we have used or proved in the
previous sections, like for instance:

\begin{coq}{def=negbktAbout}{width=5cm,title=Inspecting lemma leqn0}
About leqn0.
\end{coq}
\begin{coqout}{run=negbktAbout,ssr}{width=7cm, title=Universal quantification}
leqn0 : forall n : nat, (n <= 0) = (n == 0)
\end{coqout}

She has thus observed that \Coq{}'s output features a prenex
\C{forall} quantifier. This universal quantifier binds a natural number, and
expresses --as expected-- that the equation holds for any
natural number. The type of the lemmas and theorems with parameters all feature
prenex universal quantifiers:

\begin{coq}{}{title=Query,width=4cm}
About muln_eq0.
\end{coq}
\begin{coqout}{}{title=Response,width=8cm}
muln_eq0 : forall m n : nat,
  (m * n == 0) = (m == 0) || (n == 0)
\end{coqout}
Quantifiers do not need to be in prenex position.  In the following
example the second hypothesis is itself a quantified formula.

\begin{coq}{}{}
Lemma |*seq_eq_ext*| (s1 s2 : seq nat) :
  size s1 = size s2 ->
  (forall i : nat, nth 0 s1 i = nth 0 s2 i) ->
  s1 = s2.
\end{coq}
Quantifiers are also allowed to range over functions:

\begin{coq}{}{}
Lemma |*size_map*| (T1 T2 : Type) :
forall (f : T1 -> T2) (s : seq T1), size (map f s) = size s.
\end{coq}
Observe that in the above statement of \C{size_map}, we have used a
compact notation for successive universal quantifications:
\C{forall (f : T1 -> T2) (s : seq T1), ...} is syntactic sugar for
\C{forall f : T1 -> T2, forall s : seq T1, ...}. However in this case
of prenex quantification we would rather write:

\begin{coq}{}{}
Lemma |*size_map*| (T1 T2 : Type) (f : T1 -> T2) (s : seq T1) :
 size (map f s) = size s.
\end{coq}
\index[coq]{\C{size_map}}
as all quantifiers are in prenex positions.

We can also use quantifiers in the body of definitions, which is
useful to define predicates expressing standard properties on
objects. For instance the commutativity property of a binary operator
is defined as:

\begin{coq}{}{}
Definition |*commutative*| (T : Type) (op : T -> T -> T) :=
  forall x y, op x y = op y x.
\end{coq}
\index[coq]{\C{commutative}}
and the lemma stating the commutativity of the \C{addn} operation is
in fact:

\begin{coq}{}{}
Lemma |*addnC*| : commutative addn.
\end{coq}
The \mcbMC{} library provides many predicates to state in a consistent
and compact way standard properties.  Here we recall only few of them.

\begin{coq}{}{}
Section StandardPredicates.
Variable T : Type.
Implicit Types (op add : T -> T -> T) (R : rel T).

Definition |*associative*| op :=
  forall x y z, op x (op y z) = op (op x y) z.

Definition |*left_distributive*| op add :=
  forall x y z, op (add x y) z = add (op x z) (op y z).

Definition |*transitive*| R :=
  forall y x z, R x y -> R y z -> R x z.


Variables rT aT : Type.
Implicit Types (f : aT -> rT).

Definition |*injective*| f :=
  forall x1 x2, f x1 = f x2 -> x1 = x2.
Definition |*cancel*| f g := forall x, g (f x) = x.
Definition |*pcancel*| f g := forall x, g (f x) = Some x.

End StandardPredicates.
\end{coq}
\index[coq]{\C{associative}}
\index[coq]{\C{transitive}}
\index[coq]{\C{left_distributive}}
\index[coq]{\C{injective}}
\index[coq]{\C{cancel}}
\index[coq]{\C{pcancel}}

Note that beside the standardization of the statements through these
predicates, the \mcbMC{} library uses a systematic naming policy for the lemmas
that are instances of these predicates. For instance a common suffix \C{C}
is used for commutativity properties like \C{addnC} or \C{mulnC}.
\marginnote{To be expanded elsewhere?}

Now it is worth discussing the type of these predicates.

\begin{coq}{}{}
About commutative.
\end{coq}
\begin{coqout}{}{}
commutative : forall T : Type, (T -> T -> T) -> Prop.
\end{coqout}
It is a polymorphic function taking a binary operation and
building a \emph{proposition}, i.e. it has the same status as the
identity statements that we have seen so far in this chapter:

\begin{coq}{}{title=Query,width=6cm}
Check 3 = 3.
Check (commutative addn).
\end{coq}
\begin{coqout}{}{title=Response,width=6cm}
3 = 3 : Prop
commutative addn : Prop
\end{coqout}
Indeed, the class of propositions is closed under universal quantification
\C{forall} (and also under implication \C{->}). Chapter~\ref{sec:ttch} will
provide a more in-depth study of these propositions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Quantified statements and implications}
\label{sec:quantifiedst}

In order to use a lemma with a parameter, we can use the \C{apply}
tactic, which finds the appropriate instance (as the \C{rewrite}
tactic does):

\begin{coq}{}{}
Lemma example a b : a + b <= a + b.
Proof. apply: leqnn. Qed.
\end{coq}
\index[ssr]{\C{apply:}}
Find the appropriate instance works up to computation:

\begin{coq}{}{}
Lemma example a b : a.+1 + b <= (a + b).+1.
Proof. apply: leqnn. Qed.
\end{coq}
By the way, in order to save the effort of mentioning too trivial
steps in the proof script, we can extend the power of the \C{by}
terminator to make it aware of some (concluding) lemmas available in
the library. The \C{Hint Resolve} command is used to tag these lemmas,
as in:\index[vernac]{\C{Hint Resolve}}

\begin{coq}{}{}
(* This line belongs to the file where the lemma is stated and proved.*)
Hint Resolve leqnn.
Lemma example a b : a + b <= a + b.
Proof.  by [].  Qed.
\end{coq}
Observe that the goal is now closed without a mention of \C{leqnn}.

The \C{apply} tactic can also be used on non-atomic statements. For
instance, the following lemma can be used to perform a flavour of
proof by contraposition:

\begin{coq}{}{}
Lemma |*contraL*| (c b : bool) : (c -> ~~ b) -> (b -> ~~ c).
\end{coq}
\index[coq]{\C{contraL}}

We see this how this lemmas is used in an excerpt of the proof
that there are infinitely many primes (the full proof will be
object of study in Section~\ref{sec:infprimes}).  Given a number \C{m}
we show that any prime divisor \C{p} of \C{(m `! + 1}) is greater than \C{m},
or better that it is not the case \C{m} is bigger.

\begin{coq}{}{}
Lemma example m p : prime p -> p %| m `! + 1 -> ~~ (p <= m).
\end{coq}
We start our formal writing of such
proof by naming the hypothesis \C{(prime p)}, which means that we add it to the
current context of the goal. The dedicated tactic for this naming step is
\C{move=>} followed by the name given to the hypothesis.

\begin{coq}{}{width=6cm}
Lemma example m p : prime p ->
  p %| m `! + 1 -> ~~ (p <= m).
Proof.
move=> prime_p.
\end{coq}
\begin{coqout}{}{width=6cm}
m, p : nat
prime_p : prime p
====================
p %| m `! + 1 -> ~~ (p <= m)
\end{coqout}

By reasoning by contraposition, via \C{apply: contraL}, we are left to
prove that \C{p} is not a divisor of \C{(m `! + 1)} under the assumption
that \C{p} is smaller then \C{m}:

\begin{coq}{}{width=6cm}
Lemma example m p : prime p ->
  p %| m `! + 1 -> ~~ (p <= m).
Proof.
move=> prime_p.
apply: contraL.
\end{coq}
\begin{coqout}{}{width=6cm}
m, p : nat
prime_p : prime p
====================
 p <= m -> ~~ (p %| m `! + 1)
\end{coqout}

First observe that the \C{apply:} tactic has found the correct values
of the two parameters \C{c, b} of lemma \C{contraL}, namely
\C{(p <= m)} and \C{(p \%| m `! + 1)}, by unifying the statement to be
proved with the conclusion \C{(b -> ~~ c)} of the statement of the lemma.
Indeed lemma \C{contraL} provides a sufficient condition for a
statement of this shape to hold. After the execution of the tactic, we
are hence left with proving this sufficient condition.

The rest of proof informally goes as follows: if $p \le m$, then $p$ certainly
divides $m!$. But then $p$ divides $m! + 1$ if and only if $p$ divides $1$.
Since $p$ is a prime, it cannot be $1$.  We start our formal writing of such
proof by naming the hypothesis \C{(p <= m)}.

\begin{coq}{}{width=6cm}
Lemma example m p : prime p ->
  p %| m `! + 1 -> ~~ (p <= m).
Proof.
move=> prime_p.
apply: contraL.
move=> leq_p_m.
\end{coq}
\begin{coqout}{}{width=6cm}
m, p : nat
prime_p : prime p
leq_p_m :  p <= m
====================
 ~~ (p %| m `! + 1)
\end{coqout}
The next step is to use the following lemma:

\begin{coq}{}{}
Lemma |*dvdn_addr*| m d n : d %| m -> (d %| m + n) = (d %| n).
\end{coq}
It states a conditional equivalence, expressed as a conditional identity.
We can replace our current goal with \C{\~\~ (p \%| 1)} by rewriting (the
appropriate instance of) this identity.  This operation will open an
extra goal requiring a proof of (corresponding instance of) the side
condition.

\begin{coq}{}{width=6cm}
Lemma example m p : prime p ->
  p %| m `! + 1 -> ~~ (p <= m).
Proof.
move=> prime_p.
apply: contraL.
move=> leq_p_m.
rewrite dvdn_addr.
\end{coq}
\begin{coqout}{}{width=6cm}
2 subgoals

  m, p : nat
  pr_p : prime p
  p_le_m : p <= m
  ============================
   ~~ (p %| 1)

subgoal 2 is:
 p %| m`!
\end{coqout}
Observe the remainder at the bottom of the buffer which displays the
statement of the side condition to be proved later. The context of
this extra (sub)goal is ommited but we do not really need to see it:
we know that statement \C{p \%| m!} holds because \C{p <= m}.
This can be proved combining the following lemmas:
stated by lemma:

\begin{coq}{}{}
Lemma dvdn_fact m n : 0 < m -> m <= n -> m %| n`!.
Lemma prime_gt1 p : prime p -> 1 < p.
\end{coq}

The first goal can be solve by appealing to the following lemmas:

\begin{coq}{}{}
Lemma gtnNdvd n d : 0 < n -> n < d -> (d %| n) = false.
Lemma prime_gt0 p : prime p -> 0 < p.
\end{coq}
The resulting script would then be:

\begin{coq}{}{}
Lemma example m p : prime p -> p %| m `! + 1 -> ~~ (p <= m).
Proof.
move=> prime_p.
apply: contraL.
move=> leq_p_m.
rewrite dvdn_addr.
  rewrite gtnNdvd.
    by [].  (* ~~ false *)
    by [].  (* 0 < 1 *)
  by apply: prime_gt1.  (* 1 < p *)
apply: dvdn_fact.
  by apply: prime_gt0. (* 0 < p *)
by []. (* p <= m *)
Qed.
\end{coq}
For brevity we report in comments the goals solved by tactics.

We improve such script in two steps.  First, we take advantage of
\C{rewrite} simplification flags.  It is quite common
for an equation to be conditional, hence for\C{rewrite} to generate side
conditions.  It is good practice to solve such side conditions
as soon as possible.  The first two side conditions are indeed
trivial, and, as we did for \C{case}, can be solved by \C{//}.

\begin{coq}{}{}
Lemma example m p : prime p -> p %| m `! + 1 -> ~~ (p <= m).
Proof.
move=> prime_p; apply: contraL; move=> leq_p_m.
rewrite dvdn_addr.
  rewrite gtnNdvd //.
  by apply: prime_gt1.  (* 1 < p *)
\end{coq}
If one carefully compares the conclusion of \C{gtnNdvd} and
\C{prime_gt1} he can spot they are both rewriting rules.  While
the former features an explicit ``\C{.. = false}'', in the
latter one the ``\C{.. = true}'' part is hidden.  This means
both lemmas can be used as rewriting rules.  Rewriting with
\C{prime_gt1} leaves open the trivial goal \C{true} (i.e. \C{(true = true)}),
and the side condition \C{(prime p)}.  Both are trivial, hence
solved prefixing the line with \C{by}.

\begin{coq}{}{}
Lemma example m p : prime p ->
  p %| m `! + 1 -> ~~ (p <= m).
Proof.
move=> prime_p; apply: contraL; move=> leq_p_m.
rewrite dvdn_addr.
  by rewrite gtnNdvd // prime_gt1.
\end{coq}
The same considerations hold for the last goal.

\begin{coq}{}{}
Lemma example m p : prime p -> p %| m `! + 1 -> ~~ (p <= m).
Proof.
move=> prime_p; apply: contraL; move=> leq_p_m.
rewrite dvdn_addr.
  by rewrite gtnNdvd // prime_gt1.
by rewrite dvdn_fact // prime_gt0.
Qed.
\end{coq}

To sum up, both \C{apply:} and \C{rewrite} are able to find the right
instance of a quantified lemma and to generate sub goals
for its eventual premises.  Hypotheses can be named using \C{move=>}.

\subsection{Proofs by induction}\label{ssec:ind}

Lets take the well known induction principle for Peano's natural numbers
and lets formalize it in the language of \Coq{}.  It reads:
let $\mathcal{P}$ be a property of natural numbers, if
$\mathcal{P}$ holds on $0$ and if for all natural number $n$
if $\mathcal{P}$ hold on $n$ then it also hold on $n+1$, then $\mathcal{P}$
holds for any $n$.  Induction is typically regarded as a schema, where
the variable $\mathcal{P}$ stands for any property we could think about.

The language of \Coq{} gives to $\mathcal{P}$ a regular status, and induction,
instead of being a ``schema'' it is a regular lemma.

\begin{coq}{}{width=3.5cm}
About nat_ind.
\end{coq}
\begin{coqout}{}{width=9cm}
nat_ind : forall P : nat -> Prop,
  P 0 -> (forall n : nat, P n -> P n.+1) -> forall n : nat, P n
\end{coqout}
Here \C{P} is quantified exactly as \C{n} is, but its type is a bit more
complex and deserves an explanation.  As we have seen in the first
chapter the \C{->} denotes the type of functions, hence \C{P} is a
function from \C{nat} to \C{Prop}.  Recall that \C{Prop} is the type
of \emph{propositions}, i.e. something we may want to prove.  At the
light of that \C{P} is a function producing a proposition out of a natural
number.  For example the property of being an odd prime can be written as
follows:

\begin{coq}{}{}
(fun n : nat => odd n && prime n)
\end{coq}
Indeed if we take such function as the value for \C{P}, the first premise
of \C{nat_ind} becomes

\begin{coq}{}{width=6.5cm,title=P 0}
(fun n : nat => odd n && prime n) 0
\end{coq}
\begin{coq}{}{width=5.5cm,title=Equivalent by computation}
odd 0 && prime 0
\end{coq}
While the language of \Coq{} lets one express the induction principle
for natural numbers in a general way, the shape of the lemma is
tied to such data type.  For example the induction principle over
sequences is similar, but not identical.

\begin{coq}{}{width=3.5cm}
About list_ind.
\end{coq}
\begin{coqout}{}{width=9cm}
list_ind : forall A : Type, forall P : list A -> Prop,
  P [::] -> (forall x s, P s -> P (x :: s)) -> forall s, P s.
\end{coqout}

At the light of that, reasoning by induction on a term \C{t} means
finding the induction lemma associated to the type of \C{t} and synthesizing
the right predicate \C{P}.  The \C{elim:} tactic provides such
functionalities, while \C{apply:} does not.  Hence \C{elim:}
has to be used when reasoning by induction.\index[ssr]{\C{elim}}

The first service provided by \C{elim:} is to let one \emph{generalize}
the goal.  It is typically needed when the goal mention a recursive function
that uses an accumulator: its value is going to change during recursive calls,
hence the induction hypothesis must be general.

Another service provided by \C{elim:} is specifying an alternative
induction principle, for example one may reason by induction on
a list starting from its end.


\begin{coq}{}{width=3.5cm}
About last_ind.
\end{coq}
\begin{coqout}{}{width=9cm}
last_ind : forall A : Type, forall P : list A -> Prop,
  P [::] -> (forall s x, P s -> P (rcons x s)) -> forall s, P s
\end{coqout}
where \C{rcons} is a name for the operation of concatenating
a sequence with an element, as in \C{(s ++ [::x])}.

For example \C{las_ind} can be used to relate the
\C{foldr} and \C{foldl} iterators as follows:

\begin{coq}{}{}
Lemma foldl_rev z s : foldl z (rev s) = foldr (fun x z => f z x) z s.
\end{coq}

The proof uses the following lemmas:

\begin{coq}{}{title=Tools}
Lemma cats1 T s (z : T) : s ++ [:: z] = rcons s z.
Lemma foldr_cat T f (s1 s2 : seq T) :
  foldr f z0 (s1 ++ s2) = foldr f (foldr f z0 s2) s1.
Lemma rev_rcons T s (x : T) : rev (rcons s x) = x :: rev s.
\end{coq}

The complete proof script follows:

\begin{coq}{}{}
Lemma foldl_rev z s : foldl z (rev s) = foldr (fun x z => f z x) z s.
Proof.
elim/last_ind: s z => [|s x IHs] z //.
by rewrite -cats1 foldr_cat -IHs cats1 rev_rcons.
Qed.
\end{coq}

Here ``\C{elim/last_ind: s z}'' performs the induction using the
\C{last_ind} lemma on \C{s} after having generalized the initial value of
the accumulator \C{z}.  The resulting value for \C{P} is hence

\begin{coq}{}{}
(fun s => forall z, foldl z (rev s) = foldr (fun x z => f z x) z s)
\end{coq}

Thanks to the generalization, \C{IHs} states:

\begin{coq}{}{}
IHs : forall z : T, foldl f z (rev s) = foldr (fun x z => f z x) z s
\end{coq}
The quantification on \C{z} is crucial since the goal in the induction step,
just before we use \C{IHs} is the following one:

\begin{coqout}{}{}
foldl f z (rev (s ++ [:: x])) =
  foldr (fun y w => f w y) (foldr (fun y w => f w y) z [:: x]) s
\end{coqout}

The instance of the induction hypothesis that we need is
one where \C{z} takes \C{(foldr (fun y w => f w y) z [:: x])},
i.e. the value of the accumulator to \C{fold} for a list
which last element is \C{x}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Searching the library}
 The name \C{my_first_lemma} we chose in
section~\ref{ssec:groundeq} is actually very badly chosen since it is
hard to guess what the lemma is about by just reading its name.
This is problematic because we will soon see how the name of a lemma
is used whenever a proof appeals to such result,
similar to what a standard mathematical text would do by a reference or
a citation like ``this holds by lemma (7.3.4)''.  Lemmas are given a name,
and not just a number, because names are easier to remember and are more
stable (i.e. do not depend on the section where the corresponding lemma
is proved and don't require a renaming if a lemma is inserted before them).
The name can, and should, convey as much information as possible while
striving to stay short and handy. The
names used in the next examples are much more meaningful and actually
follow a systematic design pattern and more generally, the \mcbMC{}
library follows a naming convention that is documented in the
reference manual~\cite{ssrman}. Let's get a flavour of it by examples:

\begin{itemize}
\item the name of the lemma begins with the name of the main operation
  involved in the statement: \C{addn} for \C{addnA}, \C{odd} for
  \C{odd_mul}, \C{leq} in \C{leq0n}.
\item In \C{leq0n}, he other symbol involved in the name is ``0'',
that indeed plays an important role in the lemma.  The relative position
of ``0'' and ``n'' is chosen to recall to the user if the neutral element
 the left or the right argument of the binary operation \C{leq}.
\item The capital letter suffix ``A'' stands for associativity.
\end{itemize}

Capital letters in the suffix denote standard properties.
In particular ``A'' stands for associativity.  Standard properties are
always stated with predicates to impose
consistency in their stating.  Indeed the real statement of
\C{addnC} is \C{(commutative addn)}, where \C{addn} is the
name of the addition operation and \C{commutative} is the
following predicate.

\begin{coq}{name=macro}{title=Predicate for stating commutativity (suffix ``C'')}
Definition commutative op := forall x y, op x y = op y x.
\end{coq}

Predicates, being standard definitions, are completely transparent for the
system.\footnote{not yet for \C{Search}, but here I'm describing an ideal
situation}  Consistency is not only aesthetically, but ease the use of
lemmas: as we will see later, the order of the quantification may make
a lemma easier to use under certain circumstances.

The last general remark about naming convention worth making so early is that
uninteresting and recurrent lemmas must have a short names easy to identify and
disregard when reading a proof and at the same time easy to remember and short
to type when writing a proof.\marginnote{this is a mantra somewhat}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbsection{Rewrite, a swiss army knife}

Approximatively one third of the proof script in the \mcbMC{} library are
invocations of the \C{rewrite} tactic.  Such proof command provides many
features we cannot extensively cover here.  We just sketch a very common idiom
involving conditional rewrite rules and the mention the \C{RHS} pattern for
the casual reader.  The interested reader can find more about the pattern
language in Section~\ref{sec:rewrite2} or in the user manual of the
Ssreflect language~\cite{ssrman}.

So far we have solved side conditions using the simplification item \C{//}.
When this does not suffice, one can invoke another rewrite rule using
the optional iterator \C{?}.  A rule prefixed by \C{?} is applied to
all goals zero-or-more time.  For example, one could consider the
second sub goal that follows \C{rewrite dvdn_addr} a side condition
and solve it on the same line.

\begin{coq}{}{}
Lemma example m p : prime p -> p %| m `! + 1 -> ~~ (p <= m).
Proof.
move=> prime_p; apply: contraL; move=> leq_p_m.
rewrite dvdn_addr.
  by rewrite gtnNdvd // prime_gt1.
by rewrite dvdn_fact // prime_gt0.
Qed.
\end{coq}

Optionally rewriting with \C{dvdn_fact} on all goals affects only
the side condition, since the main goal mentions no divides predicate.
The same holds for \C{prime_gt0}.

\begin{coq}{}{}
Lemma example m p : prime p -> p %| m `! + 1 -> ~~ (p <= m).
Proof.
move=> prime_p; apply: contraL; move=> leq_p_m.
rewrite dvdn_addr ?dvdn_fact ?prime_gt0 //.
by rewrite gtnNdvd // prime_gt1.
Qed.
\end{coq}
\index[ssr]{\C{rewrite}! \C{?} (optional iteration)}

Another functionality offered by \C{rewrite} is the possibility
to focus the search for the term to be replaced by providing a
context.  For example the most frequent context is \C{RHS} (for Right
Hand Side) and is used to force rewrite to operate only on the right
hand side of an equational goal.

\begin{coq}{}{}
Lemma silly_example n : n + 0 = (n + 0) + 0.
Proof. by rewrite [in RHS]addn0. Qed.
\end{coq}
\index[ssr]{\C{rewrite}! \C{[in RHS]} (focusing)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{2}
\mcbsubsection{Rewrite contextual patterns}\label{sec:rewrite2}

This example illustrates how the \C{rewrite} tactic, provided a
rewrite rule like \C{leq_def}, \C{mulnBr} or \C{muln_eq0}, is able
to identify a
subterm in the goal to be substituted. The usability of the
tactic crucially relies on an appropriate combination of automation
and control. The user should be able to predict which subterm will be
substituted and to drive the tactic if needed, with enough control
options, but not too much verbosity. A key ingredient of the
\C{rewrite} tactic is hence the \emph{matching} algorithm which
elects this subterm from the arguments provided to the tactic. Let us
provide some insights on the power and on the limitations of this
algorithm, as well as on the control primitives that can drive it.

First, remember that our first attempt, using the simple
\C{rewrite leq_def} command only
affected the left hand side of the initial goal because of the
behaviour of this matching algorithm.
Indeed, the matching algorithm traverses the entire goal
left-to-right, looking for the first subterm matching pattern
\C{(_ <= _)},  and hence picks subterm \C{(m * n1 <= m * n2)}.
Now suppose we want to pick
the other instance of subterm matching this pattern in the goal. We
can use the command \C{rewrite [n1 <= _]leq_def}: the
pattern given by the user overrides the one inferred from the rewrite
rule and is used to select the subterm to be rewritten. In this case,
term \C{m * n1 <= m * n2} is ruled out because the first argument of
\C{<=}, namely \C{(m * n1)}, does not match the first argument \C{n1}
required in the user-given pattern. Therefore, \C{rewrite} picks term
\C{(n1 <= n2)}, in the right hand-side.

\begin{coq}{def=UserRwPat}{title=User rewrite pattern,width=7.7cm}
Lemma |*leq_mul2l*| m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite [n1 <= _]leq_def.
\end{coq}
\begin{coqout}{def=UserRwPat}{title=Proof status,width=5cm}
1 subgoal

m, n1, n2 : nat
==========================
(m * n1 <= m * n2) =
(m == 0) || (n1 - n2 == 0)
\end{coqout}

Another way of driving the matching algorithm is by providing a
\emph{context}, restricting the part of the goal to be explored. For
instance, in this case, the instance we want to pick is on
the right hand side of the identity to be proved. We can implement
this specification using the pattern \C{[in RHS]}:

\begin{coq}{def=UserRHSPat}{title=RHS pattern,width=7.7cm}
Lemma |*leq_mul2l*| m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite [in RHS]leq_def.
\end{coq}
\begin{coqout}{def=UserRHSPat}{title=Proof status,width=5cm}
1 subgoal

m, n1, n2 : nat
==========================
(m * n1 <= m * n2) =
(m == 0) || (n1 - n2 == 0)
\end{coqout}

More generally, one can provide context patterns like \C{[in X in T]}
where \C{X} is a variable name, bound in \C{T}. For instance pattern
\C{[in RHS]} is just syntactic sugar for the context pattern
\C{[in X in _ = X]}.  We invite the interested reader to check the
reference manual~\cite{ssrman} for more variants of patterns and for a
more precise description of the different phases in the matching
algorithm used by this tactic.

Lemma \C{leq_def} in fact does not exist in the library. Indeed the
identity it states holds by symbolic computation, and we have seen in
Section~\ref{ssec:proofcomp} that such a proof step can be omitted. However if we
try to omit the first \C{rewrite !leq_def} command, then the next one,
namely \C{rewrite -mulnBr} fails:

\begin{coq}{def=LeqMul2lproof2}{title=Failing rewrite,width=7.7cm}
Lemma |*leq_mul2l*| m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite -mulnBr.
\end{coq}
\begin{coqout}{def=LeqMul2lproof2}{title=Error,width=5cm}
The RHS of mulnBr
  (_ * _ - _ * _)
does not match any subterm
of the goal.
\end{coqout}

This indicates in particular that although term \C{(m * n1 <= m * n1)}
is convertible to term \C{(m * n1 - m * n1 == 0)}, the matching
algorithm is not able to see it. This is due to the compromise that
has been chosen, between predictability and cleverness. Indeed the
algorithm looks for a verbatim occurrence of the head symbol of the
pattern: in this case it hence looks for an occurence of \C{(_ - _)},
which is not found. As a consequence, we need an explicit step in the
proof script in order to expose the subtraction before being able to
rewrite right to left with \C{mulnBr}. However we can make this
rewrite step succeed using a user-provided pattern:

\begin{coq}{def=PatForConv}{title=Using a Pattern,width=7.7cm}
Lemma |*leq_mul2l*| m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite -[_ <= _]mulnBr.
\end{coq}
\begin{coqout}{def=PatForConv}{title=Proof status,width=5cm}
1 subgoal

m, n1, n2 : nat
==========================
(m * (n1 - n2) == 0) =
(m == 0) || (n1 <= n2)
\end{coqout}

Indeed, such a pattern identifies term \C{(m * n1 <= m * n2)}, as
their head symbols coincide. Now that we have elected a subterm, the
\C{rewrite} tactic is able to identify it with term
\C{(m * n1 - m * n1 == 0)}, itself an instance of the right instance
of \C{mulnBr}. Note that while matching only sees syntactic
occurrences of the
head symbols of patterns, it is able to compare the other parts of the
patterns up to symbolic computation.

Although lemma \C{leq_def} does not exist we can still use the
statement of this identity, which is simply the \emph{unfolding} of
the definition of the \C{leq} constant. The \C{rewrite} tactic can
perform this nature of step, as in the script:

\begin{coq}{def=Unfold}{title=Unfold,width=7.7cm}
Lemma |*leq_mul2l*| m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite /leq.
\end{coq}
\begin{coqout}{def=Unfold}{title=Proof status,width=5cm}
1 subgoal

m, n1, n2 : nat
==========================
(m * n1 - m * n2 == 0) =
(m == 0) || (n1 - n2 ==0)
\end{coqout}
\index[ssr]{\C{rewrite}! \C{/} (unfolding)}

where the command \C{rewrite /leq} has exposed the definition of
\C{leq} at all its occurrence in the goal. An unfolding step can be
driven by patterns as well, as in:

\begin{coq}{def=Unfold}{title=Focused unfold,width=7.7cm}
Lemma |*leq_mul2l*| m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite [in LHS]/leq
\end{coq}
\begin{coqout}{def=Unfold}{title=Proof status,width=5cm}
1 subgoal

m, n1, n2 : nat
==========================
(m * n1 - m * n2 == 0) =
(m == 0) || (n1 <= n2)
\end{coqout}

More generally, the \C{rewrite} tactic can be used to replace a
certain subterm of the goal by a convertible one:

\begin{coq}{def=Unfold}{title=Change,width=7.7cm}
Lemma |*leq_mul2l*| m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite -[n1]/(0 + n1).
\end{coq}
\begin{coqout}{def=Change}{title=Proof status,width=5cm}
1 subgoal

m, n1, n2 : nat
==========================
(m * (0 + n1) <= m * n2) =
(m == 0) || (0 + n1 <= n2)
\end{coqout}
\index[ssr]{\C{rewrite}! \C{-[$\ldots$]/($\ldots$)} (changing)}



% To get a better feeling on how lemmas are named let's see some other
% lemmas already proved for us.

% \begin{coq}{}{width=5cm,title=Lemmas of the library}
% Check add0n.
% Check addnC.
% \end{coq}
% \begin{coqout}{}{title=Response,width=7cm}
% add0n : forall n : nat, 0 + n = n
% addnC : forall n m : nat, n + m = m + n
% \end{coqout}

% First of all, note the quantification. So far \C{forall} was used to quantify
% over types and describe polymorphic functions.  Now it ranges over terms of
% type \C{nat} and describes generic lemmas, holding for any natural numbers
% \C{n} and \C{m}.

% Going back to the naming conventions, note that both names begin with ``add'',
% that is the principal operation involved.  In particular is the head symbol
% (the most external one) in the left hand side of the equation.  The addition
% operation is the one on natural numbers, hence then ``n'' component in
% the suffix.

% For the first equation, the other symbol involved in the name is ``0'',
% that indeed plays an important role in the lemma.  The relative position
% of ``0'' and ``n'' is chosen to recall to the user if the neutral element
% is added to the left or to the right.  For example the lemma named
% \C{addn0} would state \C{forall n : nat, n + 0 = n}.


% \subsection{Writing proof scripts}

% indentation, naming, using closing tactics.

% \subsection{Searching existing content}

% END OF THE REVISED ORGANIZATION.
%%%--------------- oldies

% \subsection{Stating and proving an equality}
%
% The \C{by} terminator is systematically used to prefix any proof sentence
% that terminates a goal.  A proof sentence ends with a dot, and can
% combine more than one proof command via the semi colon punctuation,
% again more examples will follow.
% The use of \C{by} is not limited to asserting no goals are left,
% but is also used to close goals by trivial means.  The notion of triviality
% is an important point we will discuss many times, for now lets just
% say it is extensible by the user and that it includes reflexivity.
% Hence the previous proof can be written as \C{by [].} where \C{[]}
% denotes the empty list of proof commands.
%
% \begin{coq}{title=Same proof}
% Lemma my_first_lemma : 3 = 3.
% Proof. by []. Qed.
% \end{coq}
%
% The \C{Qed} keyword terminates the proofs, checks it, and adds to
% the library the new lemma.  We can hence access
%
% Given that our first lemma is now part of the library as the result
% of the \C{Qed} command we can access it.
% \marginnote{should we use About ?}
%
% \begin{coq}{width=6cm,title=Printing a lemma statement}
% Check my_first_lemma.
% \end{coq}
% \begin{coqout}{title=Response,width=6cm}
% my_first_lemma : 3 = 3
% \end{coqout}
%
% Now that we are satisfied with the statement, we llok into proving it.
% At the current stage we need to use the two already existing
% lemmas \C{add0n} and \C{addnC} and the fact that the equality predicate
% is substitutive: given an equation we can replace any instance of
% its left hand side with the corresponding instance of the right hand side.
%
% The command is called rewrite, and its argument its called rule.
%
% \begin{coq}{title=Pedestrian proof}
% rewrite add0n.
% rewrite addnC.
% by [].
% Qed.
% \end{coq}
%
% \begin{coqout}{title=Response line 1,width=6cm}
% 1 subgoal
%
%   a, b : nat
%   ============================
%    a + b = b + a
% \end{coqout}
% \begin{coqout}{title=Response line 2,width=6cm}
% 1 subgoal
%
%   a, b : nat
%   ============================
%    b + a = b + a
% \end{coqout}
%
% Explain the job of instantiation rewrite does: picks \C{(a + b)} for
% \C{n} in \C{add0n} and picks \C{a} for \C{n} and \C{b} for \C{m} in
% \C{addnC}.  Explain it is guided by the head symbol \C{+} and traverses
% the goal left to right.  Define "pattern".
%
% \begin{coq}{width=4cm,title=The new lemma}
% Check add0nmC.
% \end{coq}
% \begin{coqout}{title=Response,width=8cm}
% add0nmC : forall a b : nat, 0 + (a + b) = b + a.
% \end{coqout}
%
% The rewrite proof command is very recurrent, hence a shorter form
% using multiple rules.
%
% \begin{coq}{title=More compact proof}
% Lemma add0nmC a b : 0 + (a + b) = b + a.
% Proof. by rewrite add0n addnC. Qed.
% \end{coq}
%
% Note that the equations are used in order, e.g. the script
%
% \begin{coq}{title=Wrong proof}
% Lemma add0nmC_bad a b : 0 + (a + b) = b + a.
% Proof. by rewrite addnC add0n. Qed.
% \end{coq}
%
% Fails because \C{addnC} flips \C{0} with \C{(a + b)}, then
% \C{add0n} finds no matching sub term.  In any case the proof
% is wrong, commutativity has to be employed to flip \C{a} and \C{b},
% or \C{b} and \C{a}, but not \C{0}.  If one wants to keep the rules
% in that order he needs to drive \Coq{} by better specifying the
% pattern he infers from \C{addnC}.
%
% \begin{coq}{title=Rewrite pattern}
% Lemma add0nmC a b : 0 + (a + b) = b + a.
% Proof. by rewrite [a + _]addnC add0n. Qed.
% \end{coq}
%
% Explain pattern: overrides the pattern inferred.
% Explain underscore: saves space if b is large.
%
% Discuss: stating an equation (LHS is bigger).
%
% \subsection{Equality up to computation}
%
% As we said at the beginning, equality is up to computation.
% Since \C{(0 + 3)} computes to \C{3}, proving the equality among
% the two expressions is trivial.
%
% \begin{coq}{title=Computation in proofs}
% Eval compute in (0 + 3).  (* prints 3 *)
% Eval compute in (true || false).  (* prints true *)
% Lemma example3 : 0 + 3 = 3.
% Proof. by []. Qed.
% \end{coq}
%
% Indeed \C{reflexivity}, and \C{by []} as well, take computation
% into account.
% Note it also works for symbolic expressions.
%
% \begin{coq}{title=Computation in proofs}
% Lemma add0n n : 0 + n = n.
% Proof. by []. Qed.
% \end{coq}
%
% Explain addn0 is different, why, and that it will be shown later,
% when induction will be introduced.
%
% If we go back playing with the previous proof, we see that the
% last rule can be omitted.
%
% \begin{coq}{title=This also works}
% Lemma add0nm_bad a b : 0 + (a + b) = b + a.
% Proof. by rewrite [a + _]addnC. Qed.
% \end{coq}
%
% The reason is that \C{(0 + (b + a))} is equal
% to \C{(b + a)} up to computation.
% Note that add0n  is not only for free (in its proof) but
% also in its use.
%
% Maybe talk about \C{/=} here.
%
% \begin{coq}{title=This also works}
% Lemma add0nm_bad a b : 0 + (a + b) = b + a.
% Proof. by rewrite /= addnC. Qed.
% \end{coq}
%
% Note the pattern can go, since \C{/=} leaves the goal with
% no ambiguity.
% Note that, if we mind computation, the lemma is just an alias
% for \C{addnC} and hence is useless.  It may feel depressing, but
% it is actually a very important hygiene measure: only useful lemmas
% are kept, trade off between all combinations or few base blocks that
% combine well (harder in principle, requires a language that glues well).
%
%
%
% % \subsection{old}
% %
% % \begin{itemize}
% % \item \Coq{} comes with an equality prexdicate, that we see as axiomatic for the
% % moment (in this section). It is called \C{eq} and has an infix
% % notation \C{=}. Example: \C{Check 3 = 3}, \C{Check 3 = 4}.
% % \item Observe that, \C{Check} just checks the well-formedness of the
% %   statement, not its truth. Well-formedness here means that \C{=}
% %   requires both hand-sides to be of the same type.
% %   Example \C{Check 3 = [::4]}. Observe that statement also have a
% %   type, called \C{Prop}.
% % \item We can give a name to a statement, that we would like to prove
% %   formally. Example \C{Lemma foo : 3 = 3}. Observe what happens at the
% %   level of the interface (we start a proof).
% % \item And now, how to prove equality statements. Observationaly, \C{=}
% %   behaves as expected: this is trivally true because \C{=} is
% %   reflexive.
% % \item End of the proof, \C{Qed}.
% % \item Now we have a theorem called \C{foo} at hand in the
% %   environement: \C{Check foo}. We can use it but it is useless...
% % \item In fact the libraries you load provide theorems that you can use
% %   in your proofs. Example:  \C{Check add0n}, \C{Check addnC}. Note the
% %   universal quantification.
% % \item How to state lemmas like this:
% % \C{Example toto a b : 0 + (a + b) = a + b}.
% % \item Equality is not just reflexive, it is also substitutive. This is
% %   implemented via the \C{rewrite} tactic, that we can use to prove
% %   this lemma, using \C{add0n}. Note that the tactic found the right
% %   instance of \C{add0n} to be used, with \C{(a + b)}.
% % \item \C{Qed}, \C{Check}, observe the universal quantification.
% % \item Rewrite steps can be chained, in order. Example:
% % \C{Example toto a b : 0 + (a + b) = b + a}. can be proved by rewriting
% % \C{add0n} then, \C{addnC}. Note that \C{addnC} then \C{add0n} does
% % something different.
% % \item In fact reflexivity is more than syntactic equality. Prove
% % \C{3 + 1 = 4}, \C{true || false = true}. But also with variables,
% % e.g. \C{add0n}, connect with the programs written in the previous
% % chapters.
% %
% % \item More advanced forms of proofs by the \C{rewrite} tactic allow to
% %   select a pattern and to simplify the goal for free by
% %   computation. Hence \C{addn0} just does not need to be stated
% %   explicitely in the proof script. Warning: simpl is a Pandora
% %   box. This should come very early
% %   and go with/before boolean reflection style proofs by rewriting.
% %
% % \item Special case of equality statements that play a pervasive role
% %   throughout the libraries: \C{_ = true}. For instance
% %   \C{odd (2 * x + 7) = true}. This is both a 'logical' statement,
% %   saying that any expression \C{(2x+7)} is an odd number, and
% %   an equation that can be rewriten during the course of a proof. Find
% %   an example, like \C{odd (2 * x + 7) || odd (2 * x)}. rewrite and
% %   compute.
% %
% % \item Now we should point the coercion, because people will search and
% %   check.
% % \end{itemize}
%
%
%
% \mcbLEARN{case}
% \mcbREQUIRE{}
% \mcbPROVIDE{case, -, indentation, brute force proofs, semicolon, => after case}
% \mcbLEVEL{1}
% \mcbsection{Case analysis}
%
% In programming inductive data is matched against to consider all
% possible cases.  In the same way, when we reason on a program
% whose input is symbolic, we can proceed by considering all possible
% cases.
%
% \begin{coq}{title=First De Morgan's law: pedestrian proof}
% Lemma negb_and (a b : bool) : ~~ (a && b) = ~~ a || ~~ b.
% Proof.
% case: a.
% - by []
% case: b.
% - by [].
% by [].
% Qed.
% \end{coq}
% \begin{coqout}{title=Response line 3,width=8cm}
% 2 subgoals
%
%   b : bool
%   ============================
%    ~~ (true && b) = ~~ true || ~~ b
%
% subgoal 2 is:
%  ~~ (false && b) = ~~ false || ~~ b
% \end{coqout}
%
% Explain the decorator and the indentation policy.
% Note a removed from context, substituted by true and false.
% Note first goal computes to b=b.
% Note second goal does not, computation blocked, we case b.
%
% \begin{coqout}{title=Response line 5,width=8cm}
% 2 subgoals
%
%   ============================
%    ~~ (false && true) = ~~ false || ~~ true
%
% subgoal 2 is:
%  ~~ (false && false) = ~~ false || ~~ false
% \end{coqout}
%
% Now all computes.  We are not satisfied, we could write
% as the only tactic \C{case: a; case: b.}.
%
% \begin{coqout}{title=Response,width=8cm}
% 4 subgoals
%
%   ============================
%    ~~ (true && true) = ~~ true || ~~ true
%
% subgoal 2 is:
%  ~~ (true && false) = ~~ true || ~~ false
% subgoal 3 is:
%  ~~ (false && true) = ~~ false || ~~ true
% subgoal 4 is:
%  ~~ (false && false) = ~~ false || ~~ false
% \end{coqout}
%
% Explain semicolon.
% Note that all computes. Note that this is always possible
% for finitary data, it amounts to comprehensive testing.
%
% \begin{coq}{title=First De Morgan's law}
% Lemma negb_and (a b : bool) : ~~ (a && b) = ~~ a || ~~ b.
% Proof. by case: a; case: b. Qed.
% \end{coq}
%
% other examples, exercises, can be
%
% \begin{coq}{title=possible exampels}
% Lemma andbA : associative andb.        Proof. by do 3!case. Qed.
% Lemma orbCA : left_commutative orb.    Proof. by do 3!case. Qed.
% Lemma andbN b : b && ~~ b = false.     Proof. by case: b. Qed.
% \end{coq}
%
% to explain A and N suffixes, plus do iteration, plus stack top.
%
% When data is not finitary, then case is not sufficient.
%
% \begin{coq}{}
% Lemma eqnxx (x : nat) : eqn x x = true.
% Proof. case: x => [|x'].
% \end{coq}
%
% Name subterms.
%
% \begin{coqout}{title=Response,width=8cm}
%   x' : nat
%   ============================
%    eqn x'.+1 x'.+1 = true
% \end{coqout}
%
% But before induction we look at implication
%
% \mcbLEARN{apply}
% \mcbREQUIRE{}
% \mcbPROVIDE{apply, ->, =>, //}
% \mcbLEVEL{1}
% \mcbsection{Implication and backchaining}
%
% \begin{coq}{width=4cm}
% Check @dvdn_mul.
% \end{coq}
% \begin{coqout}{title=Response,width=8cm}
% dvdn_mul : forall d1 d2 m1 m2 : nat,
%   d1 %| m1 -> d2 %| m2 -> d1 * d2 %| m1 * m2
% \end{coqout}
%
% Explain implication symbol, the ambiguity with function space will
% be explained later on.
%
% \begin{coq}{}
% Lemma stupid x : 3 * x %| 6 * x^2.
% Proof.
% apply: dvdn_mul.
% - by [].
% apply: dvdn_mulr.
% exact: dvdnn.
% Qed.
% Lemma stupid2 x : 3 * x %| 6 * x^2.
% Proof.
% rewrite dvdn_mul // dvdn_mulr // dvdnn.
% Qed.
% \end{coq}
%
% How do we prove this kind of lemmas
%
% \begin{coq}{}
% Lemma stupid3 x y : x %| y -> 3 * x %| 6 * y.
% Proof.
% move=> div_xy.
% by apply: dvdn_mul.
% Qed.
% \end{coq}
%
% by looks in the hyps.
%
% \begin{coq}{}
% Lemma stupid3 x y (div_xy : x %| y) : 3 * x %| 6 * y.
% Proof. exact: dvdn_mul. Qed.
% \end{coq}
%
% equivalent syntax, uncommon.
%
% Make another example working on the stack
%
% \begin{coq}{}
% Lemma andb_idl (a b : bool) : (b -> a) -> a && b = b.
% Proof. by case: a; case: b => // ->. Qed.
% \end{coq}
%
% note // in =>, note -> in =>, note runs on 4 goals.
%
% one last example with true=false in the context.
%
% \section{Proofs by induction}
%
% \begin{coq}{}
% Lemma eqnxx x : eqn x x.
% Proof.
% elim: x=> [|x' IH].
% rewrite /=.
% apply: IH.
% by [].
% Qed.
% Lemma eqnxx x : eqn x x.
% Proof. by elim: x. Qed.
% \end{coq}
%
% requires induction.
%
% \section{Curry-Howard}
%
% Explain CH for arrows, foralls, equality and induction. Show Proof for
% some examples of proofs.
%
% First implication, start with comparing the source and target of the
% arrows that are common to this chapter and the preceeding.
%
% \begin{coq}{}
% Inductive |*list*| (A : Type) : Type :=
%     nil : list A | cons : A -> list A -> list A
%
% list: Type -> Type
%
% Definition |*is_equal_to_2*| (x : nat) : x = 2.
%
% is_equal_to_2 : nat -> Prop
% \end{coq}
%
%
%
%
%
%
% \section{To be sorted}
%
% \subsection{Universal quantification}
%
% \begin{coq}{}
% Variable A : Prop.
% Definition toto : A -> A := fun x => x.
% Lemma  toto : A -> A.
%  Proof.
%   move => x.
%   Show Proof.
%   apply: x.
%  Qed.
% \end{coq}
%
% Note : \C{toto :  A -> A : Prop}
% discuss interactive proof construction, other example with a real
% apply that open subgoals.
%
% In CH style we see a proof, where lambdas/apply work too (same tactics)
%
% Specialization of an quantified lemma via application (maybe also
% \C{move/(_ x) in H}).
% Soft intro of the work of unification (FO) during application (infer
% arguments of conclusion's predicate symbol \C{prime _}).
%
% We should also display her  HO "predicators": commutative.  Discuss
% order of quantification in transitive and similar, naming conventions
%
% \subsection{Curry-Howard for equality proofs}
%
%
% Show \C{rewrite -H}, plus the idea that one may want to select
% occurrences (with simple patterns).
%
%
% May be should we say rather early that rewriting under binders is not
% allowed by the system.
%
% \subsection{proof term for rewrite (CH)}
%
% There are also proof terms for equality proofs (show \C{refl})
% The work rewrite does is non trivial (infer P)
%
% \begin{coq}{}
% Check eq_rect (* : forall P : nat -> Prop, .... forall n, P n *)
% \end{coq}
%
% Write a proof term by hand.
% (note that it works because of beta being part of conversion).
% See that rewrite does the verbose part for you (infer P).
%
% An example of ambiguous P from above, driving rewrite means driving the
% synthesis of P.
%
% \subsection{other eq related tactics}
%
% Congr, injection \C{[= ]}, discriminate (//), \C{->}.
%
%
% \subsection{proof term for induction}
%
% Again show that it boils down to infer P
%
%
% \subsection{proofs by induction in their generality}
%
% Show that even for commutativity of addition one needs to
% "load the goal" (or to help synthesize a more general P).
%
%
% \section{Exercises (explained)}
%
% xor-odd, then cancel encode decode, or something on primes.
%
% Take the occasion to present last/first, bullets, by, syntaxes for
% \C{=> [|IH x xs]} after a case.
%
%
% \section{Notes}
%
% % From calculability to proofs, hence the CC, and the fact that
% % reasoning principles without a computational content become axioms.
% %
% % This is a non technical chapter and message should be:
% % \begin{itemize}
% % \item instantiation of a universal statement is application (also the pair)
% % \item Excluded middle is not available by default (choice?)
% % \item Conversion as a pervasive indistinguishably, what inside
% %   (beta, definition unfolding,...)
% % \item Dependent types: eq, sigma (which example?)
% % \end{itemize}
% %
% % One options is: avoid relating type theory and other logics. We say:
% % we have a formal game where the basic elements are programs/functions
% % that come with types to avoid confusion. full stop. (no relation with
% % proof theory, set theory). maybe mention that roots are in calculability (hence
% % the choice to pick functions as primitive and not sets). This is lucky because
% % (computable) functions are today executable by a computer.  Still not all
% % concepts are "computable" hence some principles are problematic: EM,.... we
% % mainly stay in the lucky fragment (again no propaganda on intuitionistic logic,
% % constructive math; just a mention).
% %
%
% running topic: statements and their proofs. This chapter provides a gentle
% introduction to the implicative fragment of the logic and to the
% interactive construction of formal proofs. The reference to
% Curry-Howard should come as late as possible. It should indeed be
% possible to present a substantial amount of example and intuitions
% before explaining this. Specially if we carefully use the automated
% introduction of variables bound before the semi-column. At the tactic
% level, we should be able to avoid the need for Curry Howard related
% constructions like \C{apply: (H x)} in the first part of the chapter.
%
% \begin{itemize}
% \item \C{Prop} as the type of statements
% \item forall-lambda, predicates as functions to Prop.  The difference with the forall in the previous chapter is that the type the var ranges in is not "Type" but a data type like nat.
% \item examples with implicative predicate logic, modus ponens
% \item definition = lemma (proofs of implications are lambdas-app)
% \item tactics to generate the terms in a less pedestrian way (move, apply)
% \item if one calls Show Proof in the middle he sees one is building
% 	the proof term incrementally, as one draws a proof tree (in CH style)
% \end{itemize}
%
% Now we make the point of Qed, the kernel checks the term produced via
% tactics (or hand-written).
%
% Examples of predicates: equality
% \begin{itemize}
% \item not to talk about indexes of inductive families we introduce eq as
% 	an axiom and refl as another axiom to prove eq and we insist on
% 	conversion
% \item examples, among which a beta expansion (to help later on with elimination)
% \item now, what are the proofs of an equality? maybe we start with rewrite
% \item examples are symmetry, transitivity
% \item then we give the elimination principle as an axiom, and explain the
% 	work rewrite does in synthesizing the predicate
% \item the job of rewrite is not trivial nor un-ambiguous: to drive the synthesis show occurrence selection (later on we see the same problem for elim)
% \item other exercise on other eq related "commands" like discriminate, injection arrows, congr.
% \end{itemize}
%
% Showing universal properties on inductive data
% \begin{itemize}
% \item first enouce some lemmas on concrete examples, like not true = false,
% 	then try to say "froall b : bool, ...".
% \item first on enumerated types (bool) via case
% \item them on nat via case and elim
% \item then show the proof term as an application of nat-rect, again the problem
% 	is to write down P and elim does that.
% \item here an additional problem: loading the goal before using it to generate P
% \end{itemize}
%
% We should manage to prove stuff on the concepts defined in chapter 1,
% notably \C{odd(a+b) = xor (odd a) (odd b)}.  But before you need lemmas
% on "odd (S x) = not (odd x)", to make the point that the proof is trivial with
% a library that has all the needed facts.  Also the base case goes away by ssr (in general spell out where the computation saves work).
%
% Comparison with other approaches:
% \begin{itemize}
% \item Compare an axiomatic, equational presentation of arithmetic to
%   its formalization as an inductive type with functions that
%   compute.
% \end{itemize}
%
%
% Another example is set-nth of rcons as done by Florent Hivert, that has not
% developed the theory of set-nth with cat, and hence messes up the proof
% that gets shorter if one does the homework.
%
% Another example could be a proof that requires the induction principle
% on nat that (strong/course of values induction).
%
% A maybe good example that forces you to do patterns or occ numbers and explain
% that 2  contains syntactically 0 is the proof that code/decode cancel (in
% choice).
%
% We lack example with a mathematical interest, maybe arithmetic is sufficient like binomial.v.
%
% We need also /= and hence Arguments simple never (and we try to omit nosimpl).
% Maybe we should document that nosimpl has been superseeded by
% the option of Arguments in the manual.
% Let say that controlling reduction is an important topic when you
% do ssr style.
%
% In this chapter we present several features of the proof language, but it it is
% not about the proof language itself (reference manual). What one adds to the
% reference manual here is an example of usage in the right context of the
% commands.  E.g. we give an hint of what patterns do (rewrite) but we don't
% discuss all the matching discipline... nor the most advanced syntaxes)
